<!DOCTYPE html><html lang="en"><head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/png+xml" href="/icon/fp black.png">
    <title>Experiment</title>

    <link href="../jspsych-bundle/index.css" rel="stylesheet" type="text/css">
    <script src="https://cdn.jsdelivr.net/gh/jspsych/jspsych@jspsych@7.0.0/examples/js/webgazer/webgazer.js"></script>

    <script src="../jspsych-bundle/index.js"></script>

    <style>
      body {
        margin: 0;
        padding: 0;
        background-color: #f0f0f0;
      }
      #jspsych-container {
        width: 100%;
        height: 100vh;
      }
      #jspsych-target {
        width: 100%;
      }
    </style>
  </head>
  <body>
    <div id="jspsych-container">
      <div id="jspsych-target"></div>
    </div>

    
  

<script id="generated-script">

  // --- Recolectar metadata del sistema ---
  const getMetadata = () => {
    const ua = navigator.userAgent;
    let browserName = 'Unknown';
    let browserVersion = 'Unknown';
    
    if (ua.indexOf('Firefox') > -1) {
      browserName = 'Firefox';
      browserVersion = ua.match(/Firefox\/(\d+\.\d+)/)?.[1] || 'Unknown';
    } else if (ua.indexOf('Chrome') > -1) {
      browserName = 'Chrome';
      browserVersion = ua.match(/Chrome\/(\d+\.\d+)/)?.[1] || 'Unknown';
    } else if (ua.indexOf('Safari') > -1) {
      browserName = 'Safari';
      browserVersion = ua.match(/Version\/(\d+\.\d+)/)?.[1] || 'Unknown';
    } else if (ua.indexOf('Edg') > -1) {
      browserName = 'Edge';
      browserVersion = ua.match(/Edg\/(\d+\.\d+)/)?.[1] || 'Unknown';
    }
    
    let osName = 'Unknown';
    if (ua.indexOf('Win') > -1) osName = 'Windows';
    else if (ua.indexOf('Mac') > -1) osName = 'macOS';
    else if (ua.indexOf('Linux') > -1) osName = 'Linux';
    else if (ua.indexOf('Android') > -1) osName = 'Android';
    else if (ua.indexOf('iOS') > -1) osName = 'iOS';
    
    return {
      browser: browserName,
      browserVersion: browserVersion,
      os: osName,
      screenWidth: window.screen.width,
      screenHeight: window.screen.height,
      screenResolution: `${window.screen.width}x${window.screen.height}`,
      viewportWidth: window.innerWidth,
      viewportHeight: window.innerHeight,
      language: navigator.language,
      userAgent: ua,
      startedAt: new Date().toISOString()
    };
  };
  
  const metadata = getMetadata();

  // --- Socket.IO para tracking en tiempo real ---
  const socketScript = document.createElement('script');
  socketScript.src = '/socket.io/socket.io.js';
  socketScript.onload = () => {
    window._socketReady = true;
  };
  document.head.appendChild(socketScript);

  function waitForSocket() {
    return new Promise(resolve => {
      if (window._socketReady) return resolve();
      const interval = setInterval(() => {
        if (window._socketReady) {
          clearInterval(interval);
          resolve();
        }
      }, 50);
    });
  }

  const trialSessionId =
    (crypto.randomUUID
      ? crypto.randomUUID()
      : Math.random().toString(36).slice(2, 10));

  let participantNumber;
  let socket;

  async function saveSession(trialSessionId) {
   
   const res = await fetch("/api/append-result/b85d6c4c-105a-47fe-893d-43141af7db0b", {
      method: "POST",
      headers: { "Content-Type": "application/json", Accept: "*/*" },
      body: JSON.stringify({
        sessionId: trialSessionId,
        metadata: metadata
      }),
    });
  
    const result = await res.json();
    participantNumber = result.participantNumber;
    return participantNumber;
    
  }

  (async () => {

    localStorage.removeItem('jsPsych_jumpToTrial');
    
    // Esperar a que Socket.IO esté listo
    await waitForSocket();
    socket = io();
    
    participantNumber = await saveSession(trialSessionId);

    if (typeof participantNumber !== "number" || isNaN(participantNumber)) {
      alert("The participant number is not assigned. Please, wait.");
      throw new Error("participantNumber not assigned");
    }

    // Conectar sesión con el servidor via WebSocket
    socket.emit('join-experiment', {
      experimentID: 'b85d6c4c-105a-47fe-893d-43141af7db0b',
      sessionId: trialSessionId,
      state: 'initiated',
      metadata: metadata
    });

    // --- Branching logic functions (outside initJsPsych for timeline access) ---
    window.nextTrialId = null;
    window.skipRemaining = false;
    window.branchingActive = false;
    window.branchCustomParameters = null; // Store custom parameters for the next trial

    const evaluateCondition = (trialData, condition) => {
      // All rules in a condition must be true (AND logic)
      return condition.rules.every(rule => {
        // New flat structure: rule.column contains the direct column name
        // e.g., "ButtonResponseComponent_1_response" or "response" for normal plugins
        const columnName = rule.column || rule.prop; // Fallback to rule.prop for backward compatibility
        
        if (!columnName) {
          console.warn('No column name specified in rule:', rule);
          return false;
        }
        
        // Get value directly from the column
        const propValue = trialData[columnName];
        
        if (propValue === undefined) {
          console.warn('Column not found in trial data:', columnName);
          return false;
        }
        
        const compareValue = rule.value;
        
        // Handle array responses (multi-select or single-select returned as array)
        if (Array.isArray(propValue)) {
          const matches = propValue.includes(compareValue) || propValue.includes(String(compareValue));
          switch (rule.op) {
            case '==':
              return matches;
            case '!=':
              return !matches;
            default:
              return false;
          }
        }
        
        // Convert values for comparison (for non-array values)
        const numPropValue = parseFloat(propValue);
        const numCompareValue = parseFloat(compareValue);
        const isNumeric = !isNaN(numPropValue) && !isNaN(numCompareValue);
        
        switch (rule.op) {
          case '==':
            return isNumeric ? numPropValue === numCompareValue : propValue == compareValue;
          case '!=':
            return isNumeric ? numPropValue !== numCompareValue : propValue != compareValue;
          case '>':
            return isNumeric && numPropValue > numCompareValue;
          case '<':
            return isNumeric && numPropValue < numCompareValue;
          case '>=':
            return isNumeric && numPropValue >= numCompareValue;
          case '<=':
            return isNumeric && numPropValue <= numCompareValue;
          default:
            return false;
        }
      });
    };
    
    const getNextTrialId = (lastTrialData) => {
      if (!lastTrialData || !lastTrialData.trials || !lastTrialData.trials[0]) {
        return null;
      }
      
      const trial = lastTrialData.trials[0];
      
      // Check if trial/loop has branches
      if (!Array.isArray(trial.branches) || trial.branches.length === 0) {
        return null;
      }
      
      // Check if there are conditions to evaluate
      const hasBranchConditions = Array.isArray(trial.branchConditions) && trial.branchConditions.length > 0;
      
      // Check if any condition has customParameters
      const hasCustomParameters = hasBranchConditions && 
        trial.branchConditions.flat().some(condition => 
          condition && condition.customParameters && 
          Object.keys(condition.customParameters).length > 0
        );
      
      // If there are no conditions AND no custom parameters, auto-branch to first branch
      if (!hasBranchConditions && !hasCustomParameters) {
        console.log('No conditions or custom parameters defined, auto-branching to first branch:', trial.branches[0]);
        return trial.branches[0];
      }
      
      // If there are no conditions but there ARE custom parameters, we can't auto-branch
      // We need to evaluate conditions to know which customParameters to use
      if (!hasBranchConditions && hasCustomParameters) {
        console.log('Custom parameters exist but no conditions, cannot auto-branch');
        return null;
      }
      
      // If there ARE conditions, evaluate them (regardless of how many branches there are)
      // branchConditions is an array of arrays, flatten it first
      const conditions = trial.branchConditions.flat();
      
      // Evaluate each condition (OR logic between conditions)
      for (const condition of conditions) {
        if (!condition || !condition.rules) {
          console.warn('Invalid condition structure:', condition);
          continue;
        }
        
        if (evaluateCondition(trial, condition)) {
          // Store custom parameters if they exist
          if (condition.customParameters) {
            window.branchCustomParameters = condition.customParameters;
          }
          return condition.nextTrialId;
        }
      }
      
      // No condition matched - do NOT branch (conditions were defined but none matched)
      return null;
    };

    // Track pending data saves to ensure all complete before finishing
    const pendingDataSaves = [];

    const jsPsych = initJsPsych({
          display_element: document.getElementById('jspsych-container'),


    extensions: [{type: jsPsychExtensionWebgazer}],

    on_data_update: function (data) {
      // Create and track the promise for this data save
      const savePromise = fetch("/api/append-result/b85d6c4c-105a-47fe-893d-43141af7db0b", {
        method: "PUT",
        headers: { "Content-Type": "application/json", Accept: "*/*" },
        body: JSON.stringify({
          sessionId: trialSessionId,
          response: data,
        }),
      })
      .then(res => {
        if (!res.ok) {
          console.error('Error saving trial data:', res.statusText);
        }
        return res;
      })
      .catch(error => {
        console.error('Error in on_data_update:', error);
      })
      .finally(() => {
        // Remove from pending once complete
        const index = pendingDataSaves.indexOf(savePromise);
        if (index > -1) {
          pendingDataSaves.splice(index, 1);
        }
      });
      
      pendingDataSaves.push(savePromise);
      
      // Actualizar estado a 'in-progress' en la primera actualización
      if (data.trial_index === 0 && socket) {
        socket.emit('update-session-state', {
          experimentID: 'b85d6c4c-105a-47fe-893d-43141af7db0b',
          sessionId: trialSessionId,
          state: 'in-progress'
        });
      }
      
      // Solo evaluar branching si el trial/loop tiene un trial_id o loop_id válido
      if ((!data.trial_id || data.trial_id === undefined) && (!data.loop_id || data.loop_id === undefined)) {
        return;
      }
      
      const lastTrialData = jsPsych.data.getLastTrialData();
      const trial = lastTrialData.trials ? lastTrialData.trials[0] : null;
      
      // Verificar si este trial/loop tiene branches
      if (!trial || !trial.branches || trial.branches.length === 0) {
        return; // No tiene branches, no hay nada que hacer
      }
      
      // IMPORTANTE: Si el trial está dentro de un loop (isInLoop = true),
      // NO activar el branching global. Los trials dentro de loops usan su propio
      // sistema de branching con variables locales (loopNextTrialId, etc.)
      if (trial.isInLoop === true) {
        return;
      }
      
      const nextTrialId = getNextTrialId(lastTrialData);
      
      if (nextTrialId) {
        // Check if nextTrialId is "FINISH_EXPERIMENT"
        if (nextTrialId === 'FINISH_EXPERIMENT') {
          jsPsych.abortExperiment('Experiment finished by branching condition', {});
          return;
        }
        
        window.nextTrialId = nextTrialId;
        window.skipRemaining = true;
        window.branchingActive = true;
      }
    },

  on_finish: async function() {
    // Wait for all pending data saves to complete
    if (pendingDataSaves.length > 0) {
      console.log('Waiting for', pendingDataSaves.length, 'pending data saves to complete...');
      await Promise.allSettled(pendingDataSaves);
      console.log('All data saves completed');
    }
    
    // Marcar como completado
    if (socket) {
      socket.emit('update-session-state', {
        experimentID: 'b85d6c4c-105a-47fe-893d-43141af7db0b',
        sessionId: trialSessionId,
        state: 'completed'
      });
    }
    
    await fetch("/api/complete-session/b85d6c4c-105a-47fe-893d-43141af7db0b", {
      method: "POST",
      headers: { "Content-Type": "application/json", Accept: "*/*" },
      body: JSON.stringify({
        sessionId: trialSessionId,
      }),
    });
    // jsPsych.data.displayData();
  }
});

const timeline = [];

// Global preload for all uploaded files from Timeline



    const test_stimuli_New_Trial = [{components: [{ type: "HtmlComponent", coordinates: {"x":0,"y":-0.12568306010928984}, width: 200, height: 50, stimulus: "<div id=\"i9zw\" style=\"box-sizing: border-box;\">Welcome to the experiment, press 'Start' to begin</div>", name: "texto" }],
response_components: [{ type: "ButtonResponseComponent", coordinates: {"x":-0.24180327868852503,"y":0.13907103825136602}, width: 200, height: 50, choices: ["Start"], name: "boton 1" }, { type: "ButtonResponseComponent", coordinates: {"x":0.2622950819672132,"y":0.13114754098360656}, width: 200, height: 50, choices: ["salir"], name: "boton 2" }],
stimuli_duration: undefined,
trial_duration: undefined,
response_ends_trial: undefined}];
    const New_Trial_timeline = {
    type: DynamicPlugin, components: jsPsych.timelineVariable("components"),
response_components: jsPsych.timelineVariable("response_components"),
stimuli_duration: jsPsych.timelineVariable("stimuli_duration"),
trial_duration: jsPsych.timelineVariable("trial_duration"),
response_ends_trial: jsPsych.timelineVariable("response_ends_trial"),
      data: {
        rt: "rt",
        trial_id: 1765493817021,
        
        
        branches: [1765494204915, 1765496958102],
        branchConditions: [[{"id":1765497014804,"rules":[{"column":"boton 2_response","op":"==","value":"salir"}],"nextTrialId":"1765496958102","customParameters":{}},{"id":1765497030904,"rules":[{"column":"boton 1_response","op":"==","value":"Start"}],"nextTrialId":"1765494204915","customParameters":{}}]] 
        
      },
    on_start: function(trial) {
      // First, evaluate and apply params override conditions (if any)
      
      // Then apply custom parameters from branching conditions (higher priority)
      
      // For trials outside loops, use window.branchCustomParameters
      if (window.branchCustomParameters && typeof window.branchCustomParameters === 'object') {
        Object.entries(window.branchCustomParameters).forEach(([key, param]) => {
          if (param && param.source !== 'none') {
            // Parse key to check if it's a nested survey question
            const parts = key.split('::');
            
            if (parts.length === 4) {
              // Format: fieldType::componentName::survey_json::questionName
              const [fieldType, componentName, propName, questionName] = parts;
              
              if (fieldType && componentName && propName === 'survey_json' && questionName) {
                // Find the component by name in the field array
                const fieldArray = trial[fieldType];
                if (Array.isArray(fieldArray)) {
                  const compIndex = fieldArray.findIndex(c => c.name === componentName);
                  if (compIndex !== -1 && fieldArray[compIndex].survey_json) {
                    // Find the question in survey_json.elements
                    const elements = fieldArray[compIndex].survey_json.elements || [];
                    const questionIndex = elements.findIndex(q => q.name === questionName);
                    
                    if (questionIndex !== -1) {
                      // Apply the override value (from typed or csv)
                      let valueToSet;
                      if (param.source === 'typed') {
                        valueToSet = String(param.value); // Convert to string for SurveyJS
                      } else if (param.source === 'csv') {
                        valueToSet = String(trial[param.value]); // Get from CSV column and convert to string
                      }
                      
                      if (valueToSet !== undefined && valueToSet !== null) {
                        fieldArray[compIndex].survey_json.elements[questionIndex].defaultValue = valueToSet;
                      }
                    }
                  }
                }
              }
            } else {
              // Normal parameter (not nested survey question)
              if (param.source === 'typed' && param.value !== undefined && param.value !== null) {
                trial[key] = param.value;
              } else if (param.source === 'csv' && param.value !== undefined && param.value !== null) {
                trial[key] = trial[param.value];
              }
            }
          }
        });
        // Clear the custom parameters after applying them
        window.branchCustomParameters = null;
      }
      
    },
    
    on_finish: function(data) {
      
      
      // Si hay múltiples branches Y condiciones, la lógica se maneja en Timeline.tsx
      
    },
    };
    const New_Trial_procedure = {
    timeline: 
    [New_Trial_timeline],
    timeline_variables: test_stimuli_New_Trial,
    conditional_function: function() {
      const currentId = 1765493817021;
      
      // Verificar si hay un trial objetivo guardado en localStorage (para repeat/jump)
      const jumpToTrial = localStorage.getItem('jsPsych_jumpToTrial');
      if (jumpToTrial) {
        if (String(currentId) === String(jumpToTrial)) {
          // Encontramos el trial objetivo para repeat/jump
          console.log('Repeat/jump: Found target trial', currentId);
          localStorage.removeItem('jsPsych_jumpToTrial');
          return true;
        }
        // No es el objetivo, saltar
        console.log('Repeat/jump: Skipping trial', currentId);
        return false;
      }
      
      // Si skipRemaining está activo (branching normal), verificar si este es el trial objetivo
      if (window.skipRemaining) {
        if (String(currentId) === String(window.nextTrialId)) {
          // Encontramos el trial objetivo
          window.skipRemaining = false;
          window.nextTrialId = null;
          return true;
        }
        // No es el objetivo, saltar
        return false;
      }
      
      return true;
    },
    
    };
    timeline.push(New_Trial_procedure);
  


    const test_stimuli_New_Trial_1 = [{components: [{ type: "HtmlComponent", coordinates: {"x":0,"y":0}, width: 200, height: 50, stimulus: "<div id=\"i4g4\" style=\"box-sizing: border-box;\">Empezar</div>" }],
response_components: [{ type: "ButtonResponseComponent", coordinates: {"x":0.36475409836065564,"y":0.4043715846994533}, width: 200, height: 50, choices: ["hola?"] }],
stimuli_duration: undefined,
trial_duration: undefined,
response_ends_trial: undefined}];
    const New_Trial_1_timeline = {
    type: DynamicPlugin, components: jsPsych.timelineVariable("components"),
response_components: jsPsych.timelineVariable("response_components"),
stimuli_duration: jsPsych.timelineVariable("stimuli_duration"),
trial_duration: jsPsych.timelineVariable("trial_duration"),
response_ends_trial: jsPsych.timelineVariable("response_ends_trial"),
      data: {
        rt: "rt",
        trial_id: 1765494204915,
        
        
        branches: [1765498674994],
        branchConditions: [undefined] 
        
      },
    on_start: function(trial) {
      // First, evaluate and apply params override conditions (if any)
      
      // Then apply custom parameters from branching conditions (higher priority)
      
      // For trials outside loops, use window.branchCustomParameters
      if (window.branchCustomParameters && typeof window.branchCustomParameters === 'object') {
        Object.entries(window.branchCustomParameters).forEach(([key, param]) => {
          if (param && param.source !== 'none') {
            // Parse key to check if it's a nested survey question
            const parts = key.split('::');
            
            if (parts.length === 4) {
              // Format: fieldType::componentName::survey_json::questionName
              const [fieldType, componentName, propName, questionName] = parts;
              
              if (fieldType && componentName && propName === 'survey_json' && questionName) {
                // Find the component by name in the field array
                const fieldArray = trial[fieldType];
                if (Array.isArray(fieldArray)) {
                  const compIndex = fieldArray.findIndex(c => c.name === componentName);
                  if (compIndex !== -1 && fieldArray[compIndex].survey_json) {
                    // Find the question in survey_json.elements
                    const elements = fieldArray[compIndex].survey_json.elements || [];
                    const questionIndex = elements.findIndex(q => q.name === questionName);
                    
                    if (questionIndex !== -1) {
                      // Apply the override value (from typed or csv)
                      let valueToSet;
                      if (param.source === 'typed') {
                        valueToSet = String(param.value); // Convert to string for SurveyJS
                      } else if (param.source === 'csv') {
                        valueToSet = String(trial[param.value]); // Get from CSV column and convert to string
                      }
                      
                      if (valueToSet !== undefined && valueToSet !== null) {
                        fieldArray[compIndex].survey_json.elements[questionIndex].defaultValue = valueToSet;
                      }
                    }
                  }
                }
              }
            } else {
              // Normal parameter (not nested survey question)
              if (param.source === 'typed' && param.value !== undefined && param.value !== null) {
                trial[key] = param.value;
              } else if (param.source === 'csv' && param.value !== undefined && param.value !== null) {
                trial[key] = trial[param.value];
              }
            }
          }
        });
        // Clear the custom parameters after applying them
        window.branchCustomParameters = null;
      }
      
    },
    
    on_finish: function(data) {
      
      
      // Branching automático al primer branch
      const branches = [1765498674994];
      if (branches.length > 0) {
        window.nextTrialId = branches[0];
        window.skipRemaining = true;
        window.branchingActive = true;
      }
      
    },
    };
    const New_Trial_1_procedure = {
    timeline: 
    [New_Trial_1_timeline],
    timeline_variables: test_stimuli_New_Trial_1,
    conditional_function: function() {
      const currentId = 1765494204915;
      
      // Verificar si hay un trial objetivo guardado en localStorage (para repeat/jump)
      const jumpToTrial = localStorage.getItem('jsPsych_jumpToTrial');
      if (jumpToTrial) {
        if (String(currentId) === String(jumpToTrial)) {
          // Encontramos el trial objetivo para repeat/jump
          console.log('Repeat/jump: Found target trial', currentId);
          localStorage.removeItem('jsPsych_jumpToTrial');
          return true;
        }
        // No es el objetivo, saltar
        console.log('Repeat/jump: Skipping trial', currentId);
        return false;
      }
      
      // Si skipRemaining está activo (branching normal), verificar si este es el trial objetivo
      if (window.skipRemaining) {
        if (String(currentId) === String(window.nextTrialId)) {
          // Encontramos el trial objetivo
          window.skipRemaining = false;
          window.nextTrialId = null;
          return true;
        }
        // No es el objetivo, saltar
        return false;
      }
      
      return true;
    },
    
    };
    timeline.push(New_Trial_1_procedure);
  


    const test_stimuli_New_Trial_2 = [{device_select_message: "<p>Please select the microphone you would like to use.</p>",
button_label: "Use this microphone"}];
    const New_Trial_2_timeline = {
    type: jsPsychInitializeMicrophone, device_select_message: jsPsych.timelineVariable("device_select_message"),
button_label: jsPsych.timelineVariable("button_label"),
      data: {
        device_id: "device_id",
        trial_id: 1765496958102,
        
        
        branches: [1765497120721],
        branchConditions: [undefined] 
        
      },
    on_start: function(trial) {
      // First, evaluate and apply params override conditions (if any)
      
      // Then apply custom parameters from branching conditions (higher priority)
      
      // For trials outside loops, use window.branchCustomParameters
      if (window.branchCustomParameters && typeof window.branchCustomParameters === 'object') {
        Object.entries(window.branchCustomParameters).forEach(([key, param]) => {
          if (param && param.source !== 'none') {
            // Parse key to check if it's a nested survey question
            const parts = key.split('::');
            
            if (parts.length === 4) {
              // Format: fieldType::componentName::survey_json::questionName
              const [fieldType, componentName, propName, questionName] = parts;
              
              if (fieldType && componentName && propName === 'survey_json' && questionName) {
                // Find the component by name in the field array
                const fieldArray = trial[fieldType];
                if (Array.isArray(fieldArray)) {
                  const compIndex = fieldArray.findIndex(c => c.name === componentName);
                  if (compIndex !== -1 && fieldArray[compIndex].survey_json) {
                    // Find the question in survey_json.elements
                    const elements = fieldArray[compIndex].survey_json.elements || [];
                    const questionIndex = elements.findIndex(q => q.name === questionName);
                    
                    if (questionIndex !== -1) {
                      // Apply the override value (from typed or csv)
                      let valueToSet;
                      if (param.source === 'typed') {
                        valueToSet = String(param.value); // Convert to string for SurveyJS
                      } else if (param.source === 'csv') {
                        valueToSet = String(trial[param.value]); // Get from CSV column and convert to string
                      }
                      
                      if (valueToSet !== undefined && valueToSet !== null) {
                        fieldArray[compIndex].survey_json.elements[questionIndex].defaultValue = valueToSet;
                      }
                    }
                  }
                }
              }
            } else {
              // Normal parameter (not nested survey question)
              if (param.source === 'typed' && param.value !== undefined && param.value !== null) {
                trial[key] = param.value;
              } else if (param.source === 'csv' && param.value !== undefined && param.value !== null) {
                trial[key] = trial[param.value];
              }
            }
          }
        });
        // Clear the custom parameters after applying them
        window.branchCustomParameters = null;
      }
      
    },
    
    on_finish: function(data) {
      
      
      // Branching automático al primer branch
      const branches = [1765497120721];
      if (branches.length > 0) {
        window.nextTrialId = branches[0];
        window.skipRemaining = true;
        window.branchingActive = true;
      }
      
    },
    };
    const New_Trial_2_procedure = {
    timeline: 
    [New_Trial_2_timeline],
    timeline_variables: test_stimuli_New_Trial_2,
    conditional_function: function() {
      const currentId = 1765496958102;
      
      // Verificar si hay un trial objetivo guardado en localStorage (para repeat/jump)
      const jumpToTrial = localStorage.getItem('jsPsych_jumpToTrial');
      if (jumpToTrial) {
        if (String(currentId) === String(jumpToTrial)) {
          // Encontramos el trial objetivo para repeat/jump
          console.log('Repeat/jump: Found target trial', currentId);
          localStorage.removeItem('jsPsych_jumpToTrial');
          return true;
        }
        // No es el objetivo, saltar
        console.log('Repeat/jump: Skipping trial', currentId);
        return false;
      }
      
      // Si skipRemaining está activo (branching normal), verificar si este es el trial objetivo
      if (window.skipRemaining) {
        if (String(currentId) === String(window.nextTrialId)) {
          // Encontramos el trial objetivo
          window.skipRemaining = false;
          window.nextTrialId = null;
          return true;
        }
        // No es el objetivo, saltar
        return false;
      }
      
      return true;
    },
    
    };
    timeline.push(New_Trial_2_procedure);
  


    const test_stimuli_New_Trial_3 = [{components: [{ type: "HtmlComponent", coordinates: {"x":0.6393442622950818,"y":-4.440892098500626e-16}, width: 200, height: 50, stimulus: "<div id=\"i783\" style=\"box-sizing: border-box;\">Habla</div>" }],
response_components: [{ type: "AudioResponseComponent", coordinates: {"x":-0.15573770491803285,"y":0.31147540983606553}, width: 200, height: 50, rotation: 0 }],
stimuli_duration: undefined,
trial_duration: undefined,
response_ends_trial: undefined}];
    const New_Trial_3_timeline = {
    type: DynamicPlugin, components: jsPsych.timelineVariable("components"),
response_components: jsPsych.timelineVariable("response_components"),
stimuli_duration: jsPsych.timelineVariable("stimuli_duration"),
trial_duration: jsPsych.timelineVariable("trial_duration"),
response_ends_trial: jsPsych.timelineVariable("response_ends_trial"),
      data: {
        rt: "rt",
        trial_id: 1765497120721,
        
        
      },
    on_start: function(trial) {
      // First, evaluate and apply params override conditions (if any)
      
      // Then apply custom parameters from branching conditions (higher priority)
      
      // For trials outside loops, use window.branchCustomParameters
      if (window.branchCustomParameters && typeof window.branchCustomParameters === 'object') {
        Object.entries(window.branchCustomParameters).forEach(([key, param]) => {
          if (param && param.source !== 'none') {
            // Parse key to check if it's a nested survey question
            const parts = key.split('::');
            
            if (parts.length === 4) {
              // Format: fieldType::componentName::survey_json::questionName
              const [fieldType, componentName, propName, questionName] = parts;
              
              if (fieldType && componentName && propName === 'survey_json' && questionName) {
                // Find the component by name in the field array
                const fieldArray = trial[fieldType];
                if (Array.isArray(fieldArray)) {
                  const compIndex = fieldArray.findIndex(c => c.name === componentName);
                  if (compIndex !== -1 && fieldArray[compIndex].survey_json) {
                    // Find the question in survey_json.elements
                    const elements = fieldArray[compIndex].survey_json.elements || [];
                    const questionIndex = elements.findIndex(q => q.name === questionName);
                    
                    if (questionIndex !== -1) {
                      // Apply the override value (from typed or csv)
                      let valueToSet;
                      if (param.source === 'typed') {
                        valueToSet = String(param.value); // Convert to string for SurveyJS
                      } else if (param.source === 'csv') {
                        valueToSet = String(trial[param.value]); // Get from CSV column and convert to string
                      }
                      
                      if (valueToSet !== undefined && valueToSet !== null) {
                        fieldArray[compIndex].survey_json.elements[questionIndex].defaultValue = valueToSet;
                      }
                    }
                  }
                }
              }
            } else {
              // Normal parameter (not nested survey question)
              if (param.source === 'typed' && param.value !== undefined && param.value !== null) {
                trial[key] = param.value;
              } else if (param.source === 'csv' && param.value !== undefined && param.value !== null) {
                trial[key] = trial[param.value];
              }
            }
          }
        });
        // Clear the custom parameters after applying them
        window.branchCustomParameters = null;
      }
      
    },
    
    on_finish: function(data) {
      // Este trial no tiene branches ni repeat conditions, es un trial terminal
      // Si llegamos aquí después de un branching, terminar el experimento
      if (window.branchingActive) {
        jsPsych.abortExperiment('', {});
      }
    },
    };
    const New_Trial_3_procedure = {
    timeline: 
    [New_Trial_3_timeline],
    timeline_variables: test_stimuli_New_Trial_3,
    conditional_function: function() {
      const currentId = 1765497120721;
      
      // Verificar si hay un trial objetivo guardado en localStorage (para repeat/jump)
      const jumpToTrial = localStorage.getItem('jsPsych_jumpToTrial');
      if (jumpToTrial) {
        if (String(currentId) === String(jumpToTrial)) {
          // Encontramos el trial objetivo para repeat/jump
          console.log('Repeat/jump: Found target trial', currentId);
          localStorage.removeItem('jsPsych_jumpToTrial');
          return true;
        }
        // No es el objetivo, saltar
        console.log('Repeat/jump: Skipping trial', currentId);
        return false;
      }
      
      // Si skipRemaining está activo (branching normal), verificar si este es el trial objetivo
      if (window.skipRemaining) {
        if (String(currentId) === String(window.nextTrialId)) {
          // Encontramos el trial objetivo
          window.skipRemaining = false;
          window.nextTrialId = null;
          return true;
        }
        // No es el objetivo, saltar
        return false;
      }
      
      return true;
    },
    
    };
    timeline.push(New_Trial_3_procedure);
  

const plugin_webgazer_init_camera_instructions = {
      type: jsPsychHtmlButtonResponse,
      stimulus: jsPsych.timelineVariable("plugin_webgazer_init_camera_instructions"),
      choices: jsPsych.timelineVariable("plugin_webgazer_init_camera_choices"),
    };
    const test_stimuli_plugin_webgazer_init_camera = [{instructions: "`\n            <p>Position your head so that the webcam has a good view of your eyes.</p>\n            <p>Center your face in the box and look directly towards the camera.</p>\n            <p>It is important that you try and keep your head reasonably still throughout the experiment, so please take a moment to adjust your setup to be comfortable.</p>\n            <p>When your face is centered in the box and the box is green, you can click to continue.</p>`",
button_text: "Continue",
plugin_webgazer_init_camera_instructions: "\n          <p>In order to participate you must allow the experiment to use your camera.</p>\n          <p>You will be prompted to do this on the next screen.</p>\n          <p>If you do not wish to allow use of your camera, you cannot participate in this experiment.<p>\n          <p>It may take up to 30 seconds for the camera to initialize after you give permission.</p>\n        ",
plugin_webgazer_init_camera_choices: ["Got it"]}];

    
    const plugin_webgazer_init_camera_timeline = {
    type: jsPsychWebgazerInitCamera, 
    instructions: jsPsych.timelineVariable("instructions"),
button_text: jsPsych.timelineVariable("button_text"),
    data: {
      load_time: "load_time",
    },};;
    
    const plugin_webgazer_init_camera_procedure = {
    timeline: 
    [
    plugin_webgazer_init_camera_instructions,
    
    plugin_webgazer_init_camera_timeline 
    ],
    timeline_variables: test_stimuli_plugin_webgazer_init_camera,
  };
    timeline.push(plugin_webgazer_init_camera_procedure);
  ;const plugin_webgazer_calibrate_instructions = {
      type: jsPsychHtmlButtonResponse,
      stimulus: jsPsych.timelineVariable("plugin_webgazer_calibrate_instructions"),
      choices: jsPsych.timelineVariable("plugin_webgazer_calibrate_choices"),
    };
    const test_stimuli_plugin_webgazer_calibrate = [{calibration_points: [[20,20],[80,20],[50,50],[20,80],[80,80]],
calibration_mode: "click",
point_size: 20,
repetitions_per_point: 1,
randomize_calibration_order: false,
time_to_saccade: 1000,
time_per_point: 1000,
plugin_webgazer_calibrate_instructions: "\n          <p>Now you'll calibrate the eye tracking, so that the software can use the image of your eyes to predict where you are looking.</p>\n          <p>You'll see a series of dots appear on the screen. Look at each dot and click on it.</p>\n        ",
plugin_webgazer_calibrate_choices: ["Got it"]}];

    
    const plugin_webgazer_calibrate_timeline = {
    type: jsPsychWebgazerCalibrate, 
    calibration_points: jsPsych.timelineVariable("calibration_points"),
calibration_mode: jsPsych.timelineVariable("calibration_mode"),
point_size: jsPsych.timelineVariable("point_size"),
repetitions_per_point: jsPsych.timelineVariable("repetitions_per_point"),
randomize_calibration_order: jsPsych.timelineVariable("randomize_calibration_order"),
time_to_saccade: jsPsych.timelineVariable("time_to_saccade"),
time_per_point: jsPsych.timelineVariable("time_per_point"),
    data: {
      
    },};;
    
    const plugin_webgazer_calibrate_procedure = {
    timeline: 
    [
    plugin_webgazer_calibrate_instructions,
    
    plugin_webgazer_calibrate_timeline 
    ],
    timeline_variables: test_stimuli_plugin_webgazer_calibrate,
  };
    timeline.push(plugin_webgazer_calibrate_procedure);
  ;const plugin_webgazer_validate_instructions = {
      type: jsPsychHtmlButtonResponse,
      stimulus: jsPsych.timelineVariable("plugin_webgazer_validate_instructions"),
      choices: jsPsych.timelineVariable("plugin_webgazer_validate_choices"),
    };
    const test_stimuli_plugin_webgazer_validate = [{validation_points: [[20,20],[80,20],[50,50],[20,80],[80,80]],
validation_point_coordinates: "percent",
roi_radius: 200,
randomize_validation_order: false,
time_to_saccade: 1000,
validation_duration: 2000,
point_size: 20,
show_validation_data: false,
plugin_webgazer_validate_instructions: "\n          <p>Now we'll measure the accuracy of the calibration.</p>\n          <p>Look at each dot as it appears on the screen.</p>\n          <p style=\"font-weight: bold;\">You do not need to click on the dots this time.</p>\n        ",
plugin_webgazer_validate_choices: ["Got it"],
post_trial_gap: 1000}];

    
    const plugin_webgazer_validate_timeline = {
    type: jsPsychWebgazerValidate, validation_points: jsPsych.timelineVariable("validation_points"),
validation_point_coordinates: jsPsych.timelineVariable("validation_point_coordinates"),
roi_radius: jsPsych.timelineVariable("roi_radius"),
randomize_validation_order: jsPsych.timelineVariable("randomize_validation_order"),
time_to_saccade: jsPsych.timelineVariable("time_to_saccade"),
validation_duration: jsPsych.timelineVariable("validation_duration"),
point_size: jsPsych.timelineVariable("point_size"),
show_validation_data: jsPsych.timelineVariable("show_validation_data"),
    data: {
      task: 'validate'
    }};;
    
    const plugin_webgazer_validate_procedure = {
    timeline: 
    [
    plugin_webgazer_validate_instructions,
    
    plugin_webgazer_validate_timeline 
    ],
    timeline_variables: test_stimuli_plugin_webgazer_validate,
  };
    timeline.push(plugin_webgazer_validate_procedure);
  ;
    const test_stimuli_plugin_webgazer_recalibrate = [{}];

    ;
    
    const plugin_webgazer_recalibrate_procedure = {
    timeline: 
    [
    
    
    
    ],
    timeline_variables: test_stimuli_plugin_webgazer_recalibrate,
  };
    timeline.push(plugin_webgazer_recalibrate_procedure);
  ;
    const recalibrate_timeline = {
        timeline: [
        plugin_webgazer_calibrate_procedure, plugin_webgazer_validate_procedure],
        conditional_function: function(){
          var validation_data = jsPsych.data.get().filter({task: 'validate'}).values()[0];
          return validation_data.percent_in_roi.some(function(x){
            var minimum_percent_acceptable = 50;
            return x < minimum_percent_acceptable;
          });
        },
        data: {
          phase: 'recalibration'
        }
      } 
 const recalibrateWebGazer_procedure = {
    timeline: 
    [recalibrate_timeline],
    timeline_variables: test_stimuli_plugin_webgazer_recalibrate,
  };
    timeline.push(recalibrateWebGazer_procedure);
  ;const calibration_done = {
        type: jsPsychHtmlButtonResponse,
        stimulus: `
          <p>Great, we're done with calibration!</p>
        `,
        choices: ['OK']
      }
    timeline.push(calibration_done);



    const test_stimuli_New_Trial_5 = [{components: [{ type: "HtmlComponent", coordinates: {"x":0.6762295081967211,"y":-0.754098360655738}, width: 200, height: 50, stimulus: "<div id=\"iu61\" style=\"box-sizing: border-box;\">loco</div>" }],
response_components: [{ type: "KeyboardResponseComponent", coordinates: {"x":0.08606557377049184,"y":0.03278688524590153}, width: 200, height: 50 }],
stimuli_duration: undefined,
trial_duration: undefined,
response_ends_trial: undefined}];
    const New_Trial_5_timeline = {
    type: DynamicPlugin, components: jsPsych.timelineVariable("components"),
response_components: jsPsych.timelineVariable("response_components"),
stimuli_duration: jsPsych.timelineVariable("stimuli_duration"),
trial_duration: jsPsych.timelineVariable("trial_duration"),
response_ends_trial: jsPsych.timelineVariable("response_ends_trial"),
      data: {
        rt: "rt",
        trial_id: 1765498868227,
        
        
      },
    on_start: function(trial) {
      // First, evaluate and apply params override conditions (if any)
      
      // Then apply custom parameters from branching conditions (higher priority)
      
      // For trials outside loops, use window.branchCustomParameters
      if (window.branchCustomParameters && typeof window.branchCustomParameters === 'object') {
        Object.entries(window.branchCustomParameters).forEach(([key, param]) => {
          if (param && param.source !== 'none') {
            // Parse key to check if it's a nested survey question
            const parts = key.split('::');
            
            if (parts.length === 4) {
              // Format: fieldType::componentName::survey_json::questionName
              const [fieldType, componentName, propName, questionName] = parts;
              
              if (fieldType && componentName && propName === 'survey_json' && questionName) {
                // Find the component by name in the field array
                const fieldArray = trial[fieldType];
                if (Array.isArray(fieldArray)) {
                  const compIndex = fieldArray.findIndex(c => c.name === componentName);
                  if (compIndex !== -1 && fieldArray[compIndex].survey_json) {
                    // Find the question in survey_json.elements
                    const elements = fieldArray[compIndex].survey_json.elements || [];
                    const questionIndex = elements.findIndex(q => q.name === questionName);
                    
                    if (questionIndex !== -1) {
                      // Apply the override value (from typed or csv)
                      let valueToSet;
                      if (param.source === 'typed') {
                        valueToSet = String(param.value); // Convert to string for SurveyJS
                      } else if (param.source === 'csv') {
                        valueToSet = String(trial[param.value]); // Get from CSV column and convert to string
                      }
                      
                      if (valueToSet !== undefined && valueToSet !== null) {
                        fieldArray[compIndex].survey_json.elements[questionIndex].defaultValue = valueToSet;
                      }
                    }
                  }
                }
              }
            } else {
              // Normal parameter (not nested survey question)
              if (param.source === 'typed' && param.value !== undefined && param.value !== null) {
                trial[key] = param.value;
              } else if (param.source === 'csv' && param.value !== undefined && param.value !== null) {
                trial[key] = trial[param.value];
              }
            }
          }
        });
        // Clear the custom parameters after applying them
        window.branchCustomParameters = null;
      }
      
    },
    
    on_finish: function(data) {
      // Este trial no tiene branches ni repeat conditions, es un trial terminal
      // Si llegamos aquí después de un branching, terminar el experimento
      if (window.branchingActive) {
        jsPsych.abortExperiment('', {});
      }
    },
    
    extensions: 
        [{
          type: jsPsychExtensionWebgazer,
        }]
    };
    
    const New_Trial_5_procedure = {
    timeline: 
    [New_Trial_5_timeline],
    timeline_variables: test_stimuli_New_Trial_5,
    conditional_function: function() {
      const currentId = 1765498868227;
      
      // Verificar si hay un trial objetivo guardado en localStorage (para repeat/jump)
      const jumpToTrial = localStorage.getItem('jsPsych_jumpToTrial');
      if (jumpToTrial) {
        if (String(currentId) === String(jumpToTrial)) {
          // Encontramos el trial objetivo para repeat/jump
          console.log('Repeat/jump: Found target trial', currentId);
          localStorage.removeItem('jsPsych_jumpToTrial');
          return true;
        }
        // No es el objetivo, saltar
        console.log('Repeat/jump: Skipping trial', currentId);
        return false;
      }
      
      // Si skipRemaining está activo (branching normal), verificar si este es el trial objetivo
      if (window.skipRemaining) {
        if (String(currentId) === String(window.nextTrialId)) {
          // Encontramos el trial objetivo
          window.skipRemaining = false;
          window.nextTrialId = null;
          return true;
        }
        // No es el objetivo, saltar
        return false;
      }
      
      return true;
    },
    
    extensions: 
        [{
          type: jsPsychExtensionWebgazer,
        }]
    };
    timeline.push(New_Trial_5_procedure);
    

jsPsych.run(timeline);

})();

</script></body></html>