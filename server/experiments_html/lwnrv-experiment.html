<!DOCTYPE html><html lang="en"><head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/png+xml" href="/icon/fp black.png">
    <title>Experiment</title>
    <script src="https://unpkg.com/jspsych@8.2.1"></script>
    <script src="https://unpkg.com/@jspsych/plugin-animation@2.1.0"></script>
    <script src="https://unpkg.com/@jspsych/plugin-audio-button-response@2.1.0"></script>
    <script src="https://unpkg.com/@jspsych/plugin-audio-keyboard-response@2.1.0"></script>
    <script src="https://unpkg.com/@jspsych/plugin-audio-slider-response@2.1.0"></script>
    <script src="https://unpkg.com/@jspsych/plugin-browser-check@2.1.0"></script>
    <script src="https://unpkg.com/@jspsych/plugin-call-function@2.1.0"></script>
    <script src="https://unpkg.com/@jspsych/plugin-canvas-button-response@2.1.0"></script>
    <script src="https://unpkg.com/@jspsych/plugin-canvas-keyboard-response@2.1.0"></script>
    <script src="https://unpkg.com/@jspsych/plugin-canvas-slider-response@2.1.0"></script>
    <script src="https://unpkg.com/@jspsych/plugin-categorize-animation@2.1.0"></script>
    <script src="https://unpkg.com/@jspsych/plugin-categorize-html@2.1.0"></script>
    <script src="https://unpkg.com/@jspsych/plugin-categorize-image@2.1.0"></script>
    <script src="https://unpkg.com/@jspsych/plugin-cloze@2.2.0"></script>
    <script src="https://unpkg.com/@jspsych/plugin-external-html@2.1.0"></script>
    <script src="https://unpkg.com/@jspsych/plugin-free-sort@2.1.0"></script>
    <script src="https://unpkg.com/@jspsych/plugin-fullscreen@2.1.0"></script>
    <script src="https://unpkg.com/@jspsych/plugin-html-audio-response@2.1.0"></script>
    <script src="https://unpkg.com/@jspsych/plugin-html-button-response@2.1.0"></script>
    <script src="https://unpkg.com/@jspsych/plugin-html-keyboard-response@2.1.0"></script>
    <script src="https://unpkg.com/@jspsych/plugin-html-slider-response@2.1.0"></script>
    <script src="https://unpkg.com/@jspsych/plugin-html-video-response@2.1.0"></script>
    <script src="https://unpkg.com/@jspsych/plugin-iat-html@2.1.0"></script>
    <script src="https://unpkg.com/@jspsych/plugin-iat-image@2.1.0"></script>
    <script src="https://unpkg.com/@jspsych/plugin-image-button-response@2.1.0"></script>
    <script src="https://unpkg.com/@jspsych/plugin-image-keyboard-response@2.1.0"></script>
    <script src="https://unpkg.com/@jspsych/plugin-image-slider-response@2.1.0"></script>
    <script src="https://unpkg.com/@jspsych/plugin-initialize-camera@2.1.0"></script>
    <script src="https://unpkg.com/@jspsych/plugin-initialize-microphone@2.1.0"></script>
    <script src="https://unpkg.com/@jspsych/plugin-instructions@2.1.0"></script>
    <script src="https://unpkg.com/@jspsych/plugin-maxdiff@2.1.0"></script>
    <script src="https://unpkg.com/@jspsych/plugin-mirror-camera@2.1.0"></script>
    <script src="https://unpkg.com/@jspsych/plugin-preload@2.1.0"></script>
    <script src="https://unpkg.com/@jspsych/plugin-reconstruction@2.1.0"></script>
    <script src="https://unpkg.com/@jspsych/plugin-resize@2.1.0"></script>
    <script src="https://unpkg.com/@jspsych/plugin-same-different-html@2.1.0"></script>
    <script src="https://unpkg.com/@jspsych/plugin-same-different-image@2.1.0"></script>
    <script src="https://unpkg.com/@jspsych/plugin-serial-reaction-time@2.1.0"></script>
    <script src="https://unpkg.com/@jspsych/plugin-serial-reaction-time-mouse@2.1.0"></script>
    <script src="https://unpkg.com/@jspsych/plugin-sketchpad@2.1.0"></script>
    <script src="https://unpkg.com/@jspsych/plugin-survey@2.1.0"></script>
    <script src="https://unpkg.com/@jspsych/plugin-survey-html-form@2.1.0"></script>
    <script src="https://unpkg.com/@jspsych/plugin-survey-likert@2.1.0"></script>
    <script src="https://unpkg.com/@jspsych/plugin-survey-multi-choice@2.1.0"></script>
    <script src="https://unpkg.com/@jspsych/plugin-survey-multi-select@2.1.0"></script>
    <script src="https://unpkg.com/@jspsych/plugin-survey-text@2.1.0"></script>
    <script src="https://unpkg.com/@jspsych/plugin-video-button-response@2.1.0"></script>
    <script src="https://unpkg.com/@jspsych/plugin-video-keyboard-response@2.1.0"></script>
    <script src="https://unpkg.com/@jspsych/plugin-video-slider-response@2.1.0"></script>
    <script src="https://unpkg.com/@jspsych/plugin-virtual-chinrest@3.1.0"></script>
    <script src="https://unpkg.com/@jspsych/plugin-visual-search-circle@2.2.0"></script>

    <script src="https://cdn.jsdelivr.net/gh/jspsych/jspsych@jspsych@7.0.0/examples/js/webgazer/webgazer.js"></script>

    <script src="https://unpkg.com/@jspsych/extension-webgazer@1.2.0"></script>
    <script src="https://unpkg.com/@jspsych/plugin-webgazer-calibrate@2.1.0"></script>
    <script src="https://unpkg.com/@jspsych/plugin-webgazer-init-camera@2.1.0"></script>
    <script src="https://unpkg.com/@jspsych/plugin-webgazer-validate@2.1.0"></script>

    <script src="https://unpkg.com/@jspsych/extension-record-video@1.2.0"></script>
    <script src="https://unpkg.com/@jspsych/extension-mouse-tracking@1.0.0"></script>

    <link href="https://unpkg.com/jspsych@7.3.1/css/jspsych.css" rel="stylesheet" type="text/css">
    <link rel="stylesheet" href="https://unpkg.com/@jspsych/plugin-survey@2.1.0/css/survey.css">

    <style>
      body {
        margin: 0;
        padding: 0;
        background-color: #f0f0f0;
      }
      #jspsych-container {
        width: 100%;
        height: 100vh;
      }
      #jspsych-target {
        width: 100%;
      }
    </style>
  </head>
  <body>
    <div id="jspsych-container">
      <div id="jspsych-target"></div>
    </div>

    
  

<script id="generated-script">

  const trialSessionId =
    (crypto.randomUUID
      ? crypto.randomUUID()
      : Math.random().toString(36).slice(2, 10));

  let participantNumber;

  async function saveSession(trialSessionId) {
   
   const res = await fetch("/api/append-result/c3ac9abb-486f-4f43-a093-fd1173acea6a", {
      method: "POST",
      headers: { "Content-Type": "application/json", Accept: "*/*" },
      body: JSON.stringify({
        sessionId: trialSessionId,
      }),
    });
  
    const result = await res.json();
    participantNumber = result.participantNumber;
    return participantNumber;
    
  }

  (async () => {

    localStorage.removeItem('jsPsych_jumpToTrial');
    
    participantNumber = await saveSession(trialSessionId);

    if (typeof participantNumber !== "number" || isNaN(participantNumber)) {
      alert("The participant number is not assigned. Please, wait.");
      throw new Error("participantNumber not assigned");
    }

    // --- Branching logic functions (outside initJsPsych for timeline access) ---
    window.nextTrialId = null;
    window.skipRemaining = false;
    window.branchingActive = false;
    window.branchCustomParameters = null; // Store custom parameters for the next trial

    const evaluateCondition = (trialData, condition) => {
      // All rules in a condition must be true (AND logic)
      return condition.rules.every(rule => {
        const propValue = trialData[rule.prop];
        const compareValue = rule.value;
        
        // Convert values for comparison
        const numPropValue = parseFloat(propValue);
        const numCompareValue = parseFloat(compareValue);
        const isNumeric = !isNaN(numPropValue) && !isNaN(numCompareValue);
        
        switch (rule.op) {
          case '==':
            return isNumeric ? numPropValue === numCompareValue : propValue == compareValue;
          case '!=':
            return isNumeric ? numPropValue !== numCompareValue : propValue != compareValue;
          case '>':
            return isNumeric && numPropValue > numCompareValue;
          case '<':
            return isNumeric && numPropValue < numCompareValue;
          case '>=':
            return isNumeric && numPropValue >= numCompareValue;
          case '<=':
            return isNumeric && numPropValue <= numCompareValue;
          default:
            return false;
        }
      });
    };
    
    const getNextTrialId = (lastTrialData) => {
      if (!lastTrialData || !lastTrialData.trials || !lastTrialData.trials[0]) {
        return null;
      }
      
      const trial = lastTrialData.trials[0];
      
      // Check if trial/loop has branches
      if (!Array.isArray(trial.branches) || trial.branches.length === 0) {
        return null;
      }
      
      // Check if there are conditions to evaluate
      const hasBranchConditions = Array.isArray(trial.branchConditions) && trial.branchConditions.length > 0;
      
      // Check if any condition has customParameters
      const hasCustomParameters = hasBranchConditions && 
        trial.branchConditions.flat().some(condition => 
          condition && condition.customParameters && 
          Object.keys(condition.customParameters).length > 0
        );
      
      // If there are no conditions AND no custom parameters, auto-branch to first branch
      if (!hasBranchConditions && !hasCustomParameters) {
        console.log('No conditions or custom parameters defined, auto-branching to first branch:', trial.branches[0]);
        return trial.branches[0];
      }
      
      // If there are no conditions but there ARE custom parameters, we can't auto-branch
      // We need to evaluate conditions to know which customParameters to use
      if (!hasBranchConditions && hasCustomParameters) {
        console.log('Custom parameters exist but no conditions, cannot auto-branch');
        return null;
      }
      
      // If there ARE conditions, evaluate them (regardless of how many branches there are)
      // branchConditions is an array of arrays, flatten it first
      const conditions = trial.branchConditions.flat();
      
      // Evaluate each condition (OR logic between conditions)
      for (const condition of conditions) {
        if (!condition || !condition.rules) {
          console.warn('Invalid condition structure:', condition);
          continue;
        }
        
        if (evaluateCondition(trial, condition)) {
          console.log('Condition matched:', condition);
          // Store custom parameters if they exist
          if (condition.customParameters) {
            window.branchCustomParameters = condition.customParameters;
            console.log('Custom parameters for branch:', window.branchCustomParameters);
          }
          return condition.nextTrialId;
        }
      }
      
      // No condition matched - do NOT branch (conditions were defined but none matched)
      console.log('No condition matched, NOT branching');
      return null;
    };

    const jsPsych = initJsPsych({
          display_element: document.getElementById('jspsych-container'),


    

    on_data_update: function (data) {
      const res = fetch("/api/append-result/c3ac9abb-486f-4f43-a093-fd1173acea6a", {
        method: "PUT",
        headers: { "Content-Type": "application/json", Accept: "*/*" },
        body: JSON.stringify({
          sessionId: trialSessionId,
          response: data,
        }),
      });

      // Solo evaluar branching si el trial/loop tiene un trial_id o loop_id válido
      if ((!data.trial_id || data.trial_id === undefined) && (!data.loop_id || data.loop_id === undefined)) {
        return;
      }
      
      const lastTrialData = jsPsych.data.getLastTrialData();
      const trial = lastTrialData.trials ? lastTrialData.trials[0] : null;
      
      // Verificar si este trial/loop tiene branches
      if (!trial || !trial.branches || trial.branches.length === 0) {
        return; // No tiene branches, no hay nada que hacer
      }
      
      // IMPORTANTE: Si el trial está dentro de un loop (isInLoop = true),
      // NO activar el branching global. Los trials dentro de loops usan su propio
      // sistema de branching con variables locales (loopNextTrialId, etc.)
      if (trial.isInLoop === true) {
        console.log('Trial inside loop detected, skipping global branching');
        return;
      }
      
      console.log('Trial/Loop data:', lastTrialData);
      
      const nextTrialId = getNextTrialId(lastTrialData);
      console.log('Next trial/loop ID:', nextTrialId);
      
      if (nextTrialId) {
        // Check if nextTrialId is "FINISH_EXPERIMENT"
        if (nextTrialId === 'FINISH_EXPERIMENT') {
          console.log('Finish experiment requested');
          jsPsych.abortExperiment('Experiment finished by branching condition', {});
          return;
        }
        
        window.nextTrialId = nextTrialId;
        window.skipRemaining = true;
        window.branchingActive = true;
        console.log('Branching activated: skip to trial/loop', nextTrialId);
      }
    },

  on_finish: function() {
    jsPsych.data.displayData
  }
});

const timeline = [];

// const welcome = {
//   type: jsPsychHtmlButtonResponse,
//   stimulus: "Welcome to the experiment. Press 'Start' to begin.",
//   choices: ['Start'],
// };

// timeline.push(welcome);


    const preloadLoopsiono = {
        type: jsPsychPreload,
       files: [],
    }
    timeline.push(preloadLoopsiono);
    
    const test_stimuli_Loopsiono = [{stimulus: "<div id=\"if8h\" style=\"box-sizing: border-box;\">loop?</div>",
choices: ["SI","NO"]}];
    const Loopsiono_timeline = {
    type: jsPsychHtmlButtonResponse, stimulus: jsPsych.timelineVariable("stimulus"),
choices: jsPsych.timelineVariable("choices"),
      data: {
        rt: "rt",
response: "response",
stimulus: "stimulus",
        trial_id: 1762902515317,
        
        
        branches: [1762902521115, "loop_1762902533581"],
        branchConditions: [[{"id":1762903077448,"rules":[{"prop":"response","op":"==","value":"0"}],"nextTrialId":"loop_1762902533581","customParameters":{}},{"id":1762903083147,"rules":[{"prop":"response","op":"==","value":"1"}],"nextTrialId":"1762902521115","customParameters":{}}]] 
        
      },
    on_start: function(trial) {
      // First, evaluate and apply params override conditions (if any)
      
      // Then apply custom parameters from branching conditions (higher priority)
      
      // For trials outside loops, use window.branchCustomParameters
      if (window.branchCustomParameters && typeof window.branchCustomParameters === 'object') {
        console.log('Applying custom parameters to trial:', window.branchCustomParameters);
        Object.entries(window.branchCustomParameters).forEach(([key, param]) => {
          if (param && param.source !== 'none') {
            // Handle different parameter sources
            if (param.source === 'typed' && param.value !== undefined && param.value !== null) {
              // For typed values, use them directly
              trial[key] = param.value;
              console.log(`Set trial.${key} = ${param.value}`);
            } else if (param.source === 'csv' && param.value !== undefined && param.value !== null) {
              // For CSV values, param.value contains the column name, get the actual value from trial
              trial[key] = trial[param.value];
              console.log(`Set trial.${key} = ${trial[param.value]} (from CSV column: ${param.value})`);
            }
          }
        });
        // Clear the custom parameters after applying them
        window.branchCustomParameters = null;
      }
      
    },
    
    on_finish: function(data) {
      
      
      // Si hay múltiples branches Y condiciones, la lógica se maneja en Timeline.tsx
      
    },
    };
    const Loopsiono_procedure = {
    timeline: 
    [Loopsiono_timeline],
    timeline_variables: test_stimuli_Loopsiono,
    conditional_function: function() {
      const currentId = 1762902515317;
      
      // Verificar si hay un trial objetivo guardado en localStorage (para repeat/jump)
      const jumpToTrial = localStorage.getItem('jsPsych_jumpToTrial');
      if (jumpToTrial) {
        if (String(currentId) === String(jumpToTrial)) {
          // Encontramos el trial objetivo para repeat/jump
          console.log('Repeat/jump: Found target trial', currentId);
          localStorage.removeItem('jsPsych_jumpToTrial');
          return true;
        }
        // No es el objetivo, saltar
        console.log('Repeat/jump: Skipping trial', currentId);
        return false;
      }
      
      // Si skipRemaining está activo (branching normal), verificar si este es el trial objetivo
      if (window.skipRemaining) {
        if (String(currentId) === String(window.nextTrialId)) {
          // Encontramos el trial objetivo
          window.skipRemaining = false;
          window.nextTrialId = null;
          return true;
        }
        // No es el objetivo, saltar
        return false;
      }
      
      return true;
    },
    
    };
    timeline.push(Loopsiono_procedure);
  


    const preloadPuesno = {
        type: jsPsychPreload,
       files: [],
    }
    timeline.push(preloadPuesno);
    
    const test_stimuli_Puesno = [{stimulus: "<div id=\"indp\" style=\"box-sizing: border-box;\">Pues no</div>",
choices: ["QUENOo"]}];
    const Puesno_timeline = {
    type: jsPsychHtmlButtonResponse, stimulus: jsPsych.timelineVariable("stimulus"),
choices: jsPsych.timelineVariable("choices"),
      data: {
        rt: "rt",
response: "response",
stimulus: "stimulus",
        trial_id: 1762902521115,
        
        
      },
    on_start: function(trial) {
      // First, evaluate and apply params override conditions (if any)
      
      // Then apply custom parameters from branching conditions (higher priority)
      
      // For trials outside loops, use window.branchCustomParameters
      if (window.branchCustomParameters && typeof window.branchCustomParameters === 'object') {
        console.log('Applying custom parameters to trial:', window.branchCustomParameters);
        Object.entries(window.branchCustomParameters).forEach(([key, param]) => {
          if (param && param.source !== 'none') {
            // Handle different parameter sources
            if (param.source === 'typed' && param.value !== undefined && param.value !== null) {
              // For typed values, use them directly
              trial[key] = param.value;
              console.log(`Set trial.${key} = ${param.value}`);
            } else if (param.source === 'csv' && param.value !== undefined && param.value !== null) {
              // For CSV values, param.value contains the column name, get the actual value from trial
              trial[key] = trial[param.value];
              console.log(`Set trial.${key} = ${trial[param.value]} (from CSV column: ${param.value})`);
            }
          }
        });
        // Clear the custom parameters after applying them
        window.branchCustomParameters = null;
      }
      
    },
    
    on_finish: function(data) {
      
      // Evaluar repeat conditions (para reiniciar el experimento desde un trial específico)
      const repeatConditionsArray = [{"id":1762903134167,"rules":[{"prop":"response","op":"==","value":"0"}],"jumpToTrialId":"1762902515317"}];
      
      for (const condition of repeatConditionsArray) {
        if (!condition || !condition.rules) {
          continue;
        }
        
        // Todas las reglas en una condición deben ser verdaderas (lógica AND)
        const allRulesMatch = condition.rules.every(rule => {
          const propValue = data[rule.prop];
          const compareValue = rule.value;
          
          // Convertir valores para comparación
          const numPropValue = parseFloat(propValue);
          const numCompareValue = parseFloat(compareValue);
          const isNumeric = !isNaN(numPropValue) && !isNaN(numCompareValue);
          
          switch (rule.op) {
            case '==':
              return isNumeric ? numPropValue === numCompareValue : propValue == compareValue;
            case '!=':
              return isNumeric ? numPropValue !== numCompareValue : propValue != compareValue;
            case '>':
              return isNumeric && numPropValue > numCompareValue;
            case '<':
              return isNumeric && numPropValue < numCompareValue;
            case '>=':
              return isNumeric && numPropValue >= numCompareValue;
            case '<=':
              return isNumeric && numPropValue <= numCompareValue;
            default:
              return false;
          }
        });
        
        if (allRulesMatch && condition.jumpToTrialId) {
          console.log('Repeat condition matched! Jumping to trial:', condition.jumpToTrialId);
          // Guardar el trial objetivo en localStorage
          localStorage.setItem('jsPsych_jumpToTrial', String(condition.jumpToTrialId));
          // Limpiar el contenedor de jsPsych (jspsych-container es el display_element)
          const container = document.getElementById('jspsych-container');
          if (container) {
            // Limpiar todo el contenido del container
            container.innerHTML = '';
          }
          // Reiniciar el timeline
          setTimeout(() => {
            jsPsych.run(timeline);
          }, 100);
          return;
        }
      }
      
      
      // Este trial no tiene branches, es un trial terminal
      // Si llegamos aquí después de un branching, terminar el experimento
      if (window.branchingActive) {
        jsPsych.abortExperiment('', {});
      }
      
    },
    };
    const Puesno_procedure = {
    timeline: 
    [Puesno_timeline],
    timeline_variables: test_stimuli_Puesno,
    conditional_function: function() {
      const currentId = 1762902521115;
      
      // Verificar si hay un trial objetivo guardado en localStorage (para repeat/jump)
      const jumpToTrial = localStorage.getItem('jsPsych_jumpToTrial');
      if (jumpToTrial) {
        if (String(currentId) === String(jumpToTrial)) {
          // Encontramos el trial objetivo para repeat/jump
          console.log('Repeat/jump: Found target trial', currentId);
          localStorage.removeItem('jsPsych_jumpToTrial');
          return true;
        }
        // No es el objetivo, saltar
        console.log('Repeat/jump: Skipping trial', currentId);
        return false;
      }
      
      // Si skipRemaining está activo (branching normal), verificar si este es el trial objetivo
      if (window.skipRemaining) {
        if (String(currentId) === String(window.nextTrialId)) {
          // Encontramos el trial objetivo
          window.skipRemaining = false;
          window.nextTrialId = null;
          return true;
        }
        // No es el objetivo, saltar
        return false;
      }
      
      return true;
    },
    
    };
    timeline.push(Puesno_procedure);
  



    const test_stimuli_loop_1762902533581 = [
  {
    "stimulus_nested": "<div id=\"ig2k\" style=\"box-sizing: border-box;\">Nested ?</div>",
    "choices_nested": [
      "Seguir",
      "Salirn"
    ],
    "stimulus_Seguir": "<div id=\"ip4y\" style=\"box-sizing: border-box;\">Seguir</div>",
    "choices_Seguir": [
      "SI",
      "No"
    ]
  }
];
    
    
    
    const preloadnested = {
        type: jsPsychPreload,
       files: [],
    }
    timeline.push(preloadnested);
    
    const nested_timeline = {
    type: jsPsychHtmlButtonResponse, stimulus: jsPsych.timelineVariable("stimulus_nested"),
choices: jsPsych.timelineVariable("choices_nested"),
      data: {
        rt: "rt_nested",
response: "response_nested",
stimulus: "stimulus_nested",
        trial_id: 1762902524841,
        isInLoop: true,
        
        branches: [1762902528773, 1762902912364],
        branchConditions: [[{"id":1762902986815,"rules":[{"prop":"response","op":"==","value":"0"}],"nextTrialId":"1762902528773","customParameters":{}},{"id":1762902993518,"rules":[{"prop":"response","op":"==","value":"1"}],"nextTrialId":"loop_1762907705296","customParameters":{}}]] 
        
      },
    on_start: function(trial) {
      // First, evaluate and apply params override conditions (if any)
      
      // Then apply custom parameters from branching conditions (higher priority)
      
      // For trials in loops, use loopBranchCustomParameters
      if (typeof loopBranchCustomParameters !== 'undefined' && loopBranchCustomParameters && typeof loopBranchCustomParameters === 'object') {
        console.log('Applying custom parameters to loop trial:', loopBranchCustomParameters);
        Object.entries(loopBranchCustomParameters).forEach(([key, param]) => {
          if (param && param.source !== 'none') {
            // Handle different parameter sources
            if (param.source === 'typed' && param.value !== undefined && param.value !== null) {
              // For typed values, use them directly
              trial[key] = param.value;
              console.log(`Set trial.${key} = ${param.value}`);
            } else if (param.source === 'csv' && param.value !== undefined && param.value !== null) {
              // For CSV values, param.value contains the column name, get the actual value from trial
              trial[key] = trial[param.value];
              console.log(`Set trial.${key} = ${trial[param.value]} (from CSV column: ${param.value})`);
            }
          }
        });
        // Clear the custom parameters after applying them
        loopBranchCustomParameters = null;
      }
      
    },
    
    on_finish: function(data) {
      // Evaluar condiciones del trial para branching interno del loop
      const branches = [1762902528773, 1762902912364];
      const branchConditions = [{"id":1762902986815,"rules":[{"prop":"response","op":"==","value":"0"}],"nextTrialId":"1762902528773","customParameters":{}},{"id":1762902993518,"rules":[{"prop":"response","op":"==","value":"1"}],"nextTrialId":"loop_1762907705296","customParameters":{}}].flat();
      
      let nextTrialId = null;
      let matchedCustomParameters = null;
      
      // Evaluar cada condición (lógica OR entre condiciones)
      for (const condition of branchConditions) {
        if (!condition || !condition.rules) {
          continue;
        }
        
        // Todas las reglas en una condición deben ser verdaderas (lógica AND)
        const allRulesMatch = condition.rules.every(rule => {
          const propValue = data[rule.prop];
          const compareValue = rule.value;
          
          // Convertir valores para comparación
          const numPropValue = parseFloat(propValue);
          const numCompareValue = parseFloat(compareValue);
          const isNumeric = !isNaN(numPropValue) && !isNaN(numCompareValue);
          
          switch (rule.op) {
            case '==':
              return isNumeric ? numPropValue === numCompareValue : propValue == compareValue;
            case '!=':
              return isNumeric ? numPropValue !== numCompareValue : propValue != compareValue;
            case '>':
              return isNumeric && numPropValue > numCompareValue;
            case '<':
              return isNumeric && numPropValue < numCompareValue;
            case '>=':
              return isNumeric && numPropValue >= numCompareValue;
            case '<=':
              return isNumeric && numPropValue <= numCompareValue;
            default:
              return false;
          }
        });
        
        if (allRulesMatch) {
          nextTrialId = condition.nextTrialId;
          // Store custom parameters if they exist
          if (condition.customParameters) {
            matchedCustomParameters = condition.customParameters;
            console.log('Loop branching: matched custom parameters:', matchedCustomParameters);
          }
          break;
        }
      }
      
      // Si se encontró match, activar branching
      if (nextTrialId) {
        loopNextTrialId = nextTrialId;
        loopSkipRemaining = true;
        loopBranchingActive = true;
        // Store custom parameters for the next trial in the loop
        if (matchedCustomParameters) {
          loopBranchCustomParameters = matchedCustomParameters;
        }
      }
    },};



    
    const preloadSeguir = {
        type: jsPsychPreload,
       files: [],
    }
    timeline.push(preloadSeguir);
    
    const Seguir_timeline = {
    type: jsPsychHtmlButtonResponse, stimulus: jsPsych.timelineVariable("stimulus_Seguir"),
choices: jsPsych.timelineVariable("choices_Seguir"),
      data: {
        rt: "rt_Seguir",
response: "response_Seguir",
stimulus: "stimulus_Seguir",
        trial_id: 1762902528773,
        isInLoop: true,
        
      },
    on_start: function(trial) {
      // First, evaluate and apply params override conditions (if any)
      
      // Then apply custom parameters from branching conditions (higher priority)
      
      // For trials in loops, use loopBranchCustomParameters
      if (typeof loopBranchCustomParameters !== 'undefined' && loopBranchCustomParameters && typeof loopBranchCustomParameters === 'object') {
        console.log('Applying custom parameters to loop trial:', loopBranchCustomParameters);
        Object.entries(loopBranchCustomParameters).forEach(([key, param]) => {
          if (param && param.source !== 'none') {
            // Handle different parameter sources
            if (param.source === 'typed' && param.value !== undefined && param.value !== null) {
              // For typed values, use them directly
              trial[key] = param.value;
              console.log(`Set trial.${key} = ${param.value}`);
            } else if (param.source === 'csv' && param.value !== undefined && param.value !== null) {
              // For CSV values, param.value contains the column name, get the actual value from trial
              trial[key] = trial[param.value];
              console.log(`Set trial.${key} = ${trial[param.value]} (from CSV column: ${param.value})`);
            }
          }
        });
        // Clear the custom parameters after applying them
        loopBranchCustomParameters = null;
      }
      
    },
    
    on_finish: function(data) {
      // Evaluar repeat conditions (para reiniciar el experimento desde un trial específico)
      const repeatConditionsArray = [{"id":1762903488868,"rules":[{"prop":"response","op":"==","value":"0"}],"jumpToTrialId":"1762902515317"}];
      
      let shouldRepeat = false;
      for (const condition of repeatConditionsArray) {
        if (!condition || !condition.rules) {
          continue;
        }
        
        // Todas las reglas en una condición deben ser verdaderas (lógica AND)
        const allRulesMatch = condition.rules.every(rule => {
          const propValue = data[rule.prop];
          const compareValue = rule.value;
          
          // Convertir valores para comparación
          const numPropValue = parseFloat(propValue);
          const numCompareValue = parseFloat(compareValue);
          const isNumeric = !isNaN(numPropValue) && !isNaN(numCompareValue);
          
          switch (rule.op) {
            case '==':
              return isNumeric ? numPropValue === numCompareValue : propValue == compareValue;
            case '!=':
              return isNumeric ? numPropValue !== numCompareValue : propValue != compareValue;
            case '>':
              return isNumeric && numPropValue > numCompareValue;
            case '<':
              return isNumeric && numPropValue < numCompareValue;
            case '>=':
              return isNumeric && numPropValue >= numCompareValue;
            case '<=':
              return isNumeric && numPropValue <= numCompareValue;
            default:
              return false;
          }
        });
        
        if (allRulesMatch && condition.jumpToTrialId) {
          console.log('Repeat condition matched in loop! Jumping to trial:', condition.jumpToTrialId);
          // Guardar el trial objetivo en localStorage
          localStorage.setItem('jsPsych_jumpToTrial', String(condition.jumpToTrialId));
          shouldRepeat = true;
          break;
        }
      }
      
      if (shouldRepeat) {
        // Limpiar el contenedor de jsPsych (jspsych-container es el display_element)
        const container = document.getElementById('jspsych-container');
        if (container) {
          // Limpiar todo el contenido del container
          container.innerHTML = '';
        }
        // Reiniciar el timeline
        setTimeout(() => {
          jsPsych.run(timeline);
        }, 100);
        return;
      }
      
      
      // Este trial no tiene branches, verificar si el loop padre tiene branches
      if (typeof loopHasBranches !== 'undefined' && loopHasBranches) {
        // El loop tiene branches, activar branching del loop al terminar
        // Esto se manejará en el on_finish del loop
        loopShouldBranchOnFinish = true;
      } else if (!loopHasBranches) {
        // Ni el trial ni el loop tienen branches - trial terminal
        // Si llegamos aquí después de un branching global, terminar el experimento
        if (window.branchingActive) {
          jsPsych.abortExperiment('', {});
        }
      }
      
    },};



    
    const test_stimuli_loop_1762907705296 = [
  {
    "stimulus_Inicia_nested": "<div id=\"ip91\" style=\"box-sizing: border-box;\">inicia nested</div>",
    "choices_Inicia_nested": [
      "Si",
      "Nos"
    ],
    "stimulus_Final_nested": "<div id=\"isjo\" style=\"box-sizing: border-box;\">final nested</div>",
    "choices_Final_nested": [
      "Repetir",
      "Salirs"
    ],
    "stimulus_otravez": "<div id=\"imna\" style=\"box-sizing: border-box;\">otra vez</div>",
    "choices_otravez": [
      "Dije que no"
    ]
  }
];
    
    
    
    const preloadInicia_nested = {
        type: jsPsychPreload,
       files: [],
    }
    timeline.push(preloadInicia_nested);
    
    const Inicia_nested_timeline = {
    type: jsPsychHtmlButtonResponse, stimulus: jsPsych.timelineVariable("stimulus_Inicia_nested"),
choices: jsPsych.timelineVariable("choices_Inicia_nested"),
      data: {
        rt: "rt_Inicia_nested",
response: "response_Inicia_nested",
stimulus: "stimulus_Inicia_nested",
        trial_id: 1762902912364,
        isInLoop: true,
        
        branches: [1762907671377, 1762912004181],
        branchConditions: [[{"id":1762912351921,"rules":[{"prop":"response","op":"==","value":"0"}],"nextTrialId":"1762907671377","customParameters":{}},{"id":1762912364305,"rules":[{"prop":"response","op":"==","value":"1"}],"nextTrialId":"1762912004181","customParameters":{}}]] 
        
      },
    on_start: function(trial) {
      // First, evaluate and apply params override conditions (if any)
      
      // Then apply custom parameters from branching conditions (higher priority)
      
      // For trials in loops, use loopBranchCustomParameters
      if (typeof loopBranchCustomParameters !== 'undefined' && loopBranchCustomParameters && typeof loopBranchCustomParameters === 'object') {
        console.log('Applying custom parameters to loop trial:', loopBranchCustomParameters);
        Object.entries(loopBranchCustomParameters).forEach(([key, param]) => {
          if (param && param.source !== 'none') {
            // Handle different parameter sources
            if (param.source === 'typed' && param.value !== undefined && param.value !== null) {
              // For typed values, use them directly
              trial[key] = param.value;
              console.log(`Set trial.${key} = ${param.value}`);
            } else if (param.source === 'csv' && param.value !== undefined && param.value !== null) {
              // For CSV values, param.value contains the column name, get the actual value from trial
              trial[key] = trial[param.value];
              console.log(`Set trial.${key} = ${trial[param.value]} (from CSV column: ${param.value})`);
            }
          }
        });
        // Clear the custom parameters after applying them
        loopBranchCustomParameters = null;
      }
      
    },
    
    on_finish: function(data) {
      // Evaluar condiciones del trial para branching interno del loop
      const branches = [1762907671377, 1762912004181];
      const branchConditions = [{"id":1762912351921,"rules":[{"prop":"response","op":"==","value":"0"}],"nextTrialId":"1762907671377","customParameters":{}},{"id":1762912364305,"rules":[{"prop":"response","op":"==","value":"1"}],"nextTrialId":"1762912004181","customParameters":{}}].flat();
      
      let nextTrialId = null;
      let matchedCustomParameters = null;
      
      // Evaluar cada condición (lógica OR entre condiciones)
      for (const condition of branchConditions) {
        if (!condition || !condition.rules) {
          continue;
        }
        
        // Todas las reglas en una condición deben ser verdaderas (lógica AND)
        const allRulesMatch = condition.rules.every(rule => {
          const propValue = data[rule.prop];
          const compareValue = rule.value;
          
          // Convertir valores para comparación
          const numPropValue = parseFloat(propValue);
          const numCompareValue = parseFloat(compareValue);
          const isNumeric = !isNaN(numPropValue) && !isNaN(numCompareValue);
          
          switch (rule.op) {
            case '==':
              return isNumeric ? numPropValue === numCompareValue : propValue == compareValue;
            case '!=':
              return isNumeric ? numPropValue !== numCompareValue : propValue != compareValue;
            case '>':
              return isNumeric && numPropValue > numCompareValue;
            case '<':
              return isNumeric && numPropValue < numCompareValue;
            case '>=':
              return isNumeric && numPropValue >= numCompareValue;
            case '<=':
              return isNumeric && numPropValue <= numCompareValue;
            default:
              return false;
          }
        });
        
        if (allRulesMatch) {
          nextTrialId = condition.nextTrialId;
          // Store custom parameters if they exist
          if (condition.customParameters) {
            matchedCustomParameters = condition.customParameters;
            console.log('Loop branching: matched custom parameters:', matchedCustomParameters);
          }
          break;
        }
      }
      
      // Si se encontró match, activar branching
      if (nextTrialId) {
        loopNextTrialId = nextTrialId;
        loopSkipRemaining = true;
        loopBranchingActive = true;
        // Store custom parameters for the next trial in the loop
        if (matchedCustomParameters) {
          loopBranchCustomParameters = matchedCustomParameters;
        }
      }
    },};



    
    const preloadFinal_nested = {
        type: jsPsychPreload,
       files: [],
    }
    timeline.push(preloadFinal_nested);
    
    const Final_nested_timeline = {
    type: jsPsychHtmlButtonResponse, stimulus: jsPsych.timelineVariable("stimulus_Final_nested"),
choices: jsPsych.timelineVariable("choices_Final_nested"),
      data: {
        rt: "rt_Final_nested",
response: "response_Final_nested",
stimulus: "stimulus_Final_nested",
        trial_id: 1762907671377,
        isInLoop: true,
        
      },
    on_start: function(trial) {
      // First, evaluate and apply params override conditions (if any)
      
      // Then apply custom parameters from branching conditions (higher priority)
      
      // For trials in loops, use loopBranchCustomParameters
      if (typeof loopBranchCustomParameters !== 'undefined' && loopBranchCustomParameters && typeof loopBranchCustomParameters === 'object') {
        console.log('Applying custom parameters to loop trial:', loopBranchCustomParameters);
        Object.entries(loopBranchCustomParameters).forEach(([key, param]) => {
          if (param && param.source !== 'none') {
            // Handle different parameter sources
            if (param.source === 'typed' && param.value !== undefined && param.value !== null) {
              // For typed values, use them directly
              trial[key] = param.value;
              console.log(`Set trial.${key} = ${param.value}`);
            } else if (param.source === 'csv' && param.value !== undefined && param.value !== null) {
              // For CSV values, param.value contains the column name, get the actual value from trial
              trial[key] = trial[param.value];
              console.log(`Set trial.${key} = ${trial[param.value]} (from CSV column: ${param.value})`);
            }
          }
        });
        // Clear the custom parameters after applying them
        loopBranchCustomParameters = null;
      }
      
    },
    
    on_finish: function(data) {
      // Este trial no tiene branches ni repeat conditions, verificar si el loop padre tiene branches
      if (typeof loopHasBranches !== 'undefined' && loopHasBranches) {
        // El loop tiene branches, activar branching del loop al terminar
        // Esto se manejará en el on_finish del loop
        loopShouldBranchOnFinish = true;
      } else if (!loopHasBranches) {
        // Ni el trial ni el loop tienen branches - trial terminal
        // Si llegamos aquí después de un branching global, terminar el experimento
        if (window.branchingActive) {
          jsPsych.abortExperiment('', {});
        }
      }
    },};



    
    const preloadotravez = {
        type: jsPsychPreload,
       files: [],
    }
    timeline.push(preloadotravez);
    
    const otravez_timeline = {
    type: jsPsychHtmlButtonResponse, stimulus: jsPsych.timelineVariable("stimulus_otravez"),
choices: jsPsych.timelineVariable("choices_otravez"),
      data: {
        rt: "rt_otravez",
response: "response_otravez",
stimulus: "stimulus_otravez",
        trial_id: 1762912004181,
        isInLoop: true,
        
      },
    on_start: function(trial) {
      // First, evaluate and apply params override conditions (if any)
      
      // Then apply custom parameters from branching conditions (higher priority)
      
      // For trials in loops, use loopBranchCustomParameters
      if (typeof loopBranchCustomParameters !== 'undefined' && loopBranchCustomParameters && typeof loopBranchCustomParameters === 'object') {
        console.log('Applying custom parameters to loop trial:', loopBranchCustomParameters);
        Object.entries(loopBranchCustomParameters).forEach(([key, param]) => {
          if (param && param.source !== 'none') {
            // Handle different parameter sources
            if (param.source === 'typed' && param.value !== undefined && param.value !== null) {
              // For typed values, use them directly
              trial[key] = param.value;
              console.log(`Set trial.${key} = ${param.value}`);
            } else if (param.source === 'csv' && param.value !== undefined && param.value !== null) {
              // For CSV values, param.value contains the column name, get the actual value from trial
              trial[key] = trial[param.value];
              console.log(`Set trial.${key} = ${trial[param.value]} (from CSV column: ${param.value})`);
            }
          }
        });
        // Clear the custom parameters after applying them
        loopBranchCustomParameters = null;
      }
      
    },
    
    on_finish: function(data) {
      // Este trial no tiene branches ni repeat conditions, verificar si el loop padre tiene branches
      if (typeof loopHasBranches !== 'undefined' && loopHasBranches) {
        // El loop tiene branches, activar branching del loop al terminar
        // Esto se manejará en el on_finish del loop
        loopShouldBranchOnFinish = true;
      } else if (!loopHasBranches) {
        // Ni el trial ni el loop tienen branches - trial terminal
        // Si llegamos aquí después de un branching global, terminar el experimento
        if (window.branchingActive) {
          jsPsych.abortExperiment('', {});
        }
      }
    },};


// --- Branching logic variables for nested loop Nested Loop 1 ---
let loop_loop_1762907705296_NextTrialId = null;
let loop_loop_1762907705296_SkipRemaining = false;
let loop_loop_1762907705296_BranchingActive = false;
let loop_loop_1762907705296_BranchCustomParameters = null;
let loop_loop_1762907705296_TargetExecuted = false;
let loop_loop_1762907705296_IterationComplete = false;
const loop_loop_1762907705296_HasBranches = false;
let loop_loop_1762907705296_ShouldBranchOnFinish = false;

// IMPORTANTE: Guardar el scope del loop padre si existe (runtime check)
// Usamos una función inmediata para evitar problemas con el TDZ
const parent_loopNextTrialId = (() => { try { return loopNextTrialId; } catch(e) { return undefined; } })();
const parent_loopSkipRemaining = (() => { try { return loopSkipRemaining; } catch(e) { return undefined; } })();
const parent_loopBranchingActive = (() => { try { return loopBranchingActive; } catch(e) { return undefined; } })();
const parent_loopBranchCustomParameters = (() => { try { return loopBranchCustomParameters; } catch(e) { return undefined; } })();
const parent_loopTargetExecuted = (() => { try { return loopTargetExecuted; } catch(e) { return undefined; } })();
const parent_loopIterationComplete = (() => { try { return loopIterationComplete; } catch(e) { return undefined; } })();
const parent_loopHasBranches = (() => { try { return loopHasBranches; } catch(e) { return undefined; } })();
const parent_loopShouldBranchOnFinish = (() => { try { return loopShouldBranchOnFinish; } catch(e) { return undefined; } })();

// Reasignar o declarar las variables del loop para que apunten a los valores del nested loop
// Usamos una IIFE para manejar tanto el caso donde las variables existen como donde no
(() => {
  try {
    // Intentar reasignar (caso: hay un loop padre)
    loopNextTrialId = loop_loop_1762907705296_NextTrialId;
    loopSkipRemaining = loop_loop_1762907705296_SkipRemaining;
    loopBranchingActive = loop_loop_1762907705296_BranchingActive;
    loopBranchCustomParameters = loop_loop_1762907705296_BranchCustomParameters;
    loopTargetExecuted = loop_loop_1762907705296_TargetExecuted;
    loopIterationComplete = loop_loop_1762907705296_IterationComplete;
    loopHasBranches = loop_loop_1762907705296_HasBranches;
    loopShouldBranchOnFinish = loop_loop_1762907705296_ShouldBranchOnFinish;
  } catch(e) {
    // Las variables no existen, se declararán por el loop padre más adelante
    // o estamos en el scope incorrecto
  }
})();


    const Inicia_nested_wrapper = {
      timeline: [Inicia_nested_timeline],
      conditional_function: function() {
        const currentId = Inicia_nested_timeline.data.trial_id;
        
        // Verificar si hay un trial/loop objetivo guardado en localStorage (para repeat/jump global)
        const jumpToTrial = localStorage.getItem('jsPsych_jumpToTrial');
        if (jumpToTrial) {
          if (String(currentId) === String(jumpToTrial)) {
            // Encontramos el trial/loop objetivo para repeat/jump
            console.log('Repeat/jump: Found target trial/loop inside nested loop', currentId);
            localStorage.removeItem('jsPsych_jumpToTrial');
            return true;
          }
          // No es el objetivo, saltar
          console.log('Repeat/jump: Skipping trial/loop inside nested loop', currentId);
          return false;
        }
        
        // Si el item objetivo ya fue ejecutado, saltar todos los items restantes en esta iteración
        if (loop_loop_1762907705296_TargetExecuted) {
          
          return false;
        }
        
        // Si loopSkipRemaining está activo, verificar si este es el item objetivo
        if (loop_loop_1762907705296_SkipRemaining) {
          if (String(currentId) === String(loop_loop_1762907705296_NextTrialId)) {
            // Encontramos el item objetivo dentro del loop
            loop_loop_1762907705296_TargetExecuted = true;
            return true;
          }
          // No es el objetivo, saltar
          return false;
        }
        
        // No hay branching activo, ejecutar normalmente
        return true;
      },
      on_timeline_finish: function() {
        
      }
    };


    const Final_nested_wrapper = {
      timeline: [Final_nested_timeline],
      conditional_function: function() {
        const currentId = Final_nested_timeline.data.trial_id;
        
        // Verificar si hay un trial/loop objetivo guardado en localStorage (para repeat/jump global)
        const jumpToTrial = localStorage.getItem('jsPsych_jumpToTrial');
        if (jumpToTrial) {
          if (String(currentId) === String(jumpToTrial)) {
            // Encontramos el trial/loop objetivo para repeat/jump
            console.log('Repeat/jump: Found target trial/loop inside nested loop', currentId);
            localStorage.removeItem('jsPsych_jumpToTrial');
            return true;
          }
          // No es el objetivo, saltar
          console.log('Repeat/jump: Skipping trial/loop inside nested loop', currentId);
          return false;
        }
        
        // Si el item objetivo ya fue ejecutado, saltar todos los items restantes en esta iteración
        if (loop_loop_1762907705296_TargetExecuted) {
          
          return false;
        }
        
        // Si loopSkipRemaining está activo, verificar si este es el item objetivo
        if (loop_loop_1762907705296_SkipRemaining) {
          if (String(currentId) === String(loop_loop_1762907705296_NextTrialId)) {
            // Encontramos el item objetivo dentro del loop
            loop_loop_1762907705296_TargetExecuted = true;
            return true;
          }
          // No es el objetivo, saltar
          return false;
        }
        
        // No hay branching activo, ejecutar normalmente
        return true;
      },
      on_timeline_finish: function() {
        
      }
    };


    const otravez_wrapper = {
      timeline: [otravez_timeline],
      conditional_function: function() {
        const currentId = otravez_timeline.data.trial_id;
        
        // Verificar si hay un trial/loop objetivo guardado en localStorage (para repeat/jump global)
        const jumpToTrial = localStorage.getItem('jsPsych_jumpToTrial');
        if (jumpToTrial) {
          if (String(currentId) === String(jumpToTrial)) {
            // Encontramos el trial/loop objetivo para repeat/jump
            console.log('Repeat/jump: Found target trial/loop inside nested loop', currentId);
            localStorage.removeItem('jsPsych_jumpToTrial');
            return true;
          }
          // No es el objetivo, saltar
          console.log('Repeat/jump: Skipping trial/loop inside nested loop', currentId);
          return false;
        }
        
        // Si el item objetivo ya fue ejecutado, saltar todos los items restantes en esta iteración
        if (loop_loop_1762907705296_TargetExecuted) {
          
          // Último item: resetear flags para la siguiente iteración/repetición
          loop_loop_1762907705296_NextTrialId = null;
          loop_loop_1762907705296_SkipRemaining = false;
          loop_loop_1762907705296_TargetExecuted = false;
          loop_loop_1762907705296_BranchingActive = false;
          loop_loop_1762907705296_BranchCustomParameters = null;
          loop_loop_1762907705296_IterationComplete = false;
          return false;
        }
        
        // Si loopSkipRemaining está activo, verificar si este es el item objetivo
        if (loop_loop_1762907705296_SkipRemaining) {
          if (String(currentId) === String(loop_loop_1762907705296_NextTrialId)) {
            // Encontramos el item objetivo dentro del loop
            loop_loop_1762907705296_TargetExecuted = true;
            return true;
          }
          // No es el objetivo, saltar
          return false;
        }
        
        // No hay branching activo, ejecutar normalmente
        return true;
      },
      on_timeline_finish: function() {
        
        // Último item del timeline: resetear flags para la siguiente iteración/repetición
        loop_loop_1762907705296_NextTrialId = null;
        loop_loop_1762907705296_SkipRemaining = false;
        loop_loop_1762907705296_TargetExecuted = false;
        loop_loop_1762907705296_BranchingActive = false;
        loop_loop_1762907705296_BranchCustomParameters = null;
        loop_loop_1762907705296_IterationComplete = false;
      }
    };

const loop_1762907705296_procedure = {
  timeline: [Inicia_nested_wrapper, Final_nested_wrapper, otravez_wrapper],
  timeline_variables: test_stimuli_loop_1762907705296,
  repetitions: 1,
  randomize_order: false,
  loop_function: function(data) {
    // Evaluate loop conditions to determine if the nested loop should repeat
    const loopConditionsArray = [{"id":1762912141687,"rules":[{"trialId":"1762912004181","prop":"response","op":"==","value":"0"}]}];
    
    // Helper function to get data from a specific trial
    const getTrialData = (trialId) => {
      // Get all trials data
      const allTrials = data.values();
      
      // Find the last occurrence of the trial with matching trial_id
      for (let i = allTrials.length - 1; i >= 0; i--) {
        const trial = allTrials[i];
        if (String(trial.trial_id) === String(trialId)) {
          return trial;
        }
      }
      return null;
    };
    
    // Evaluate a single condition (AND logic between rules)
    const evaluateCondition = (condition) => {
      return condition.rules.every(rule => {
        const trialData = getTrialData(rule.trialId);
        
        if (!trialData) {
          console.warn('Nested loop: Trial data not found for:', rule.trialId);
          return false;
        }
        
        const propValue = trialData[rule.prop];
        const compareValue = rule.value;
        
        // Convert values for comparison
        const numPropValue = parseFloat(propValue);
        const numCompareValue = parseFloat(compareValue);
        const isNumeric = !isNaN(numPropValue) && !isNaN(numCompareValue);
        
        switch (rule.op) {
          case '==':
            return isNumeric ? numPropValue === numCompareValue : propValue == compareValue;
          case '!=':
            return isNumeric ? numPropValue !== numCompareValue : propValue != compareValue;
          case '>':
            return isNumeric && numPropValue > numCompareValue;
          case '<':
            return isNumeric && numPropValue < numCompareValue;
          case '>=':
            return isNumeric && numPropValue >= numCompareValue;
          case '<=':
            return isNumeric && numPropValue <= numCompareValue;
          default:
            return false;
        }
      });
    };
    
    // Evaluate all conditions (OR logic between conditions)
    const shouldRepeat = loopConditionsArray.some(condition => evaluateCondition(condition));
    
    console.log('Nested loop condition evaluation result for Nested Loop 1:', shouldRepeat);
    
    // Si no debe repetir Y el loop tiene branches, activar branching
    
    
    return shouldRepeat;
  },
  on_timeline_start: function() {
    // Resetear las flags al inicio de cada iteración del nested loop
    loop_loop_1762907705296_NextTrialId = null;
    loop_loop_1762907705296_SkipRemaining = false;
    loop_loop_1762907705296_BranchingActive = false;
    loop_loop_1762907705296_BranchCustomParameters = null;
    loop_loop_1762907705296_TargetExecuted = false;
    loop_loop_1762907705296_IterationComplete = false;
    loop_loop_1762907705296_ShouldBranchOnFinish = false;
    
    // Sincronizar los alias sin prefijo
    loopNextTrialId = null;
    loopSkipRemaining = false;
    loopBranchingActive = false;
    loopBranchCustomParameters = null;
    loopTargetExecuted = false;
    loopIterationComplete = false;
    loopShouldBranchOnFinish = false;
    
    // IMPORTANTE: Si el nested loop es condicional, resetear también el branching LOCAL
    // para que se regenere durante esta iteración
    
    loop_loop_1762907705296_NextTrialId = null;
    loop_loop_1762907705296_SkipRemaining = false;
    loop_loop_1762907705296_BranchingActive = false;
    loopNextTrialId = null;
    loopSkipRemaining = false;
    loopBranchingActive = false;
    console.log('Conditional nested loop iteration starting, reset local branching flags');
    
  },
  on_timeline_finish: function() {
    // Sincronizar los cambios de los alias a las variables con prefijo antes de terminar
    loop_loop_1762907705296_NextTrialId = loopNextTrialId;
    loop_loop_1762907705296_SkipRemaining = loopSkipRemaining;
    loop_loop_1762907705296_TargetExecuted = loopTargetExecuted;
    loop_loop_1762907705296_BranchingActive = loopBranchingActive;
    loop_loop_1762907705296_BranchCustomParameters = loopBranchCustomParameters;
    loop_loop_1762907705296_IterationComplete = loopIterationComplete;
    loop_loop_1762907705296_ShouldBranchOnFinish = loopShouldBranchOnFinish;
    
    // IMPORTANTE: Si el nested loop activó branching desde un trial interno (loopShouldBranchOnFinish)
    // propagar este flag al loop padre
    const nestedLoopActivatedBranching = loop_loop_1762907705296_ShouldBranchOnFinish;
    
    // Restaurar las variables del loop padre solo si existen (estamos en un nested context)
    if (typeof parent_loopNextTrialId !== 'undefined') {
      loopNextTrialId = parent_loopNextTrialId;
      loopSkipRemaining = parent_loopSkipRemaining;
      loopBranchingActive = parent_loopBranchingActive;
      loopBranchCustomParameters = parent_loopBranchCustomParameters;
      loopTargetExecuted = parent_loopTargetExecuted;
      loopIterationComplete = parent_loopIterationComplete;
      loopHasBranches = parent_loopHasBranches;
      loopShouldBranchOnFinish = parent_loopShouldBranchOnFinish;
      
      // Si el nested loop activó branching, propagar al loop padre
      if (nestedLoopActivatedBranching) {
        loopShouldBranchOnFinish = true;
        console.log('Nested loop propagating branch flag to parent loop');
      }
    } else {
      // No hay loop padre - si el nested loop activó branching, propagar al contexto global
      if (nestedLoopActivatedBranching && typeof window !== 'undefined') {
        window.branchingActive = true;
        console.log('Nested loop propagating branch flag to global context');
      }
    }
    
    // Resetear las flags del nested loop
    loop_loop_1762907705296_NextTrialId = null;
    loop_loop_1762907705296_SkipRemaining = false;
    loop_loop_1762907705296_TargetExecuted = false;
    loop_loop_1762907705296_BranchingActive = false;
    loop_loop_1762907705296_BranchCustomParameters = null;
    loop_loop_1762907705296_IterationComplete = false;
    loop_loop_1762907705296_ShouldBranchOnFinish = false;
  },
  data: {
    loop_id: "loop_1762907705296",
    loop_name: "Nested Loop 1"
  }
};

// --- Branching logic variables for internal loop trials ---
let loopNextTrialId = null;
let loopSkipRemaining = false;
let loopBranchingActive = false;
let loopBranchCustomParameters = null; // Store custom parameters for branching within loops
let loopTargetExecuted = false; // Indica si el trial objetivo ya se ejecutó en esta iteración
let loopIterationComplete = false; // Indica que la iteración actual terminó
const loopHasBranches = true;
let loopShouldBranchOnFinish = false;


    const nested_wrapper = {
      timeline: [nested_timeline],
      conditional_function: function() {
        const currentId = nested_timeline.data.trial_id;
        
        // Verificar si hay un trial/loop objetivo guardado en localStorage (para repeat/jump global)
        const jumpToTrial = localStorage.getItem('jsPsych_jumpToTrial');
        if (jumpToTrial) {
          if (String(currentId) === String(jumpToTrial)) {
            // Encontramos el trial/loop objetivo para repeat/jump
            console.log('Repeat/jump: Found target trial/loop inside loop', currentId);
            localStorage.removeItem('jsPsych_jumpToTrial');
            return true;
          }
          // No es el objetivo, saltar
          console.log('Repeat/jump: Skipping trial/loop inside loop', currentId);
          return false;
        }
        
        // Si el item objetivo ya fue ejecutado, saltar todos los items restantes en esta iteración
        if (loopTargetExecuted) {
          
          return false;
        }
        
        // Si loopSkipRemaining está activo, verificar si este es el item objetivo
        if (loopSkipRemaining) {
          if (String(currentId) === String(loopNextTrialId)) {
            // Encontramos el item objetivo dentro del loop
            loopTargetExecuted = true;
            return true;
          }
          // No es el objetivo, saltar
          return false;
        }
        
        // No hay branching activo, ejecutar normalmente
        return true;
      },
      on_timeline_finish: function() {
        
      }
    };


    const Seguir_wrapper = {
      timeline: [Seguir_timeline],
      conditional_function: function() {
        const currentId = Seguir_timeline.data.trial_id;
        
        // Verificar si hay un trial/loop objetivo guardado en localStorage (para repeat/jump global)
        const jumpToTrial = localStorage.getItem('jsPsych_jumpToTrial');
        if (jumpToTrial) {
          if (String(currentId) === String(jumpToTrial)) {
            // Encontramos el trial/loop objetivo para repeat/jump
            console.log('Repeat/jump: Found target trial/loop inside loop', currentId);
            localStorage.removeItem('jsPsych_jumpToTrial');
            return true;
          }
          // No es el objetivo, saltar
          console.log('Repeat/jump: Skipping trial/loop inside loop', currentId);
          return false;
        }
        
        // Si el item objetivo ya fue ejecutado, saltar todos los items restantes en esta iteración
        if (loopTargetExecuted) {
          
          return false;
        }
        
        // Si loopSkipRemaining está activo, verificar si este es el item objetivo
        if (loopSkipRemaining) {
          if (String(currentId) === String(loopNextTrialId)) {
            // Encontramos el item objetivo dentro del loop
            loopTargetExecuted = true;
            return true;
          }
          // No es el objetivo, saltar
          return false;
        }
        
        // No hay branching activo, ejecutar normalmente
        return true;
      },
      on_timeline_finish: function() {
        
      }
    };


    const Nested_Loop_1_wrapper = {
      timeline: [loop_1762907705296_procedure],
      conditional_function: function() {
        const currentId = "loop_1762907705296";
        
        // Verificar si hay un trial/loop objetivo guardado en localStorage (para repeat/jump global)
        const jumpToTrial = localStorage.getItem('jsPsych_jumpToTrial');
        if (jumpToTrial) {
          if (String(currentId) === String(jumpToTrial)) {
            // Encontramos el trial/loop objetivo para repeat/jump
            console.log('Repeat/jump: Found target trial/loop inside loop', currentId);
            localStorage.removeItem('jsPsych_jumpToTrial');
            return true;
          }
          // No es el objetivo, saltar
          console.log('Repeat/jump: Skipping trial/loop inside loop', currentId);
          return false;
        }
        
        // Si el item objetivo ya fue ejecutado, saltar todos los items restantes en esta iteración
        if (loopTargetExecuted) {
          
          // Último item: resetear flags para la siguiente iteración/repetición
          loopNextTrialId = null;
          loopSkipRemaining = false;
          loopTargetExecuted = false;
          loopBranchingActive = false;
          loopBranchCustomParameters = null;
          loopIterationComplete = false;
          return false;
        }
        
        // Si loopSkipRemaining está activo, verificar si este es el item objetivo
        if (loopSkipRemaining) {
          if (String(currentId) === String(loopNextTrialId)) {
            // Encontramos el item objetivo dentro del loop
            loopTargetExecuted = true;
            return true;
          }
          // No es el objetivo, saltar
          return false;
        }
        
        // No hay branching activo, ejecutar normalmente
        return true;
      },
      on_timeline_finish: function() {
        
        // Último item del timeline: resetear flags para la siguiente iteración/repetición
        loopNextTrialId = null;
        loopSkipRemaining = false;
        loopTargetExecuted = false;
        loopBranchingActive = false;
        loopBranchCustomParameters = null;
        loopIterationComplete = false;
      }
    };

const evaluateLoopCondition = (trialData, condition) => {
  // All rules in a condition must be true (AND logic)
  return condition.rules.every(rule => {
    const propValue = trialData[rule.prop];
    const compareValue = rule.value;
    
    // Convert values for comparison
    const numPropValue = parseFloat(propValue);
    const numCompareValue = parseFloat(compareValue);
    const isNumeric = !isNaN(numPropValue) && !isNaN(numCompareValue);
    
    switch (rule.op) {
      case '==':
        return isNumeric ? numPropValue === numCompareValue : propValue == compareValue;
      case '!=':
        return isNumeric ? numPropValue !== numCompareValue : propValue != compareValue;
      case '>':
        return isNumeric && numPropValue > numCompareValue;
      case '<':
        return isNumeric && numPropValue < numCompareValue;
      case '>=':
        return isNumeric && numPropValue >= numCompareValue;
      case '<=':
        return isNumeric && numPropValue <= numCompareValue;
      default:
        return false;
    }
  });
};

const getNextLoopTrialId = (lastTrialData) => {
  if (!lastTrialData || !lastTrialData.trials || !lastTrialData.trials[0]) {
    return null;
  }
  
  const trial = lastTrialData.trials[0];
  
  // Check if trial has branches
  if (!Array.isArray(trial.branches) || trial.branches.length === 0) {
    return null;
  }
  
  // Si solo hay un branch O no hay condiciones, seguir al primer branch automáticamente
  const hasMultipleBranches = trial.branches.length > 1;
  const hasBranchConditions = Array.isArray(trial.branchConditions) && trial.branchConditions.length > 0;
  
  if (!hasMultipleBranches || !hasBranchConditions) {
    console.log('Loop internal: Auto-branching to first branch:', trial.branches[0]);
    return trial.branches[0];
  }
  
  // Si hay múltiples branches Y condiciones, evaluar las condiciones
  const conditions = trial.branchConditions.flat();
  
  // Evaluate each condition (OR logic between conditions)
  for (const condition of conditions) {
    if (!condition || !condition.rules) {
      console.warn('Invalid condition structure:', condition);
      continue;
    }
    
    if (evaluateLoopCondition(trial, condition)) {
      console.log('Loop internal: Condition matched:', condition);
      return condition.nextTrialId;
    }
  }
  
  // No condition matched - seguir al primer branch por defecto
  console.log('Loop internal: No condition matched, defaulting to first branch:', trial.branches[0]);
  return trial.branches[0];
};

const loop_1762902533581_procedure = {
  timeline: [nested_wrapper, Seguir_wrapper, Nested_Loop_1_wrapper],
  timeline_variables: test_stimuli_loop_1762902533581,
  repetitions: 1,
  randomize_order: false,
  
  conditional_function: function() {
    const currentId = "loop_1762902533581";
    
    // Verificar si hay un trial objetivo guardado en localStorage (para repeat/jump)
    const jumpToTrial = localStorage.getItem('jsPsych_jumpToTrial');
    if (jumpToTrial) {
      if (String(currentId) === String(jumpToTrial)) {
        // Encontramos el loop objetivo para repeat/jump
        console.log('Repeat/jump: Found target loop', currentId);
        localStorage.removeItem('jsPsych_jumpToTrial');
        return true;
      }
      // No es el objetivo, saltar
      console.log('Repeat/jump: Skipping loop', currentId);
      return false;
    }
    
    // Si skipRemaining está activo (branching normal), verificar si este es el loop objetivo
    if (window.skipRemaining) {
      if (String(currentId) === String(window.nextTrialId)) {
        // Encontramos el loop objetivo
        window.skipRemaining = false;
        window.nextTrialId = null;
        return true;
      }
      // No es el objetivo, saltar
      return false;
    }
    
    return true;
  },
  on_timeline_start: function() {
    // Resetear las flags al inicio de cada iteración del loop
    // Esto permite que cada repetición del loop funcione correctamente
    loopNextTrialId = null;
    loopSkipRemaining = false;
    loopBranchingActive = false;
    loopBranchCustomParameters = null;
    loopTargetExecuted = false;
    loopIterationComplete = false;
    loopShouldBranchOnFinish = false;
    
    // IMPORTANTE: Si el loop es condicional, resetear también el branching GLOBAL
    // para que se regenere durante esta iteración del loop
    
  },
  on_timeline_finish: function() {
    // Resetear las flags al finalizar todas las repeticiones del loop
    loopNextTrialId = null;
    loopSkipRemaining = false;
    loopTargetExecuted = false;
    loopBranchingActive = false;
    loopBranchCustomParameters = null;
    
    // Verificar si se debe hacer branching porque un trial sin branches se completó
    // pero el loop tiene branches
    if (loopShouldBranchOnFinish && loopHasBranches) {
      const branches = [1762902536432];
      if (branches.length > 0) {
        window.nextTrialId = branches[0];
        window.skipRemaining = true;
        window.branchingActive = true;
        console.log('Loop finished (from internal trial), branching to:', branches[0]);
      }
    }
    
    // Resetear todas las variables de branching del loop
    loopNextTrialId = null;
    loopSkipRemaining = false;
    loopBranchingActive = false;
    loopBranchCustomParameters = null;
    loopShouldBranchOnFinish = false;
  },

  data: {
    loop_id: "loop_1762902533581"
  },
  on_finish: function(data) {
    // Branching automático al primer branch del loop
    // Solo si NO se activó desde trial interno (loopShouldBranchOnFinish o loopBranchingActive)
    if (!loopShouldBranchOnFinish && !loopBranchingActive) {
      const branches = [1762902536432];
      if (branches.length > 0) {
        window.nextTrialId = branches[0];
        window.skipRemaining = true;
        window.branchingActive = true;
        console.log('Loop on_finish: branching to', branches[0]);
      }
    }
  },
};
timeline.push(loop_1762902533581_procedure);



    const preloadDEspues_del_loop = {
        type: jsPsychPreload,
       files: [],
    }
    timeline.push(preloadDEspues_del_loop);
    
    const test_stimuli_DEspues_del_loop = [{stimulus: "<div id=\"iern\" style=\"box-sizing: border-box;\">DEspupes del loop</div>",
choices: ["BUnas"]}];
    const DEspues_del_loop_timeline = {
    type: jsPsychHtmlButtonResponse, stimulus: jsPsych.timelineVariable("stimulus"),
choices: jsPsych.timelineVariable("choices"),
      data: {
        rt: "rt",
response: "response",
stimulus: "stimulus",
        trial_id: 1762902536432,
        
        
      },
    on_start: function(trial) {
      // First, evaluate and apply params override conditions (if any)
      
      const paramsOverrideConditions = [{"id":1762906456091,"rules":[{"trialId":"1762902515317","prop":"response","op":"==","value":"0"}],"paramsToOverride":{"stimulus":{"source":"csv","value":"stimulus"}}}];
      
      // Evaluate params override conditions
      for (const condition of paramsOverrideConditions) {
        if (!condition || !condition.rules) {
          continue;
        }
        
        // Get data from all previous trials
        const allData = jsPsych.data.get().values();
        
        // Check if all rules match (AND logic within condition)
        const allRulesMatch = condition.rules.every(rule => {
          if (!rule.trialId || !rule.prop) {
            return false;
          }
          
          // Find data from the referenced trial
          const trialData = allData.filter(d => {
            // Compare both as strings to handle type mismatches
            return String(d.trial_id) === String(rule.trialId) || d.trial_id === rule.trialId;
          });
          if (trialData.length === 0) {
            return false;
          }
          
          // Use the most recent data if multiple exist
          const data = trialData[trialData.length - 1];
          const propValue = data[rule.prop];
          const compareValue = rule.value;
          
          // Convert values for comparison
          const numPropValue = parseFloat(propValue);
          const numCompareValue = parseFloat(compareValue);
          const isNumeric = !isNaN(numPropValue) && !isNaN(numCompareValue);
          
          switch (rule.op) {
            case '==':
              return isNumeric ? numPropValue === numCompareValue : propValue == compareValue;
            case '!=':
              return isNumeric ? numPropValue !== numCompareValue : propValue != compareValue;
            case '>':
              return isNumeric && numPropValue > numCompareValue;
            case '<':
              return isNumeric && numPropValue < numCompareValue;
            case '>=':
              return isNumeric && numPropValue >= numCompareValue;
            case '<=':
              return isNumeric && numPropValue <= numCompareValue;
            default:
              return false;
          }
        });
        
        // If all rules match, apply parameter overrides
        if (allRulesMatch && condition.paramsToOverride) {
          Object.entries(condition.paramsToOverride).forEach(([key, param]) => {
            if (param && param.source !== 'none') {
              if (param.source === 'typed' && param.value !== undefined && param.value !== null) {
                trial[key] = param.value;
              } else if (param.source === 'csv' && param.value !== undefined && param.value !== null) {
                // For CSV source, param.value contains the column name, get the actual value from trial
                trial[key] = trial[param.value];
              }
            }
          });
          // Break after first matching condition (OR logic between conditions)
          break;
        }
      }
      
      // Then apply custom parameters from branching conditions (higher priority)
      
      // For trials outside loops, use window.branchCustomParameters
      if (window.branchCustomParameters && typeof window.branchCustomParameters === 'object') {
        console.log('Applying custom parameters to trial:', window.branchCustomParameters);
        Object.entries(window.branchCustomParameters).forEach(([key, param]) => {
          if (param && param.source !== 'none') {
            // Handle different parameter sources
            if (param.source === 'typed' && param.value !== undefined && param.value !== null) {
              // For typed values, use them directly
              trial[key] = param.value;
              console.log(`Set trial.${key} = ${param.value}`);
            } else if (param.source === 'csv' && param.value !== undefined && param.value !== null) {
              // For CSV values, param.value contains the column name, get the actual value from trial
              trial[key] = trial[param.value];
              console.log(`Set trial.${key} = ${trial[param.value]} (from CSV column: ${param.value})`);
            }
          }
        });
        // Clear the custom parameters after applying them
        window.branchCustomParameters = null;
      }
      
    },
    
    on_finish: function(data) {
      // Este trial no tiene branches ni repeat conditions, es un trial terminal
      // Si llegamos aquí después de un branching, terminar el experimento
      if (window.branchingActive) {
        jsPsych.abortExperiment('', {});
      }
    },
    };
    const DEspues_del_loop_procedure = {
    timeline: 
    [DEspues_del_loop_timeline],
    timeline_variables: test_stimuli_DEspues_del_loop,
    conditional_function: function() {
      const currentId = 1762902536432;
      
      // Verificar si hay un trial objetivo guardado en localStorage (para repeat/jump)
      const jumpToTrial = localStorage.getItem('jsPsych_jumpToTrial');
      if (jumpToTrial) {
        if (String(currentId) === String(jumpToTrial)) {
          // Encontramos el trial objetivo para repeat/jump
          console.log('Repeat/jump: Found target trial', currentId);
          localStorage.removeItem('jsPsych_jumpToTrial');
          return true;
        }
        // No es el objetivo, saltar
        console.log('Repeat/jump: Skipping trial', currentId);
        return false;
      }
      
      // Si skipRemaining está activo (branching normal), verificar si este es el trial objetivo
      if (window.skipRemaining) {
        if (String(currentId) === String(window.nextTrialId)) {
          // Encontramos el trial objetivo
          window.skipRemaining = false;
          window.nextTrialId = null;
          return true;
        }
        // No es el objetivo, saltar
        return false;
      }
      
      return true;
    },
    
    };
    timeline.push(DEspues_del_loop_procedure);
  

jsPsych.run(timeline);

})();

</script></body></html>