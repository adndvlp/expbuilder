<!DOCTYPE html><html lang="en"><head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/png+xml" href="/icon/fp black.png">
    <title>Experiment</title>

    <link href="../jspsych-bundle/index.css" rel="stylesheet" type="text/css">
    <script src="https://cdn.jsdelivr.net/gh/jspsych/jspsych@jspsych@7.0.0/examples/js/webgazer/webgazer.js"></script>

    <script src="../jspsych-bundle/index.js"></script>

    <style>
      body {
        margin: 0;
        padding: 0;
        background-color: #f0f0f0;
      }
      #jspsych-container {
        width: 100%;
        height: 100vh;
      }
      #jspsych-target {
        width: 100%;
      }
    </style>
  </head>
  <body>
    <div id="jspsych-container">
      <div id="jspsych-target"></div>
    </div>

    
  

<script id="generated-script">

  // --- Recolectar metadata del sistema ---
  const getMetadata = () => {
    const ua = navigator.userAgent;
    let browserName = 'Unknown';
    let browserVersion = 'Unknown';
    
    if (ua.indexOf('Firefox') > -1) {
      browserName = 'Firefox';
      browserVersion = ua.match(/Firefox\/(\d+\.\d+)/)?.[1] || 'Unknown';
    } else if (ua.indexOf('Chrome') > -1) {
      browserName = 'Chrome';
      browserVersion = ua.match(/Chrome\/(\d+\.\d+)/)?.[1] || 'Unknown';
    } else if (ua.indexOf('Safari') > -1) {
      browserName = 'Safari';
      browserVersion = ua.match(/Version\/(\d+\.\d+)/)?.[1] || 'Unknown';
    } else if (ua.indexOf('Edg') > -1) {
      browserName = 'Edge';
      browserVersion = ua.match(/Edg\/(\d+\.\d+)/)?.[1] || 'Unknown';
    }
    
    let osName = 'Unknown';
    if (ua.indexOf('Win') > -1) osName = 'Windows';
    else if (ua.indexOf('Mac') > -1) osName = 'macOS';
    else if (ua.indexOf('Linux') > -1) osName = 'Linux';
    else if (ua.indexOf('Android') > -1) osName = 'Android';
    else if (ua.indexOf('iOS') > -1) osName = 'iOS';
    
    return {
      browser: browserName,
      browserVersion: browserVersion,
      os: osName,
      screenWidth: window.screen.width,
      screenHeight: window.screen.height,
      screenResolution: `${window.screen.width}x${window.screen.height}`,
      viewportWidth: window.innerWidth,
      viewportHeight: window.innerHeight,
      language: navigator.language,
      userAgent: ua,
      startedAt: new Date().toISOString()
    };
  };
  
  const metadata = getMetadata();

  // --- Socket.IO para tracking en tiempo real ---
  const socketScript = document.createElement('script');
  socketScript.src = '/socket.io/socket.io.js';
  socketScript.onload = () => {
    window._socketReady = true;
  };
  document.head.appendChild(socketScript);

  function waitForSocket() {
    return new Promise(resolve => {
      if (window._socketReady) return resolve();
      const interval = setInterval(() => {
        if (window._socketReady) {
          clearInterval(interval);
          resolve();
        }
      }, 50);
    });
  }

  const trialSessionId =
    (crypto.randomUUID
      ? crypto.randomUUID()
      : Math.random().toString(36).slice(2, 10));

  let participantNumber;
  let socket;

  async function saveSession(trialSessionId) {
   
   const res = await fetch("/api/append-result/76876170-6c97-47ef-ad0e-5b01d3a02f1c", {
      method: "POST",
      headers: { "Content-Type": "application/json", Accept: "*/*" },
      body: JSON.stringify({
        sessionId: trialSessionId,
        metadata: metadata
      }),
    });
  
    const result = await res.json();
    participantNumber = result.participantNumber;
    return participantNumber;
    
  }

  (async () => {

    localStorage.removeItem('jsPsych_jumpToTrial');
    
    // Esperar a que Socket.IO est√© listo
    await waitForSocket();
    socket = io();
    
    participantNumber = await saveSession(trialSessionId);

    if (typeof participantNumber !== "number" || isNaN(participantNumber)) {
      alert("The participant number is not assigned. Please, wait.");
      throw new Error("participantNumber not assigned");
    }

    // Conectar sesi√≥n con el servidor via WebSocket
    socket.emit('join-experiment', {
      experimentID: '76876170-6c97-47ef-ad0e-5b01d3a02f1c',
      sessionId: trialSessionId,
      state: 'initiated',
      metadata: metadata
    });

    // --- Branching logic functions (outside initJsPsych for timeline access) ---
    window.nextTrialId = null;
    window.skipRemaining = false;
    window.branchingActive = false;
    window.branchCustomParameters = null; // Store custom parameters for the next trial

    const evaluateCondition = (trialData, condition) => {
      // All rules in a condition must be true (AND logic)
      return condition.rules.every(rule => {
        // New flat structure: rule.column contains the direct column name
        // e.g., "ButtonResponseComponent_1_response" or "response" for normal plugins
        const columnName = rule.column || rule.prop; // Fallback to rule.prop for backward compatibility
        
        if (!columnName) {
          console.warn('No column name specified in rule:', rule);
          return false;
        }
        
        // Get value directly from the column
        const propValue = trialData[columnName];
        
        if (propValue === undefined) {
          console.warn('Column not found in trial data:', columnName);
          return false;
        }
        
        const compareValue = rule.value;
        
        // Handle array responses (multi-select or single-select returned as array)
        if (Array.isArray(propValue)) {
          const matches = propValue.includes(compareValue) || propValue.includes(String(compareValue));
          switch (rule.op) {
            case '==':
              return matches;
            case '!=':
              return !matches;
            default:
              return false;
          }
        }
        
        // Convert values for comparison (for non-array values)
        const numPropValue = parseFloat(propValue);
        const numCompareValue = parseFloat(compareValue);
        const isNumeric = !isNaN(numPropValue) && !isNaN(numCompareValue);
        
        switch (rule.op) {
          case '==':
            return isNumeric ? numPropValue === numCompareValue : propValue == compareValue;
          case '!=':
            return isNumeric ? numPropValue !== numCompareValue : propValue != compareValue;
          case '>':
            return isNumeric && numPropValue > numCompareValue;
          case '<':
            return isNumeric && numPropValue < numCompareValue;
          case '>=':
            return isNumeric && numPropValue >= numCompareValue;
          case '<=':
            return isNumeric && numPropValue <= numCompareValue;
          default:
            return false;
        }
      });
    };
    
    const getNextTrialId = (lastTrialData) => {
      if (!lastTrialData || !lastTrialData.trials || !lastTrialData.trials[0]) {
        return null;
      }
      
      const trial = lastTrialData.trials[0];
      
      // Check if trial/loop has branches
      if (!Array.isArray(trial.branches) || trial.branches.length === 0) {
        return null;
      }
      
      // Check if there are conditions to evaluate
      const hasBranchConditions = Array.isArray(trial.branchConditions) && trial.branchConditions.length > 0;
      
      // Check if any condition has customParameters
      const hasCustomParameters = hasBranchConditions && 
        trial.branchConditions.flat().some(condition => 
          condition && condition.customParameters && 
          Object.keys(condition.customParameters).length > 0
        );
      
      // If there are no conditions AND no custom parameters, auto-branch to first branch
      if (!hasBranchConditions && !hasCustomParameters) {
        console.log('No conditions or custom parameters defined, auto-branching to first branch:', trial.branches[0]);
        return trial.branches[0];
      }
      
      // If there are no conditions but there ARE custom parameters, we can't auto-branch
      // We need to evaluate conditions to know which customParameters to use
      if (!hasBranchConditions && hasCustomParameters) {
        console.log('Custom parameters exist but no conditions, cannot auto-branch');
        return null;
      }
      
      // If there ARE conditions, evaluate them (regardless of how many branches there are)
      // branchConditions is an array of arrays, flatten it first
      const conditions = trial.branchConditions.flat();
      
      // Evaluate each condition (OR logic between conditions)
      for (const condition of conditions) {
        if (!condition || !condition.rules) {
          console.warn('Invalid condition structure:', condition);
          continue;
        }
        
        if (evaluateCondition(trial, condition)) {
          // Store custom parameters if they exist
          if (condition.customParameters) {
            window.branchCustomParameters = condition.customParameters;
          }
          return condition.nextTrialId;
        }
      }
      
      // No condition matched - do NOT branch (conditions were defined but none matched)
      return null;
    };

    // Track pending data saves to ensure all complete before finishing
    const pendingDataSaves = [];

    const jsPsych = initJsPsych({
          display_element: document.getElementById('jspsych-container'),


    

    on_data_update: function (data) {
      // Create and track the promise for this data save
      const savePromise = fetch("/api/append-result/76876170-6c97-47ef-ad0e-5b01d3a02f1c", {
        method: "PUT",
        headers: { "Content-Type": "application/json", Accept: "*/*" },
        body: JSON.stringify({
          sessionId: trialSessionId,
          response: data,
        }),
      })
      .then(res => {
        if (!res.ok) {
          console.error('Error saving trial data:', res.statusText);
        }
        return res;
      })
      .catch(error => {
        console.error('Error in on_data_update:', error);
      })
      .finally(() => {
        // Remove from pending once complete
        const index = pendingDataSaves.indexOf(savePromise);
        if (index > -1) {
          pendingDataSaves.splice(index, 1);
        }
      });
      
      pendingDataSaves.push(savePromise);
      
      // Actualizar estado a 'in-progress' en la primera actualizaci√≥n
      if (data.trial_index === 0 && socket) {
        socket.emit('update-session-state', {
          experimentID: '76876170-6c97-47ef-ad0e-5b01d3a02f1c',
          sessionId: trialSessionId,
          state: 'in-progress'
        });
      }
      
      // Solo evaluar branching si el trial/loop tiene un trial_id o loop_id v√°lido
      if ((!data.trial_id || data.trial_id === undefined) && (!data.loop_id || data.loop_id === undefined)) {
        return;
      }
      
      const lastTrialData = jsPsych.data.getLastTrialData();
      const trial = lastTrialData.trials ? lastTrialData.trials[0] : null;
      
      // Verificar si este trial/loop tiene branches
      if (!trial || !trial.branches || trial.branches.length === 0) {
        return; // No tiene branches, no hay nada que hacer
      }
      
      // IMPORTANTE: Si el trial est√° dentro de un loop (isInLoop = true),
      // NO activar el branching global. Los trials dentro de loops usan su propio
      // sistema de branching con variables locales (loopNextTrialId, etc.)
      if (trial.isInLoop === true) {
        return;
      }
      
      const nextTrialId = getNextTrialId(lastTrialData);
      
      if (nextTrialId) {
        // Check if nextTrialId is "FINISH_EXPERIMENT"
        if (nextTrialId === 'FINISH_EXPERIMENT') {
          console.log('üèÅ [BRANCHING] Finishing experiment via branching');
          jsPsych.abortExperiment('Experiment finished by branching condition', {});
          return;
        }
        
        console.log('üéØ [BRANCHING] Setting global branch target:', nextTrialId);
        window.nextTrialId = nextTrialId;
        window.skipRemaining = true;
        window.branchingActive = true;
        console.log('üéØ [BRANCHING] Skip remaining activated');
      }
    },

  on_finish: async function() {
    // Wait for all pending data saves to complete
    if (pendingDataSaves.length > 0) {
      console.log('Waiting for', pendingDataSaves.length, 'pending data saves to complete...');
      await Promise.allSettled(pendingDataSaves);
      console.log('All data saves completed');
    }
    
    // Marcar como completado
    if (socket) {
      socket.emit('update-session-state', {
        experimentID: '76876170-6c97-47ef-ad0e-5b01d3a02f1c',
        sessionId: trialSessionId,
        state: 'completed'
      });
    }
    
    await fetch("/api/complete-session/76876170-6c97-47ef-ad0e-5b01d3a02f1c", {
      method: "POST",
      headers: { "Content-Type": "application/json", Accept: "*/*" },
      body: JSON.stringify({
        sessionId: trialSessionId,
      }),
    });
    // jsPsych.data.displayData();
  }
});

const timeline = [];

// Global preload for all uploaded files from Timeline



    const test_stimuli_New_Trial = [{components: [{ type: "HtmlComponent", coordinates: {"x":0,"y":0}, width: 200, height: 50, name: "HtmlComponent_1", stimulus: "<div id=\"iqbh\" style=\"box-sizing: border-box;\">agua</div>" }],
response_components: [{ type: "ButtonResponseComponent", coordinates: {"x":-0.27459016393442637,"y":0.28415300546448075}, width: 200, height: 50, name: "ButtonResponseComponent_1", choices: ["no"] }, { type: "ButtonResponseComponent", coordinates: {"x":0.2827868852459017,"y":0.27868852459016386}, width: 200, height: 50, name: "ButtonResponseComponent_2", choices: ["si"] }]}];
    const New_Trial_timeline = {
    type: DynamicPlugin, components: jsPsych.timelineVariable("components"),
response_components: jsPsych.timelineVariable("response_components"),
      data: {
        rt: "rt",
        trial_id: 1769321879545,
        
        
        branches: [1769321882769, "loop_1769327951177"],
        branchConditions: [[{"id":1769327889221,"rules":[{"column":"","op":"==","value":"no","fieldType":"response_components","componentIdx":"ButtonResponseComponent_1","prop":"response"}],"nextTrialId":"1769321882769","customParameters":{}},{"id":1769327902544,"rules":[{"column":"","op":"==","value":"si","fieldType":"response_components","componentIdx":"ButtonResponseComponent_2","prop":"response"}],"nextTrialId":"loop_1769327951177","customParameters":{}}]] 
        
      },
    on_start: function(trial) {
      // Then apply custom parameters from branching conditions (higher priority)
      // For trials outside loops, use window.branchCustomParameters
      if (window.branchCustomParameters && typeof window.branchCustomParameters === 'object') {
        Object.entries(window.branchCustomParameters).forEach(([key, param]) => {
          if (param && param.source !== 'none') {
            // Parse key to check if it's a nested survey question
            const parts = key.split('::');
            
            if (parts.length === 4) {
              // Format: fieldType::componentName::survey_json::questionName
              const [fieldType, componentName, propName, questionName] = parts;
              
              if (fieldType && componentName && propName === 'survey_json' && questionName) {
                // Find the component by name in the field array
                const fieldArray = trial[fieldType];
                if (Array.isArray(fieldArray)) {
                  const compIndex = fieldArray.findIndex(c => c.name === componentName);
                  if (compIndex !== -1 && fieldArray[compIndex].survey_json) {
                    // Find the question in survey_json.elements
                    const elements = fieldArray[compIndex].survey_json.elements || [];
                    const questionIndex = elements.findIndex(q => q.name === questionName);
                    
                    if (questionIndex !== -1) {
                      // Apply the override value (from typed or csv)
                      let valueToSet;
                      if (param.source === 'typed') {
                        valueToSet = String(param.value); // Convert to string for SurveyJS
                      } else if (param.source === 'csv') {
                        valueToSet = String(trial[param.value]); // Get from CSV column and convert to string
                      }
                      
                      if (valueToSet !== undefined && valueToSet !== null) {
                        fieldArray[compIndex].survey_json.elements[questionIndex].defaultValue = valueToSet;
                      }
                    }
                  }
                }
              }
            } else if (parts.length === 3) {
              // Format: fieldType::componentName::property (for DynamicPlugin components)
              const [fieldType, componentName, propName] = parts;
              
              if (fieldType && componentName && propName) {
                // Find the component by name in the field array
                const fieldArray = trial[fieldType];
                if (Array.isArray(fieldArray)) {
                  const compIndex = fieldArray.findIndex(c => c.name === componentName);
                  if (compIndex !== -1) {
                    // Apply the override value (from typed or csv)
                    let valueToSet;
                    if (param.source === 'typed') {
                      valueToSet = param.value;
                    } else if (param.source === 'csv') {
                      valueToSet = trial[param.value];
                    }
                    
                    if (valueToSet !== undefined && valueToSet !== null) {
                      fieldArray[compIndex][propName] = valueToSet;
                    }
                  }
                }
              }
            } else {
              // Normal parameter (not nested survey question)
              if (param.source === 'typed' && param.value !== undefined && param.value !== null) {
                trial[key] = param.value;
              } else if (param.source === 'csv' && param.value !== undefined && param.value !== null) {
                trial[key] = trial[param.value];
              }
            }
          }
        });
        // Clear the custom parameters after applying them
        window.branchCustomParameters = null;
      }
      
    },
    on_finish: function(data) {
      // Evaluar condiciones del trial para branching global
      console.log('üîç [GLOBAL BRANCH] Evaluating branch conditions...');
      const branches = [1769321882769, "loop_1769327951177"];
      const branchConditions = [{"id":1769327889221,"rules":[{"column":"","op":"==","value":"no","fieldType":"response_components","componentIdx":"ButtonResponseComponent_1","prop":"response"}],"nextTrialId":"1769321882769","customParameters":{}},{"id":1769327902544,"rules":[{"column":"","op":"==","value":"si","fieldType":"response_components","componentIdx":"ButtonResponseComponent_2","prop":"response"}],"nextTrialId":"loop_1769327951177","customParameters":{}}].flat();
      console.log('üîç [GLOBAL BRANCH] Available branches:', branches);
      console.log('üîç [GLOBAL BRANCH] Conditions to evaluate:', branchConditions.length);
      
      let nextTrialId = null;
      let matchedCustomParameters = null;
      
      // Evaluar cada condici√≥n (l√≥gica OR entre condiciones)
      for (const condition of branchConditions) {
        if (!condition || !condition.rules) {
          continue;
        }
        
        // Todas las reglas en una condici√≥n deben ser verdaderas (l√≥gica AND)
        const allRulesMatch = condition.rules.every(rule => {
          let propValue;
          
          // Parse column name to extract component info for dynamic plugins
          // Format: "componentName_propertyName" or "componentName_questionName" for surveys
          // If column is empty, construct it from componentIdx and prop
          let columnName = rule.column || "";
          if (!columnName && rule.componentIdx && rule.prop) {
            columnName = rule.componentIdx + '_' + rule.prop;
          }
          const parts = columnName.split("_");
          
          // Check if this looks like a dynamic plugin column (has underscore)
          if (parts.length >= 2) {
            // Last part is the property or question name
            const propertyOrQuestion = parts[parts.length - 1];
            // Everything before the last underscore is the component name
            const componentName = parts.slice(0, -1).join("_");
            
            // Try to find the data in the format: componentName_response
            const responseKey = componentName + '_response';
            const responseData = data[responseKey];
            
            // If response data exists and is an object (SurveyComponent case)
            if (responseData && typeof responseData === 'object' && !Array.isArray(responseData)) {
              // This is likely a survey response - check if property is a question name
              if (responseData[propertyOrQuestion] !== undefined) {
                propValue = responseData[propertyOrQuestion];
              } else {
                return false;
              }
            } else {
              // Not a survey response object, try direct property access
              const directKey = componentName + '_' + propertyOrQuestion;
              if (data[directKey] !== undefined) {
                propValue = data[directKey];
              } else {
                return false;
              }
            }
          } else {
            // Normal plugin structure - direct property access
            propValue = data[columnName];
          }
          
          const compareValue = rule.value;
          
          // Handle array responses (multi-select or single-select returned as array)
          if (Array.isArray(propValue)) {
            const matches = propValue.includes(compareValue) || propValue.includes(String(compareValue));
            switch (rule.op) {
              case '==':
                return matches;
              case '!=':
                return !matches;
              default:
                return false;
            }
          }
          
          // Convertir valores para comparaci√≥n
          const numPropValue = parseFloat(propValue);
          const numCompareValue = parseFloat(compareValue);
          const isNumeric = !isNaN(numPropValue) && !isNaN(numCompareValue);
          
          switch (rule.op) {
            case '==':
              return isNumeric ? numPropValue === numCompareValue : propValue == compareValue;
            case '!=':
              return isNumeric ? numPropValue !== numCompareValue : propValue != compareValue;
            case '>':
              return isNumeric && numPropValue > numCompareValue;
            case '<':
              return isNumeric && numPropValue < numCompareValue;
            case '>=':
              return isNumeric && numPropValue >= numCompareValue;
            case '<=':
              return isNumeric && numPropValue <= numCompareValue;
            default:
              return false;
          }
        });
        
        if (allRulesMatch) {
          console.log('‚úÖ [GLOBAL BRANCH] Condition matched! Next trial:', condition.nextTrialId);
          nextTrialId = condition.nextTrialId;
          // Store custom parameters if they exist
          if (condition.customParameters) {
            matchedCustomParameters = condition.customParameters;
            console.log('‚úÖ [GLOBAL BRANCH] Custom parameters:', matchedCustomParameters);
          }
          break;
        }
      }
      
      // Si se encontr√≥ match, activar branching
      if (nextTrialId) {
        console.log('üéØ [GLOBAL BRANCH] Activating branching to trial:', nextTrialId);
        window.nextTrialId = nextTrialId;
        window.skipRemaining = true;
        window.branchingActive = true;
        // Store custom parameters for the next trial
        if (matchedCustomParameters) {
          window.branchCustomParameters = matchedCustomParameters;
        }
      } else {
        // No match - ir al primer branch por defecto
        console.log('‚ö†Ô∏è [GLOBAL BRANCH] No condition matched, branching to first branch:', branches[0]);
        window.nextTrialId = branches[0];
        window.skipRemaining = true;
        window.branchingActive = true;
      }
      
    },};
    console.log("=== PROCEDURE SETUP New_Trial ===");
    console.log("test_stimuli_New_Trial before procedure:", test_stimuli_New_Trial);
    console.log("test_stimuli_New_Trial.length:", test_stimuli_New_Trial ? test_stimuli_New_Trial.length : 'undefined');
    
    const New_Trial_procedure = {
    timeline: 
    [New_Trial_timeline],
    timeline_variables: test_stimuli_New_Trial,
    
    conditional_function: function() {
      const currentId = 1769321879545;
      
      // Verificar si hay un trial objetivo guardado en localStorage (para repeat/jump)
      const jumpToTrial = localStorage.getItem('jsPsych_jumpToTrial');
      if (jumpToTrial) {
        if (String(currentId) === String(jumpToTrial)) {
          // Encontramos el trial objetivo para repeat/jump
          console.log('üîÅ [REPEAT/JUMP] Found target trial', currentId);
          localStorage.removeItem('jsPsych_jumpToTrial');
          return true;
        }
        // No es el objetivo, saltar
        console.log('‚è≠Ô∏è [REPEAT/JUMP] Skipping trial', currentId);
        return false;
      }
      
      // Si skipRemaining est√° activo (branching normal), verificar si este es el trial objetivo
      if (window.skipRemaining) {
        console.log('üîç [SKIP CHECK] Trial', currentId, '| Target:', window.nextTrialId, '| Match:', String(currentId) === String(window.nextTrialId));
        if (String(currentId) === String(window.nextTrialId)) {
          // Encontramos el trial objetivo
          console.log('‚úÖ [SKIP CHECK] Found target trial! Disabling skip mode');
          window.skipRemaining = false;
          window.nextTrialId = null;
          return true;
        }
        // No es el objetivo, saltar
        console.log('‚è≠Ô∏è [SKIP CHECK] Skipping trial', currentId);
        return false;
      }
      
      return true;
    },
  
    
    };
    timeline.push(New_Trial_procedure);
  


    const test_stimuli_New_Trial_1 = [{components: [{ type: "HtmlComponent", coordinates: {"x":0,"y":0}, width: 200, height: 50, name: "HtmlComponent_1", stimulus: "<div id=\"irs4\" style=\"box-sizing: border-box;\">pues toma agua</div>" }],
response_components: [{ type: "ButtonResponseComponent", coordinates: {"x":0.004098360655737654,"y":0.3387978142076502}, width: 200, height: 50, name: "ButtonResponseComponent_1", choices: ["nel"] }]}];
    const New_Trial_1_timeline = {
    type: DynamicPlugin, components: jsPsych.timelineVariable("components"),
response_components: jsPsych.timelineVariable("response_components"),
      data: {
        rt: "rt",
        trial_id: 1769321882769,
        
        
      },
    on_start: function(trial) {
      // Then apply custom parameters from branching conditions (higher priority)
      // For trials outside loops, use window.branchCustomParameters
      if (window.branchCustomParameters && typeof window.branchCustomParameters === 'object') {
        Object.entries(window.branchCustomParameters).forEach(([key, param]) => {
          if (param && param.source !== 'none') {
            // Parse key to check if it's a nested survey question
            const parts = key.split('::');
            
            if (parts.length === 4) {
              // Format: fieldType::componentName::survey_json::questionName
              const [fieldType, componentName, propName, questionName] = parts;
              
              if (fieldType && componentName && propName === 'survey_json' && questionName) {
                // Find the component by name in the field array
                const fieldArray = trial[fieldType];
                if (Array.isArray(fieldArray)) {
                  const compIndex = fieldArray.findIndex(c => c.name === componentName);
                  if (compIndex !== -1 && fieldArray[compIndex].survey_json) {
                    // Find the question in survey_json.elements
                    const elements = fieldArray[compIndex].survey_json.elements || [];
                    const questionIndex = elements.findIndex(q => q.name === questionName);
                    
                    if (questionIndex !== -1) {
                      // Apply the override value (from typed or csv)
                      let valueToSet;
                      if (param.source === 'typed') {
                        valueToSet = String(param.value); // Convert to string for SurveyJS
                      } else if (param.source === 'csv') {
                        valueToSet = String(trial[param.value]); // Get from CSV column and convert to string
                      }
                      
                      if (valueToSet !== undefined && valueToSet !== null) {
                        fieldArray[compIndex].survey_json.elements[questionIndex].defaultValue = valueToSet;
                      }
                    }
                  }
                }
              }
            } else if (parts.length === 3) {
              // Format: fieldType::componentName::property (for DynamicPlugin components)
              const [fieldType, componentName, propName] = parts;
              
              if (fieldType && componentName && propName) {
                // Find the component by name in the field array
                const fieldArray = trial[fieldType];
                if (Array.isArray(fieldArray)) {
                  const compIndex = fieldArray.findIndex(c => c.name === componentName);
                  if (compIndex !== -1) {
                    // Apply the override value (from typed or csv)
                    let valueToSet;
                    if (param.source === 'typed') {
                      valueToSet = param.value;
                    } else if (param.source === 'csv') {
                      valueToSet = trial[param.value];
                    }
                    
                    if (valueToSet !== undefined && valueToSet !== null) {
                      fieldArray[compIndex][propName] = valueToSet;
                    }
                  }
                }
              }
            } else {
              // Normal parameter (not nested survey question)
              if (param.source === 'typed' && param.value !== undefined && param.value !== null) {
                trial[key] = param.value;
              } else if (param.source === 'csv' && param.value !== undefined && param.value !== null) {
                trial[key] = trial[param.value];
              }
            }
          }
        });
        // Clear the custom parameters after applying them
        window.branchCustomParameters = null;
      }
      
    },
    on_finish: function(data) {
      // Evaluar repeat conditions (para reiniciar el experimento desde un trial espec√≠fico)
      const repeatConditionsArray = [{"id":1769327873454,"rules":[{"column":"","op":"==","value":"nel","fieldType":"response_components","componentIdx":"ButtonResponseComponent_1","prop":"response"}],"jumpToTrialId":"1769321879545"}];
      
      let shouldRepeat = false;
      for (const condition of repeatConditionsArray) {
        if (!condition || !condition.rules) {
          continue;
        }
        
        // Todas las reglas en una condici√≥n deben ser verdaderas (l√≥gica AND)
        const allRulesMatch = condition.rules.every(rule => {
          // Construct column name if empty (for dynamic plugins)
          let columnName = rule.column || "";
          if (!columnName && rule.componentIdx && rule.prop) {
            columnName = rule.componentIdx + '_' + rule.prop;
          }
          
          // Get the property value using the column name
          const propValue = data[columnName || rule.prop];
          const compareValue = rule.value;
          
          // Handle array responses (multi-select questions)
          if (Array.isArray(propValue)) {
            // For array values, check if compareValue is included in the array
            switch (rule.op) {
              case '==':
                return propValue.includes(compareValue);
              case '!=':
                return !propValue.includes(compareValue);
              default:
                return false; // Comparison operators don't make sense for arrays
            }
          }
          
          // Convertir valores para comparaci√≥n (for non-array values)
          const numPropValue = parseFloat(propValue);
          const numCompareValue = parseFloat(compareValue);
          const isNumeric = !isNaN(numPropValue) && !isNaN(numCompareValue);
          
          switch (rule.op) {
            case '==':
              return isNumeric ? numPropValue === numCompareValue : propValue == compareValue;
            case '!=':
              return isNumeric ? numPropValue !== numCompareValue : propValue != compareValue;
            case '>':
              return isNumeric && numPropValue > numCompareValue;
            case '<':
              return isNumeric && numPropValue < numCompareValue;
            case '>=':
              return isNumeric && numPropValue >= numCompareValue;
            case '<=':
              return isNumeric && numPropValue <= numCompareValue;
            default:
              return false;
          }
        });
        
        if (allRulesMatch && condition.jumpToTrialId) {
          console.log('Repeat condition matched! Jumping to trial:', condition.jumpToTrialId);
          // Guardar el trial objetivo en localStorage
          localStorage.setItem('jsPsych_jumpToTrial', String(condition.jumpToTrialId));
          shouldRepeat = true;
          break;
        }
      }
      
      if (shouldRepeat) {
        // Limpiar el contenedor de jsPsych (jspsych-container es el display_element)
        const container = document.getElementById('jspsych-container');
        if (container) {
          // Limpiar todo el contenido del container
          container.innerHTML = '';
        }
        // Reiniciar el timeline
        setTimeout(() => {
          jsPsych.run(timeline);
        }, 100);
        return;
      }
      
    },};
    console.log("=== PROCEDURE SETUP New_Trial_1 ===");
    console.log("test_stimuli_New_Trial_1 before procedure:", test_stimuli_New_Trial_1);
    console.log("test_stimuli_New_Trial_1.length:", test_stimuli_New_Trial_1 ? test_stimuli_New_Trial_1.length : 'undefined');
    
    const New_Trial_1_procedure = {
    timeline: 
    [New_Trial_1_timeline],
    timeline_variables: test_stimuli_New_Trial_1,
    
    conditional_function: function() {
      const currentId = 1769321882769;
      
      // Verificar si hay un trial objetivo guardado en localStorage (para repeat/jump)
      const jumpToTrial = localStorage.getItem('jsPsych_jumpToTrial');
      if (jumpToTrial) {
        if (String(currentId) === String(jumpToTrial)) {
          // Encontramos el trial objetivo para repeat/jump
          console.log('üîÅ [REPEAT/JUMP] Found target trial', currentId);
          localStorage.removeItem('jsPsych_jumpToTrial');
          return true;
        }
        // No es el objetivo, saltar
        console.log('‚è≠Ô∏è [REPEAT/JUMP] Skipping trial', currentId);
        return false;
      }
      
      // Si skipRemaining est√° activo (branching normal), verificar si este es el trial objetivo
      if (window.skipRemaining) {
        console.log('üîç [SKIP CHECK] Trial', currentId, '| Target:', window.nextTrialId, '| Match:', String(currentId) === String(window.nextTrialId));
        if (String(currentId) === String(window.nextTrialId)) {
          // Encontramos el trial objetivo
          console.log('‚úÖ [SKIP CHECK] Found target trial! Disabling skip mode');
          window.skipRemaining = false;
          window.nextTrialId = null;
          return true;
        }
        // No es el objetivo, saltar
        console.log('‚è≠Ô∏è [SKIP CHECK] Skipping trial', currentId);
        return false;
      }
      
      return true;
    },
  
    
    };
    timeline.push(New_Trial_1_procedure);
  



    const test_stimuli_loop_1769327951177 = [
  {
    "components_New_Trial_3": [
      {
        "type": "HtmlComponent",
        "coordinates": {
          "x": 0,
          "y": 0
        },
        "width": 200,
        "height": 50,
        "name": "HtmlComponent_1",
        "stimulus": "<div id=\"iwdf\" style=\"box-sizing: border-box;\">de sabor?</div>"
      }
    ],
    "response_components_New_Trial_3": [
      {
        "type": "ButtonResponseComponent",
        "coordinates": {
          "x": -0.24590163934426235,
          "y": 0.26229508196721296
        },
        "width": 200,
        "height": 50,
        "name": "ButtonResponseComponent_1",
        "choices": [
          "si"
        ]
      },
      {
        "type": "ButtonResponseComponent",
        "coordinates": {
          "x": 0.2581967213114751,
          "y": 0.27868852459016386
        },
        "width": 200,
        "height": 50,
        "name": "ButtonResponseComponent_2",
        "choices": [
          "no"
        ]
      }
    ],
    "components_New_Trial_2": [],
    "response_components_New_Trial_2": []
  }
];
    
    
    
    const New_Trial_3_timeline = {
    type: DynamicPlugin, components: jsPsych.timelineVariable("components_New_Trial_3"),
response_components: jsPsych.timelineVariable("response_components_New_Trial_3"),
      data: {
        rt: "rt_New_Trial_3",
        trial_id: 1769321886621,
        isInLoop: true,
        
        branches: [1769327944691, "loop_1769327960658"],
        branchConditions: [[{"id":1769327972121,"rules":[{"column":"","op":"==","value":"si","fieldType":"response_components","componentIdx":"ButtonResponseComponent_1","prop":"response"}],"nextTrialId":"loop_1769327960658","customParameters":{}},{"id":1769327988304,"rules":[{"column":"","op":"==","value":"no","fieldType":"response_components","componentIdx":"ButtonResponseComponent_2","prop":"response"}],"nextTrialId":"1769327944691","customParameters":{}}]] 
        
      },
    on_start: function(trial) {
      // Then apply custom parameters from branching conditions (higher priority)
      // For trials in loops, use loop-specific BranchCustomParameters
      if (typeof loop_loop_1769327951177_BranchCustomParameters !== 'undefined' && loop_loop_1769327951177_BranchCustomParameters && typeof loop_loop_1769327951177_BranchCustomParameters === 'object') {
        Object.entries(loop_loop_1769327951177_BranchCustomParameters).forEach(([key, param]) => {
          if (param && param.source !== 'none') {
            // Parse key to check if it's a nested survey question
            const parts = key.split('::');
            
            if (parts.length === 4) {
              // Format: fieldType::componentName::survey_json::questionName
              const [fieldType, componentName, propName, questionName] = parts;
              
              if (fieldType && componentName && propName === 'survey_json' && questionName) {
                // Find the component by name in the field array
                const fieldArray = trial[fieldType];
                if (Array.isArray(fieldArray)) {
                  const compIndex = fieldArray.findIndex(c => c.name === componentName);
                  if (compIndex !== -1 && fieldArray[compIndex].survey_json) {
                    // Find the question in survey_json.elements
                    const elements = fieldArray[compIndex].survey_json.elements || [];
                    const questionIndex = elements.findIndex(q => q.name === questionName);
                    
                    if (questionIndex !== -1) {
                      // Apply the override value (from typed or csv)
                      let valueToSet;
                      if (param.source === 'typed') {
                        valueToSet = String(param.value); // Convert to string for SurveyJS
                      } else if (param.source === 'csv') {
                        valueToSet = String(trial[param.value]); // Get from CSV column and convert to string
                      }
                      
                      if (valueToSet !== undefined && valueToSet !== null) {
                        fieldArray[compIndex].survey_json.elements[questionIndex].defaultValue = valueToSet;
                      }
                    }
                  }
                }
              }
            } else if (parts.length === 3) {
              // Format: fieldType::componentName::property (for DynamicPlugin components)
              const [fieldType, componentName, propName] = parts;
              
              if (fieldType && componentName && propName) {
                // Find the component by name in the field array
                const fieldArray = trial[fieldType];
                if (Array.isArray(fieldArray)) {
                  const compIndex = fieldArray.findIndex(c => c.name === componentName);
                  if (compIndex !== -1) {
                    // Apply the override value (from typed or csv)
                    let valueToSet;
                    if (param.source === 'typed') {
                      valueToSet = param.value;
                    } else if (param.source === 'csv') {
                      valueToSet = trial[param.value];
                    }
                    
                    if (valueToSet !== undefined && valueToSet !== null) {
                      fieldArray[compIndex][propName] = valueToSet;
                    }
                  }
                }
              }
            } else {
              // Normal parameter (not nested survey question)
              if (param.source === 'typed' && param.value !== undefined && param.value !== null) {
                trial[key] = param.value;
              } else if (param.source === 'csv' && param.value !== undefined && param.value !== null) {
                trial[key] = trial[param.value];
              }
            }
          }
        });
        // Clear the custom parameters after applying them
        loop_loop_1769327951177_BranchCustomParameters = null;
      }
      
    },
    on_finish: function(data) {
      // Evaluar condiciones del trial para branching interno del loop
      console.log('üîç [LOOP BRANCH] Evaluating branch conditions...');
      const branches = [1769327944691, "loop_1769327960658"];
      const branchConditions = [{"id":1769327972121,"rules":[{"column":"","op":"==","value":"si","fieldType":"response_components","componentIdx":"ButtonResponseComponent_1","prop":"response"}],"nextTrialId":"loop_1769327960658","customParameters":{}},{"id":1769327988304,"rules":[{"column":"","op":"==","value":"no","fieldType":"response_components","componentIdx":"ButtonResponseComponent_2","prop":"response"}],"nextTrialId":"1769327944691","customParameters":{}}].flat();
      console.log('üîç [LOOP BRANCH] Available branches:', branches);
      console.log('üîç [LOOP BRANCH] Conditions to evaluate:', branchConditions.length);
      
      let nextTrialId = null;
      let matchedCustomParameters = null;
      
      // Evaluar cada condici√≥n (l√≥gica OR entre condiciones)
      for (const condition of branchConditions) {
        if (!condition || !condition.rules) {
          continue;
        }
        
        // Todas las reglas en una condici√≥n deben ser verdaderas (l√≥gica AND)
        const allRulesMatch = condition.rules.every(rule => {
          let propValue;
          
          // Parse column name to extract component info for dynamic plugins
          // Format: "componentName_propertyName" or "componentName_questionName" for surveys
          const columnName = rule.column || rule.prop || "";
          const parts = columnName.split("_");
          
          // Check if this looks like a dynamic plugin column (has underscore)
          if (parts.length >= 2) {
            // Last part is the property or question name
            const propertyOrQuestion = parts[parts.length - 1];
            // Everything before the last underscore is the component name
            const componentName = parts.slice(0, -1).join("_");
            
            // Try to find the data in the format: componentName_response
            const responseKey = componentName + '_response';
            const responseData = data[responseKey];
            
            console.log('Branch eval (loop): Checking column', columnName);
            console.log('Branch eval (loop): Component name:', componentName, 'Property:', propertyOrQuestion);
            console.log('Branch eval (loop): Looking for response key:', responseKey);
            console.log('Branch eval (loop): Response data:', responseData);
            
            // If response data exists and is an object (SurveyComponent case)
            if (responseData && typeof responseData === 'object' && !Array.isArray(responseData)) {
              // This is likely a survey response - check if property is a question name
              if (responseData[propertyOrQuestion] !== undefined) {
                propValue = responseData[propertyOrQuestion];
                console.log('Branch eval (loop): Found survey question response', propertyOrQuestion, '=', propValue);
              } else {
                console.log('Branch eval (loop): Survey question not found:', propertyOrQuestion);
                return false;
              }
            } else {
              // Not a survey response object, try direct property access
              const directKey = componentName + '_' + propertyOrQuestion;
              if (data[directKey] !== undefined) {
                propValue = data[directKey];
                console.log('Branch eval (loop): Found direct property', directKey, '=', propValue);
              } else {
                console.log('Branch eval (loop): Property not found:', directKey);
                return false;
              }
            }
          } else {
            // Normal plugin structure - direct property access
            propValue = data[columnName];
            console.log('Branch eval (loop): Direct property access', columnName, '=', propValue);
          }
          
          const compareValue = rule.value;
          console.log('Branch eval (loop): Comparing', propValue, rule.op, compareValue);
          
          // Handle array responses (multi-select or single-select returned as array)
          if (Array.isArray(propValue)) {
            const matches = propValue.includes(compareValue) || propValue.includes(String(compareValue));
            console.log('Branch eval (loop): Array comparison result', matches);
            switch (rule.op) {
              case '==':
                return matches;
              case '!=':
                return !matches;
              default:
                return false;
            }
          }
          
          // Convertir valores para comparaci√≥n
          const numPropValue = parseFloat(propValue);
          const numCompareValue = parseFloat(compareValue);
          const isNumeric = !isNaN(numPropValue) && !isNaN(numCompareValue);
          
          switch (rule.op) {
            case '==':
              return isNumeric ? numPropValue === numCompareValue : propValue == compareValue;
            case '!=':
              return isNumeric ? numPropValue !== numCompareValue : propValue != compareValue;
            case '>':
              return isNumeric && numPropValue > numCompareValue;
            case '<':
              return isNumeric && numPropValue < numCompareValue;
            case '>=':
              return isNumeric && numPropValue >= numCompareValue;
            case '<=':
              return isNumeric && numPropValue <= numCompareValue;
            default:
              return false;
          }
        });
        
        if (allRulesMatch) {
          console.log('‚úÖ [LOOP BRANCH] Condition matched! Next trial:', condition.nextTrialId);
          nextTrialId = condition.nextTrialId;
          // Store custom parameters if they exist
          if (condition.customParameters) {
            matchedCustomParameters = condition.customParameters;
            console.log('‚úÖ [LOOP BRANCH] Custom parameters:', matchedCustomParameters);
          }
          break;
        }
      }
      
      // Si se encontr√≥ match, activar branching
      if (nextTrialId) {
        console.log('üéØ [LOOP BRANCH] Activating branching to trial:', nextTrialId);
        loop_loop_1769327951177_NextTrialId = nextTrialId;
        loop_loop_1769327951177_SkipRemaining = true;
        loop_loop_1769327951177_BranchingActive = true;
        // Store custom parameters for the next trial in the loop
        if (matchedCustomParameters) {
          loop_loop_1769327951177_BranchCustomParameters = matchedCustomParameters;
        }
      } else {
        // No match - ir al primer branch por defecto
        console.log('‚ö†Ô∏è [LOOP BRANCH] No condition matched, branching to first branch:', branches[0]);
        loop_loop_1769327951177_NextTrialId = branches[0];
        loop_loop_1769327951177_SkipRemaining = true;
        loop_loop_1769327951177_BranchingActive = true;
      }
      
    },};



    
    const New_Trial_2_timeline = {
    type: DynamicPlugin, 
      data: {
        rt: "rt_New_Trial_2",
        trial_id: 1769327944691,
        isInLoop: true,
        
      },
    on_start: function(trial) {
      // Then apply custom parameters from branching conditions (higher priority)
      // For trials in loops, use loop-specific BranchCustomParameters
      if (typeof loop_loop_1769327951177_BranchCustomParameters !== 'undefined' && loop_loop_1769327951177_BranchCustomParameters && typeof loop_loop_1769327951177_BranchCustomParameters === 'object') {
        Object.entries(loop_loop_1769327951177_BranchCustomParameters).forEach(([key, param]) => {
          if (param && param.source !== 'none') {
            // Parse key to check if it's a nested survey question
            const parts = key.split('::');
            
            if (parts.length === 4) {
              // Format: fieldType::componentName::survey_json::questionName
              const [fieldType, componentName, propName, questionName] = parts;
              
              if (fieldType && componentName && propName === 'survey_json' && questionName) {
                // Find the component by name in the field array
                const fieldArray = trial[fieldType];
                if (Array.isArray(fieldArray)) {
                  const compIndex = fieldArray.findIndex(c => c.name === componentName);
                  if (compIndex !== -1 && fieldArray[compIndex].survey_json) {
                    // Find the question in survey_json.elements
                    const elements = fieldArray[compIndex].survey_json.elements || [];
                    const questionIndex = elements.findIndex(q => q.name === questionName);
                    
                    if (questionIndex !== -1) {
                      // Apply the override value (from typed or csv)
                      let valueToSet;
                      if (param.source === 'typed') {
                        valueToSet = String(param.value); // Convert to string for SurveyJS
                      } else if (param.source === 'csv') {
                        valueToSet = String(trial[param.value]); // Get from CSV column and convert to string
                      }
                      
                      if (valueToSet !== undefined && valueToSet !== null) {
                        fieldArray[compIndex].survey_json.elements[questionIndex].defaultValue = valueToSet;
                      }
                    }
                  }
                }
              }
            } else if (parts.length === 3) {
              // Format: fieldType::componentName::property (for DynamicPlugin components)
              const [fieldType, componentName, propName] = parts;
              
              if (fieldType && componentName && propName) {
                // Find the component by name in the field array
                const fieldArray = trial[fieldType];
                if (Array.isArray(fieldArray)) {
                  const compIndex = fieldArray.findIndex(c => c.name === componentName);
                  if (compIndex !== -1) {
                    // Apply the override value (from typed or csv)
                    let valueToSet;
                    if (param.source === 'typed') {
                      valueToSet = param.value;
                    } else if (param.source === 'csv') {
                      valueToSet = trial[param.value];
                    }
                    
                    if (valueToSet !== undefined && valueToSet !== null) {
                      fieldArray[compIndex][propName] = valueToSet;
                    }
                  }
                }
              }
            } else {
              // Normal parameter (not nested survey question)
              if (param.source === 'typed' && param.value !== undefined && param.value !== null) {
                trial[key] = param.value;
              } else if (param.source === 'csv' && param.value !== undefined && param.value !== null) {
                trial[key] = trial[param.value];
              }
            }
          }
        });
        // Clear the custom parameters after applying them
        loop_loop_1769327951177_BranchCustomParameters = null;
      }
      
    },
    on_finish: function(data) {
      // Este trial no tiene branches ni repeat conditions, verificar si el loop padre tiene branches
      if (typeof loop_loop_1769327951177_HasBranches !== 'undefined' && loop_loop_1769327951177_HasBranches) {
        // El loop tiene branches, activar branching del loop al terminar
        // Esto se manejar√° en el on_finish del loop
        loop_loop_1769327951177_ShouldBranchOnFinish = true;
      } else if (!loop_loop_1769327951177_HasBranches) {
        // Ni el trial ni el loop tienen branches - trial terminal
        // Si llegamos aqu√≠ despu√©s de un branching global, terminar el experimento
        if (window.branchingActive) {
          jsPsych.abortExperiment('', {});
        }
      }
    },};




    const test_stimuli_loop_1769327960658 = [
  {
    "components_New_Trial_4": [
      {
        "type": "HtmlComponent",
        "coordinates": {
          "x": 0,
          "y": 0
        },
        "width": 200,
        "height": 50,
        "name": "HtmlComponent_1",
        "stimulus": "<div id=\"i0ag\" style=\"box-sizing: border-box;\">toma agua pura</div>"
      }
    ],
    "response_components_New_Trial_4": [
      {
        "type": "ButtonResponseComponent",
        "coordinates": {
          "x": 0,
          "y": 0.3333333333333333
        },
        "width": 200,
        "height": 50,
        "name": "ButtonResponseComponent_1",
        "choices": [
          "nel"
        ]
      }
    ],
    "components_New_Trial_5": [
      {
        "type": "HtmlComponent",
        "coordinates": {
          "x": 0,
          "y": 0
        },
        "width": 200,
        "height": 50,
        "name": "HtmlComponent_1",
        "stimulus": "<div id=\"ihjp\" style=\"box-sizing: border-box;\">pues...</div>"
      }
    ],
    "response_components_New_Trial_5": [
      {
        "type": "ButtonResponseComponent",
        "coordinates": {
          "x": -0.41803278688524603,
          "y": 0.30601092896174853
        },
        "width": 200,
        "height": 50,
        "name": "ButtonResponseComponent_1",
        "choices": [
          "otravez"
        ]
      },
      {
        "type": "ButtonResponseComponent",
        "coordinates": {
          "x": 0.29508196721311486,
          "y": 0.27868852459016374
        },
        "width": 200,
        "height": 50,
        "name": "ButtonResponseComponent_2",
        "choices": [
          "salir"
        ]
      }
    ]
  }
];
    
    
    
    const New_Trial_4_timeline = {
    type: DynamicPlugin, components: jsPsych.timelineVariable("components_New_Trial_4"),
response_components: jsPsych.timelineVariable("response_components_New_Trial_4"),
      data: {
        rt: "rt_New_Trial_4",
        trial_id: 1769327954295,
        isInLoop: true,
        
        branches: [1769327955957],
        branchConditions: [undefined] 
        
      },
    on_start: function(trial) {
      // Then apply custom parameters from branching conditions (higher priority)
      // For trials in loops, use loop-specific BranchCustomParameters
      if (typeof loop_loop_1769327960658_BranchCustomParameters !== 'undefined' && loop_loop_1769327960658_BranchCustomParameters && typeof loop_loop_1769327960658_BranchCustomParameters === 'object') {
        Object.entries(loop_loop_1769327960658_BranchCustomParameters).forEach(([key, param]) => {
          if (param && param.source !== 'none') {
            // Parse key to check if it's a nested survey question
            const parts = key.split('::');
            
            if (parts.length === 4) {
              // Format: fieldType::componentName::survey_json::questionName
              const [fieldType, componentName, propName, questionName] = parts;
              
              if (fieldType && componentName && propName === 'survey_json' && questionName) {
                // Find the component by name in the field array
                const fieldArray = trial[fieldType];
                if (Array.isArray(fieldArray)) {
                  const compIndex = fieldArray.findIndex(c => c.name === componentName);
                  if (compIndex !== -1 && fieldArray[compIndex].survey_json) {
                    // Find the question in survey_json.elements
                    const elements = fieldArray[compIndex].survey_json.elements || [];
                    const questionIndex = elements.findIndex(q => q.name === questionName);
                    
                    if (questionIndex !== -1) {
                      // Apply the override value (from typed or csv)
                      let valueToSet;
                      if (param.source === 'typed') {
                        valueToSet = String(param.value); // Convert to string for SurveyJS
                      } else if (param.source === 'csv') {
                        valueToSet = String(trial[param.value]); // Get from CSV column and convert to string
                      }
                      
                      if (valueToSet !== undefined && valueToSet !== null) {
                        fieldArray[compIndex].survey_json.elements[questionIndex].defaultValue = valueToSet;
                      }
                    }
                  }
                }
              }
            } else if (parts.length === 3) {
              // Format: fieldType::componentName::property (for DynamicPlugin components)
              const [fieldType, componentName, propName] = parts;
              
              if (fieldType && componentName && propName) {
                // Find the component by name in the field array
                const fieldArray = trial[fieldType];
                if (Array.isArray(fieldArray)) {
                  const compIndex = fieldArray.findIndex(c => c.name === componentName);
                  if (compIndex !== -1) {
                    // Apply the override value (from typed or csv)
                    let valueToSet;
                    if (param.source === 'typed') {
                      valueToSet = param.value;
                    } else if (param.source === 'csv') {
                      valueToSet = trial[param.value];
                    }
                    
                    if (valueToSet !== undefined && valueToSet !== null) {
                      fieldArray[compIndex][propName] = valueToSet;
                    }
                  }
                }
              }
            } else {
              // Normal parameter (not nested survey question)
              if (param.source === 'typed' && param.value !== undefined && param.value !== null) {
                trial[key] = param.value;
              } else if (param.source === 'csv' && param.value !== undefined && param.value !== null) {
                trial[key] = trial[param.value];
              }
            }
          }
        });
        // Clear the custom parameters after applying them
        loop_loop_1769327960658_BranchCustomParameters = null;
      }
      
    },
    on_finish: function(data) {
      // Branching autom√°tico al primer branch (dentro del loop)
      const branches = [1769327955957];
      if (branches.length > 0) {
        console.log('üîÑ [LOOP BRANCH] Auto-branching to first branch:', branches[0]);
        loop_loop_1769327960658_NextTrialId = branches[0];
        loop_loop_1769327960658_SkipRemaining = true;
        loop_loop_1769327960658_BranchingActive = true;
      }
      
    },};



    
    const New_Trial_5_timeline = {
    type: DynamicPlugin, components: jsPsych.timelineVariable("components_New_Trial_5"),
response_components: jsPsych.timelineVariable("response_components_New_Trial_5"),
      data: {
        rt: "rt_New_Trial_5",
        trial_id: 1769327955957,
        isInLoop: true,
        
      },
    on_start: function(trial) {
      // Then apply custom parameters from branching conditions (higher priority)
      // For trials in loops, use loop-specific BranchCustomParameters
      if (typeof loop_loop_1769327960658_BranchCustomParameters !== 'undefined' && loop_loop_1769327960658_BranchCustomParameters && typeof loop_loop_1769327960658_BranchCustomParameters === 'object') {
        Object.entries(loop_loop_1769327960658_BranchCustomParameters).forEach(([key, param]) => {
          if (param && param.source !== 'none') {
            // Parse key to check if it's a nested survey question
            const parts = key.split('::');
            
            if (parts.length === 4) {
              // Format: fieldType::componentName::survey_json::questionName
              const [fieldType, componentName, propName, questionName] = parts;
              
              if (fieldType && componentName && propName === 'survey_json' && questionName) {
                // Find the component by name in the field array
                const fieldArray = trial[fieldType];
                if (Array.isArray(fieldArray)) {
                  const compIndex = fieldArray.findIndex(c => c.name === componentName);
                  if (compIndex !== -1 && fieldArray[compIndex].survey_json) {
                    // Find the question in survey_json.elements
                    const elements = fieldArray[compIndex].survey_json.elements || [];
                    const questionIndex = elements.findIndex(q => q.name === questionName);
                    
                    if (questionIndex !== -1) {
                      // Apply the override value (from typed or csv)
                      let valueToSet;
                      if (param.source === 'typed') {
                        valueToSet = String(param.value); // Convert to string for SurveyJS
                      } else if (param.source === 'csv') {
                        valueToSet = String(trial[param.value]); // Get from CSV column and convert to string
                      }
                      
                      if (valueToSet !== undefined && valueToSet !== null) {
                        fieldArray[compIndex].survey_json.elements[questionIndex].defaultValue = valueToSet;
                      }
                    }
                  }
                }
              }
            } else if (parts.length === 3) {
              // Format: fieldType::componentName::property (for DynamicPlugin components)
              const [fieldType, componentName, propName] = parts;
              
              if (fieldType && componentName && propName) {
                // Find the component by name in the field array
                const fieldArray = trial[fieldType];
                if (Array.isArray(fieldArray)) {
                  const compIndex = fieldArray.findIndex(c => c.name === componentName);
                  if (compIndex !== -1) {
                    // Apply the override value (from typed or csv)
                    let valueToSet;
                    if (param.source === 'typed') {
                      valueToSet = param.value;
                    } else if (param.source === 'csv') {
                      valueToSet = trial[param.value];
                    }
                    
                    if (valueToSet !== undefined && valueToSet !== null) {
                      fieldArray[compIndex][propName] = valueToSet;
                    }
                  }
                }
              }
            } else {
              // Normal parameter (not nested survey question)
              if (param.source === 'typed' && param.value !== undefined && param.value !== null) {
                trial[key] = param.value;
              } else if (param.source === 'csv' && param.value !== undefined && param.value !== null) {
                trial[key] = trial[param.value];
              }
            }
          }
        });
        // Clear the custom parameters after applying them
        loop_loop_1769327960658_BranchCustomParameters = null;
      }
      
    },
    on_finish: function(data) {
      // Este trial no tiene branches ni repeat conditions, verificar si el loop padre tiene branches
      if (typeof loop_loop_1769327960658_HasBranches !== 'undefined' && loop_loop_1769327960658_HasBranches) {
        // El loop tiene branches, activar branching del loop al terminar
        // Esto se manejar√° en el on_finish del loop
        loop_loop_1769327960658_ShouldBranchOnFinish = true;
      } else if (!loop_loop_1769327960658_HasBranches) {
        // Ni el trial ni el loop tienen branches - trial terminal
        // Si llegamos aqu√≠ despu√©s de un branching global, terminar el experimento
        if (window.branchingActive) {
          jsPsych.abortExperiment('', {});
        }
      }
    },};


// --- Branching logic variables for loop loop_1769327960658 ---
let loop_loop_1769327960658_NextTrialId = null;
let loop_loop_1769327960658_SkipRemaining = false;
let loop_loop_1769327960658_BranchingActive = false;
let loop_loop_1769327960658_BranchCustomParameters = null; // Store custom parameters for branching within loops
let loop_loop_1769327960658_TargetExecuted = false; // Indica si el trial objetivo ya se ejecut√≥ en esta iteraci√≥n
let loop_loop_1769327960658_IterationComplete = false; // Indica que la iteraci√≥n actual termin√≥
const loop_loop_1769327960658_HasBranches = false;
let loop_loop_1769327960658_ShouldBranchOnFinish = false;


    const New_Trial_4_wrapper = {
      timeline: [New_Trial_4_timeline],
      conditional_function: function() {
        const currentId = New_Trial_4_timeline.data.trial_id;
        
        // Verificar si hay un trial/loop objetivo guardado en localStorage (para repeat/jump global)
        const jumpToTrial = localStorage.getItem('jsPsych_jumpToTrial');
        if (jumpToTrial) {
          if (String(currentId) === String(jumpToTrial)) {
            // Encontramos el trial/loop objetivo para repeat/jump
            console.log('Repeat/jump: Found target trial/loop inside loop', currentId);
            localStorage.removeItem('jsPsych_jumpToTrial');
            return true;
          }
          // No es el objetivo, saltar
          console.log('Repeat/jump: Skipping trial/loop inside loop', currentId);
          return false;
        }
        
        // Si el item objetivo ya fue ejecutado, saltar todos los items restantes en esta iteraci√≥n
        if (loop_loop_1769327960658_TargetExecuted) {
          
          return false;
        }
        
        // Si loopSkipRemaining est√° activo, verificar si este es el item objetivo
        if (loop_loop_1769327960658_SkipRemaining) {
          if (String(currentId) === String(loop_loop_1769327960658_NextTrialId)) {
            // Encontramos el item objetivo dentro del loop
            loop_loop_1769327960658_TargetExecuted = true;
            return true;
          }
          // No es el objetivo, saltar
          return false;
        }
        
        // No hay branching activo, ejecutar normalmente
        return true;
      },
      on_timeline_finish: function() {
        
      }
    };


    const New_Trial_5_wrapper = {
      timeline: [New_Trial_5_timeline],
      conditional_function: function() {
        const currentId = New_Trial_5_timeline.data.trial_id;
        
        // Verificar si hay un trial/loop objetivo guardado en localStorage (para repeat/jump global)
        const jumpToTrial = localStorage.getItem('jsPsych_jumpToTrial');
        if (jumpToTrial) {
          if (String(currentId) === String(jumpToTrial)) {
            // Encontramos el trial/loop objetivo para repeat/jump
            console.log('Repeat/jump: Found target trial/loop inside loop', currentId);
            localStorage.removeItem('jsPsych_jumpToTrial');
            return true;
          }
          // No es el objetivo, saltar
          console.log('Repeat/jump: Skipping trial/loop inside loop', currentId);
          return false;
        }
        
        // Si el item objetivo ya fue ejecutado, saltar todos los items restantes en esta iteraci√≥n
        if (loop_loop_1769327960658_TargetExecuted) {
          
          // √öltimo item: resetear flags para la siguiente iteraci√≥n/repetici√≥n
          loop_loop_1769327960658_NextTrialId = null;
          loop_loop_1769327960658_SkipRemaining = false;
          loop_loop_1769327960658_TargetExecuted = false;
          loop_loop_1769327960658_BranchingActive = false;
          loop_loop_1769327960658_BranchCustomParameters = null;
          loop_loop_1769327960658_IterationComplete = false;
          return false;
        }
        
        // Si loopSkipRemaining est√° activo, verificar si este es el item objetivo
        if (loop_loop_1769327960658_SkipRemaining) {
          if (String(currentId) === String(loop_loop_1769327960658_NextTrialId)) {
            // Encontramos el item objetivo dentro del loop
            loop_loop_1769327960658_TargetExecuted = true;
            return true;
          }
          // No es el objetivo, saltar
          return false;
        }
        
        // No hay branching activo, ejecutar normalmente
        return true;
      },
      on_timeline_finish: function() {
        
        // √öltimo item del timeline: resetear flags para la siguiente iteraci√≥n/repetici√≥n
        loop_loop_1769327960658_NextTrialId = null;
        loop_loop_1769327960658_SkipRemaining = false;
        loop_loop_1769327960658_TargetExecuted = false;
        loop_loop_1769327960658_BranchingActive = false;
        loop_loop_1769327960658_BranchCustomParameters = null;
        loop_loop_1769327960658_IterationComplete = false;
      }
    };

const evaluateLoopCondition_loop_1769327960658 = (trialData, condition) => {
  // All rules in a condition must be true (AND logic)
  return condition.rules.every(rule => {
    const propValue = trialData[rule.prop];
    const compareValue = rule.value;
    
    // Convert values for comparison
    const numPropValue = parseFloat(propValue);
    const numCompareValue = parseFloat(compareValue);
    const isNumeric = !isNaN(numPropValue) && !isNaN(numCompareValue);
    
    switch (rule.op) {
      case '==':
        return isNumeric ? numPropValue === numCompareValue : propValue == compareValue;
      case '!=':
        return isNumeric ? numPropValue !== numCompareValue : propValue != compareValue;
      case '>':
        return isNumeric && numPropValue > numCompareValue;
      case '<':
        return isNumeric && numPropValue < numCompareValue;
      case '>=':
        return isNumeric && numPropValue >= numCompareValue;
      case '<=':
        return isNumeric && numPropValue <= numCompareValue;
      default:
        return false;
    }
  });
};

const getNextLoopTrialId_loop_1769327960658 = (lastTrialData) => {
  if (!lastTrialData || !lastTrialData.trials || !lastTrialData.trials[0]) {
    return null;
  }
  
  const trial = lastTrialData.trials[0];
  
  // Check if trial has branches
  if (!Array.isArray(trial.branches) || trial.branches.length === 0) {
    return null;
  }
  
  // Si solo hay un branch O no hay condiciones, seguir al primer branch autom√°ticamente
  const hasMultipleBranches = trial.branches.length > 1;
  const hasBranchConditions = Array.isArray(trial.branchConditions) && trial.branchConditions.length > 0;
  
  if (!hasMultipleBranches || !hasBranchConditions) {
    console.log('Loop internal: Auto-branching to first branch:', trial.branches[0]);
    return trial.branches[0];
  }
  
  // Si hay m√∫ltiples branches Y condiciones, evaluar las condiciones
  const conditions = trial.branchConditions.flat();
  
  // Evaluate each condition (OR logic between conditions)
  for (const condition of conditions) {
    if (!condition || !condition.rules) {
      console.warn('Invalid condition structure:', condition);
      continue;
    }
    
    if (evaluateLoopCondition_loop_1769327960658(trial, condition)) {
      console.log('Loop internal: Condition matched:', condition);
      return condition.nextTrialId;
    }
  }
  
  // No condition matched - seguir al primer branch por defecto
  console.log('Loop internal: No condition matched, defaulting to first branch:', trial.branches[0]);
  return trial.branches[0];
};

const loop_1769327960658_procedure = {
  timeline: [New_Trial_4_wrapper, New_Trial_5_wrapper],
  timeline_variables: test_stimuli_loop_1769327960658,
  repetitions: 1,
  randomize_order: false,
  loop_function: function(data) {
    // Evaluate loop conditions to determine if the loop should repeat
    const loopConditionsArray = [{"id":1769328079655,"rules":[{"trialId":"1769327955957","column":"","op":"==","value":"otravez","prop":"response","fieldType":"response_components","componentIdx":"ButtonResponseComponent_1"}]}];
    
    // Helper function to get data from a specific trial
    const getTrialData = (trialId) => {
      // Get all trials data
      const allTrials = data.values();
      
      // Find the last occurrence of the trial with matching trial_id
      for (let i = allTrials.length - 1; i >= 0; i--) {
        const trial = allTrials[i];
        if (String(trial.trial_id) === String(trialId)) {
          return trial;
        }
      }
      return null;
    };
    
    // Evaluate a single condition (AND logic between rules)
    const evaluateCondition = (condition) => {
      return condition.rules.every(rule => {
        const trialData = getTrialData(rule.trialId);
        
        if (!trialData) {
          return false;
        }
        
        // Construct column name if empty (for dynamic plugins)
        let columnName = rule.column || "";
        if (!columnName && rule.componentIdx && rule.prop) {
          columnName = rule.componentIdx + '_' + rule.prop;
        }
        
        // Get the property value using the column name
        const propValue = trialData[columnName || rule.prop];
        const compareValue = rule.value;
        
        // Convert values for comparison
        const numPropValue = parseFloat(propValue);
        const numCompareValue = parseFloat(compareValue);
        const isNumeric = !isNaN(numPropValue) && !isNaN(numCompareValue);
        
        let result;
        switch (rule.op) {
          case '==':
            result = isNumeric ? numPropValue === numCompareValue : propValue == compareValue;
            break;
          case '!=':
            result = isNumeric ? numPropValue !== numCompareValue : propValue != compareValue;
            break;
          case '>':
            result = isNumeric && numPropValue > numCompareValue;
            break;
          case '<':
            result = isNumeric && numPropValue < numCompareValue;
            break;
          case '>=':
            result = isNumeric && numPropValue >= numCompareValue;
            break;
          case '<=':
            result = isNumeric && numPropValue <= numCompareValue;
            break;
          default:
            result = false;
        }
        
        return result;
      });
    };
    
    // Evaluate all conditions (OR logic between conditions)
    const shouldRepeat = loopConditionsArray.some(condition => evaluateCondition(condition));
    
    return shouldRepeat;
  },
  conditional_function: function() {
    const currentId = "loop_1769327960658";
    
    // Verificar si hay un trial objetivo guardado en localStorage (para repeat/jump)
    const jumpToTrial = localStorage.getItem('jsPsych_jumpToTrial');
    if (jumpToTrial) {
      if (String(currentId) === String(jumpToTrial)) {
        // Encontramos el loop objetivo para repeat/jump
        console.log('Repeat/jump: Found target loop', currentId);
        localStorage.removeItem('jsPsych_jumpToTrial');
        return true;
      }
      // No es el objetivo, saltar
      console.log('Repeat/jump: Skipping loop', currentId);
      return false;
    }
    
    // Si skipRemaining est√° activo (branching normal), verificar si este es el loop objetivo
    if (window.skipRemaining) {
      if (String(currentId) === String(window.nextTrialId)) {
        // Encontramos el loop objetivo
        window.skipRemaining = false;
        window.nextTrialId = null;
        return true;
      }
      // No es el objetivo, saltar
      return false;
    }
    
    return true;
  },
  on_timeline_start: function() {
    // Resetear las flags al inicio de cada iteraci√≥n del loop
    // Esto permite que cada repetici√≥n del loop funcione correctamente
    loop_loop_1769327960658_NextTrialId = null;
    loop_loop_1769327960658_SkipRemaining = false;
    loop_loop_1769327960658_BranchingActive = false;
    loop_loop_1769327960658_BranchCustomParameters = null;
    loop_loop_1769327960658_TargetExecuted = false;
    loop_loop_1769327960658_IterationComplete = false;
    loop_loop_1769327960658_ShouldBranchOnFinish = false;
    
    // IMPORTANTE: Si el loop es condicional, resetear tambi√©n el branching GLOBAL
    // para que se regenere durante esta iteraci√≥n del loop
    
    window.nextTrialId = null;
    window.skipRemaining = false;
    window.branchingActive = false;
    window.branchCustomParameters = null;
    console.log('Conditional loop iteration starting, reset global branching flags');
    
  },
  on_timeline_finish: function() {
    // Resetear las flags al finalizar todas las repeticiones del loop
    loop_loop_1769327960658_NextTrialId = null;
    loop_loop_1769327960658_SkipRemaining = false;
    loop_loop_1769327960658_TargetExecuted = false;
    loop_loop_1769327960658_BranchingActive = false;
    loop_loop_1769327960658_BranchCustomParameters = null;
    
    // Verificar si se debe hacer branching porque un trial sin branches se complet√≥
    // pero el loop tiene branches
    if (loop_loop_1769327960658_ShouldBranchOnFinish && loop_loop_1769327960658_HasBranches) {
      const branches = [];
      if (branches.length > 0) {
        
        // Este es un loop ra√≠z - activar branching global
        window.nextTrialId = branches[0];
        window.skipRemaining = true;
        window.branchingActive = true;
        console.log('Root loop finished (from internal trial), branching to:', branches[0]);
      }
    }
    
    // Resetear todas las variables de branching del loop
    loop_loop_1769327960658_NextTrialId = null;
    loop_loop_1769327960658_SkipRemaining = false;
    loop_loop_1769327960658_BranchingActive = false;
    loop_loop_1769327960658_BranchCustomParameters = null;
    loop_loop_1769327960658_ShouldBranchOnFinish = false;
  },

  data: {
    loop_id: "loop_1769327960658"
  },
  on_finish: function(data) {
    // Este loop no tiene branches ni repeat conditions, es un loop terminal
    // Si llegamos aqu√≠ despu√©s de un branching, terminar el experimento
    if (window.branchingActive) {
      jsPsych.abortExperiment('', {});
    }
  },
};
timeline.push(loop_1769327960658_procedure);


// --- Branching logic variables for loop loop_1769327951177 ---
let loop_loop_1769327951177_NextTrialId = null;
let loop_loop_1769327951177_SkipRemaining = false;
let loop_loop_1769327951177_BranchingActive = false;
let loop_loop_1769327951177_BranchCustomParameters = null; // Store custom parameters for branching within loops
let loop_loop_1769327951177_TargetExecuted = false; // Indica si el trial objetivo ya se ejecut√≥ en esta iteraci√≥n
let loop_loop_1769327951177_IterationComplete = false; // Indica que la iteraci√≥n actual termin√≥
const loop_loop_1769327951177_HasBranches = false;
let loop_loop_1769327951177_ShouldBranchOnFinish = false;


    const New_Trial_3_wrapper = {
      timeline: [New_Trial_3_timeline],
      conditional_function: function() {
        const currentId = New_Trial_3_timeline.data.trial_id;
        
        // Verificar si hay un trial/loop objetivo guardado en localStorage (para repeat/jump global)
        const jumpToTrial = localStorage.getItem('jsPsych_jumpToTrial');
        if (jumpToTrial) {
          if (String(currentId) === String(jumpToTrial)) {
            // Encontramos el trial/loop objetivo para repeat/jump
            console.log('Repeat/jump: Found target trial/loop inside loop', currentId);
            localStorage.removeItem('jsPsych_jumpToTrial');
            return true;
          }
          // No es el objetivo, saltar
          console.log('Repeat/jump: Skipping trial/loop inside loop', currentId);
          return false;
        }
        
        // Si el item objetivo ya fue ejecutado, saltar todos los items restantes en esta iteraci√≥n
        if (loop_loop_1769327951177_TargetExecuted) {
          
          return false;
        }
        
        // Si loopSkipRemaining est√° activo, verificar si este es el item objetivo
        if (loop_loop_1769327951177_SkipRemaining) {
          if (String(currentId) === String(loop_loop_1769327951177_NextTrialId)) {
            // Encontramos el item objetivo dentro del loop
            loop_loop_1769327951177_TargetExecuted = true;
            return true;
          }
          // No es el objetivo, saltar
          return false;
        }
        
        // No hay branching activo, ejecutar normalmente
        return true;
      },
      on_timeline_finish: function() {
        
      }
    };


    const New_Trial_2_wrapper = {
      timeline: [New_Trial_2_timeline],
      conditional_function: function() {
        const currentId = New_Trial_2_timeline.data.trial_id;
        
        // Verificar si hay un trial/loop objetivo guardado en localStorage (para repeat/jump global)
        const jumpToTrial = localStorage.getItem('jsPsych_jumpToTrial');
        if (jumpToTrial) {
          if (String(currentId) === String(jumpToTrial)) {
            // Encontramos el trial/loop objetivo para repeat/jump
            console.log('Repeat/jump: Found target trial/loop inside loop', currentId);
            localStorage.removeItem('jsPsych_jumpToTrial');
            return true;
          }
          // No es el objetivo, saltar
          console.log('Repeat/jump: Skipping trial/loop inside loop', currentId);
          return false;
        }
        
        // Si el item objetivo ya fue ejecutado, saltar todos los items restantes en esta iteraci√≥n
        if (loop_loop_1769327951177_TargetExecuted) {
          
          return false;
        }
        
        // Si loopSkipRemaining est√° activo, verificar si este es el item objetivo
        if (loop_loop_1769327951177_SkipRemaining) {
          if (String(currentId) === String(loop_loop_1769327951177_NextTrialId)) {
            // Encontramos el item objetivo dentro del loop
            loop_loop_1769327951177_TargetExecuted = true;
            return true;
          }
          // No es el objetivo, saltar
          return false;
        }
        
        // No hay branching activo, ejecutar normalmente
        return true;
      },
      on_timeline_finish: function() {
        
      }
    };


    const Nested_Loop_1_wrapper = {
      timeline: [loop_1769327960658_procedure],
      conditional_function: function() {
        const currentId = "loop_1769327960658";
        
        // Verificar si hay un trial/loop objetivo guardado en localStorage (para repeat/jump global)
        const jumpToTrial = localStorage.getItem('jsPsych_jumpToTrial');
        if (jumpToTrial) {
          if (String(currentId) === String(jumpToTrial)) {
            // Encontramos el trial/loop objetivo para repeat/jump
            console.log('Repeat/jump: Found target trial/loop inside loop', currentId);
            localStorage.removeItem('jsPsych_jumpToTrial');
            return true;
          }
          // No es el objetivo, saltar
          console.log('Repeat/jump: Skipping trial/loop inside loop', currentId);
          return false;
        }
        
        // Si el item objetivo ya fue ejecutado, saltar todos los items restantes en esta iteraci√≥n
        if (loop_loop_1769327951177_TargetExecuted) {
          
          // √öltimo item: resetear flags para la siguiente iteraci√≥n/repetici√≥n
          loop_loop_1769327951177_NextTrialId = null;
          loop_loop_1769327951177_SkipRemaining = false;
          loop_loop_1769327951177_TargetExecuted = false;
          loop_loop_1769327951177_BranchingActive = false;
          loop_loop_1769327951177_BranchCustomParameters = null;
          loop_loop_1769327951177_IterationComplete = false;
          return false;
        }
        
        // Si loopSkipRemaining est√° activo, verificar si este es el item objetivo
        if (loop_loop_1769327951177_SkipRemaining) {
          if (String(currentId) === String(loop_loop_1769327951177_NextTrialId)) {
            // Encontramos el item objetivo dentro del loop
            loop_loop_1769327951177_TargetExecuted = true;
            return true;
          }
          // No es el objetivo, saltar
          return false;
        }
        
        // No hay branching activo, ejecutar normalmente
        return true;
      },
      on_timeline_finish: function() {
        
        // √öltimo item del timeline: resetear flags para la siguiente iteraci√≥n/repetici√≥n
        loop_loop_1769327951177_NextTrialId = null;
        loop_loop_1769327951177_SkipRemaining = false;
        loop_loop_1769327951177_TargetExecuted = false;
        loop_loop_1769327951177_BranchingActive = false;
        loop_loop_1769327951177_BranchCustomParameters = null;
        loop_loop_1769327951177_IterationComplete = false;
      }
    };

const evaluateLoopCondition_loop_1769327951177 = (trialData, condition) => {
  // All rules in a condition must be true (AND logic)
  return condition.rules.every(rule => {
    const propValue = trialData[rule.prop];
    const compareValue = rule.value;
    
    // Convert values for comparison
    const numPropValue = parseFloat(propValue);
    const numCompareValue = parseFloat(compareValue);
    const isNumeric = !isNaN(numPropValue) && !isNaN(numCompareValue);
    
    switch (rule.op) {
      case '==':
        return isNumeric ? numPropValue === numCompareValue : propValue == compareValue;
      case '!=':
        return isNumeric ? numPropValue !== numCompareValue : propValue != compareValue;
      case '>':
        return isNumeric && numPropValue > numCompareValue;
      case '<':
        return isNumeric && numPropValue < numCompareValue;
      case '>=':
        return isNumeric && numPropValue >= numCompareValue;
      case '<=':
        return isNumeric && numPropValue <= numCompareValue;
      default:
        return false;
    }
  });
};

const getNextLoopTrialId_loop_1769327951177 = (lastTrialData) => {
  if (!lastTrialData || !lastTrialData.trials || !lastTrialData.trials[0]) {
    return null;
  }
  
  const trial = lastTrialData.trials[0];
  
  // Check if trial has branches
  if (!Array.isArray(trial.branches) || trial.branches.length === 0) {
    return null;
  }
  
  // Si solo hay un branch O no hay condiciones, seguir al primer branch autom√°ticamente
  const hasMultipleBranches = trial.branches.length > 1;
  const hasBranchConditions = Array.isArray(trial.branchConditions) && trial.branchConditions.length > 0;
  
  if (!hasMultipleBranches || !hasBranchConditions) {
    console.log('Loop internal: Auto-branching to first branch:', trial.branches[0]);
    return trial.branches[0];
  }
  
  // Si hay m√∫ltiples branches Y condiciones, evaluar las condiciones
  const conditions = trial.branchConditions.flat();
  
  // Evaluate each condition (OR logic between conditions)
  for (const condition of conditions) {
    if (!condition || !condition.rules) {
      console.warn('Invalid condition structure:', condition);
      continue;
    }
    
    if (evaluateLoopCondition_loop_1769327951177(trial, condition)) {
      console.log('Loop internal: Condition matched:', condition);
      return condition.nextTrialId;
    }
  }
  
  // No condition matched - seguir al primer branch por defecto
  console.log('Loop internal: No condition matched, defaulting to first branch:', trial.branches[0]);
  return trial.branches[0];
};

const loop_1769327951177_procedure = {
  timeline: [New_Trial_3_wrapper, New_Trial_2_wrapper, Nested_Loop_1_wrapper],
  timeline_variables: test_stimuli_loop_1769327951177,
  repetitions: 1,
  randomize_order: false,
  
  conditional_function: function() {
    const currentId = "loop_1769327951177";
    
    // Verificar si hay un trial objetivo guardado en localStorage (para repeat/jump)
    const jumpToTrial = localStorage.getItem('jsPsych_jumpToTrial');
    if (jumpToTrial) {
      if (String(currentId) === String(jumpToTrial)) {
        // Encontramos el loop objetivo para repeat/jump
        console.log('Repeat/jump: Found target loop', currentId);
        localStorage.removeItem('jsPsych_jumpToTrial');
        return true;
      }
      // No es el objetivo, saltar
      console.log('Repeat/jump: Skipping loop', currentId);
      return false;
    }
    
    // Si skipRemaining est√° activo (branching normal), verificar si este es el loop objetivo
    if (window.skipRemaining) {
      if (String(currentId) === String(window.nextTrialId)) {
        // Encontramos el loop objetivo
        window.skipRemaining = false;
        window.nextTrialId = null;
        return true;
      }
      // No es el objetivo, saltar
      return false;
    }
    
    return true;
  },
  on_timeline_start: function() {
    // Resetear las flags al inicio de cada iteraci√≥n del loop
    // Esto permite que cada repetici√≥n del loop funcione correctamente
    loop_loop_1769327951177_NextTrialId = null;
    loop_loop_1769327951177_SkipRemaining = false;
    loop_loop_1769327951177_BranchingActive = false;
    loop_loop_1769327951177_BranchCustomParameters = null;
    loop_loop_1769327951177_TargetExecuted = false;
    loop_loop_1769327951177_IterationComplete = false;
    loop_loop_1769327951177_ShouldBranchOnFinish = false;
    
    // IMPORTANTE: Si el loop es condicional, resetear tambi√©n el branching GLOBAL
    // para que se regenere durante esta iteraci√≥n del loop
    
  },
  on_timeline_finish: function() {
    // Resetear las flags al finalizar todas las repeticiones del loop
    loop_loop_1769327951177_NextTrialId = null;
    loop_loop_1769327951177_SkipRemaining = false;
    loop_loop_1769327951177_TargetExecuted = false;
    loop_loop_1769327951177_BranchingActive = false;
    loop_loop_1769327951177_BranchCustomParameters = null;
    
    // Verificar si se debe hacer branching porque un trial sin branches se complet√≥
    // pero el loop tiene branches
    if (loop_loop_1769327951177_ShouldBranchOnFinish && loop_loop_1769327951177_HasBranches) {
      const branches = [];
      if (branches.length > 0) {
        
        // Este es un loop ra√≠z - activar branching global
        window.nextTrialId = branches[0];
        window.skipRemaining = true;
        window.branchingActive = true;
        console.log('Root loop finished (from internal trial), branching to:', branches[0]);
      }
    }
    
    // Resetear todas las variables de branching del loop
    loop_loop_1769327951177_NextTrialId = null;
    loop_loop_1769327951177_SkipRemaining = false;
    loop_loop_1769327951177_BranchingActive = false;
    loop_loop_1769327951177_BranchCustomParameters = null;
    loop_loop_1769327951177_ShouldBranchOnFinish = false;
  },

  data: {
    loop_id: "loop_1769327951177"
  },
  on_finish: function(data) {
    // Este loop no tiene branches ni repeat conditions, es un loop terminal
    // Si llegamos aqu√≠ despu√©s de un branching, terminar el experimento
    if (window.branchingActive) {
      jsPsych.abortExperiment('', {});
    }
  },
};
timeline.push(loop_1769327951177_procedure);


jsPsych.run(timeline);

})();

</script></body></html>