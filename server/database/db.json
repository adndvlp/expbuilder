{
  "experiments": [
    {
      "experimentID": "35c481f1-13f2-43a6-9aee-54e1e0bc2e42",
      "name": "wrc",
      "createdAt": "2026-01-22T03:57:17.728Z",
      "updatedAt": "2026-01-22T03:57:17.728Z"
    },
    {
      "experimentID": "e852734d-02be-4a66-b9c7-56c078e94d9b",
      "name": "lkjf",
      "createdAt": "2026-01-25T06:06:05.194Z",
      "updatedAt": "2026-01-25T06:06:05.194Z"
    }
  ],
  "trials": [
    {
      "experimentID": "35c481f1-13f2-43a6-9aee-54e1e0bc2e42",
      "trials": [
        {
          "type": "Trial",
          "name": "Loopsiono",
          "plugin": "plugin-dynamic",
          "parameters": {
            "includesExtensions": false,
            "extensionType": ""
          },
          "trialCode": "",
          "id": 1769054412868,
          "createdAt": "2026-01-22T04:00:12.868Z",
          "updatedAt": "2026-01-23T01:59:36.872Z",
          "branches": [
            1769054414149,
            "loop_1769054420851"
          ],
          "columnMapping": {
            "components": {
              "source": "typed",
              "value": [
                {
                  "type": "HtmlComponent",
                  "coordinates": {
                    "x": 0,
                    "y": 0
                  },
                  "width": 200,
                  "height": 50,
                  "name": {
                    "source": "typed",
                    "value": "HtmlComponent_1"
                  },
                  "stimulus": {
                    "source": "typed",
                    "value": "<div id=\"ip0u\" style=\"box-sizing: border-box;\">loop?</div>"
                  }
                },
                {
                  "type": "ImageComponent",
                  "coordinates": {
                    "x": -0.6501604646475405,
                    "y": -0.5168634492003834
                  },
                  "width": 268.8730468382805,
                  "height": 268.8730468382805,
                  "name": {
                    "source": "typed",
                    "value": "ImageComponent_1"
                  },
                  "stimulus": {
                    "source": "csv",
                    "value": "images"
                  }
                }
              ]
            },
            "response_components": {
              "source": "typed",
              "value": [
                {
                  "type": "ButtonResponseComponent",
                  "coordinates": {
                    "x": -0.016393442622950838,
                    "y": 0.4207650273224042
                  },
                  "width": 200,
                  "height": 50,
                  "name": {
                    "source": "typed",
                    "value": "ButtonResponseComponent_1"
                  },
                  "choices": {
                    "source": "typed",
                    "value": [
                      "si",
                      "no",
                      "nose"
                    ]
                  }
                }
              ]
            },
            "stimulus": {
              "source": "typed",
              "value": ""
            },
            "choices": {
              "source": "typed",
              "value": [
                "j"
              ]
            }
          },
          "branchConditions": [
            {
              "id": 1769125088942,
              "rules": [
                {
                  "column": "",
                  "op": "==",
                  "value": "nose",
                  "fieldType": "response_components",
                  "componentIdx": "ButtonResponseComponent_1",
                  "prop": "response"
                }
              ],
              "nextTrialId": "1769054414149",
              "customParameters": {}
            },
            {
              "id": 1769125796392,
              "rules": [
                {
                  "column": "",
                  "op": "==",
                  "value": "si",
                  "fieldType": "response_components",
                  "componentIdx": "ButtonResponseComponent_1",
                  "prop": "response"
                }
              ],
              "nextTrialId": "loop_1769054420851",
              "customParameters": {}
            }
          ],
          "repeatConditions": [],
          "csvJson": [
            {
              "images": "armadillo.png",
              "witdh": "100",
              "categories": "1",
              "order1": "1",
              "order2": "cofre.png",
              "button": "loca"
            },
            {
              "images": "bmw.png",
              "witdh": "12",
              "categories": "1",
              "order1": "2",
              "order2": "cube.png",
              "button": "cola"
            },
            {
              "images": "boat.png",
              "witdh": "100",
              "categories": "1",
              "order1": "3",
              "order2": "dis.png",
              "button": "loca"
            },
            {
              "images": "boat2.png",
              "witdh": "12",
              "categories": "1",
              "order1": "4",
              "order2": "floor.png",
              "button": "lwrknv"
            },
            {
              "images": "cofre.png",
              "witdh": "100",
              "categories": "2",
              "order1": "5",
              "order2": "green.png",
              "button": "rv"
            },
            {
              "images": "cube.png",
              "witdh": "12",
              "categories": "2",
              "order1": "6",
              "order2": "obstacle.png",
              "button": "e"
            },
            {
              "images": "dis.png",
              "witdh": "100",
              "categories": "2",
              "order1": "7",
              "button": "rv"
            },
            {
              "images": "floor.png",
              "witdh": "12",
              "categories": "3",
              "order1": "8",
              "button": "er"
            },
            {
              "images": "green.png",
              "witdh": "100",
              "categories": "3",
              "order1": "9",
              "button": "rere"
            },
            {
              "images": "obstacle.png",
              "witdh": "12",
              "categories": "3",
              "order1": "10",
              "button": "er"
            }
          ],
          "csvColumns": [
            "images",
            "witdh",
            "categories",
            "order1",
            "order2",
            "button"
          ],
          "orders": true,
          "orderColumns": [
            "order1"
          ],
          "stimuliOrders": [
            [
              0,
              1,
              2,
              3,
              4,
              5,
              6,
              7,
              8,
              9
            ]
          ],
          "categories": true,
          "categoryColumn": "categories",
          "categoryData": [
            "1",
            "1",
            "1",
            "1",
            "2",
            "2",
            "2",
            "3",
            "3",
            "3"
          ],
          "parentLoopId": null,
          "paramsOverride": [
            {
              "id": 1769122722267,
              "rules": [
                {
                  "trialId": "",
                  "column": "",
                  "op": "==",
                  "value": "",
                  "prop": ""
                }
              ],
              "paramsToOverride": {}
            }
          ]
        },
        {
          "type": "Trial",
          "name": "no",
          "plugin": "plugin-dynamic",
          "parameters": {
            "includesExtensions": false,
            "extensionType": ""
          },
          "trialCode": "",
          "id": 1769054414149,
          "createdAt": "2026-01-22T04:00:14.149Z",
          "updatedAt": "2026-01-23T02:05:35.726Z",
          "columnMapping": {
            "components": {
              "source": "typed",
              "value": [
                {
                  "type": "HtmlComponent",
                  "coordinates": {
                    "x": 0,
                    "y": 0
                  },
                  "width": 200,
                  "height": 50,
                  "name": {
                    "source": "typed",
                    "value": "HtmlComponent_1"
                  },
                  "stimulus": {
                    "source": "typed",
                    "value": "<div id=\"i29z\" style=\"box-sizing: border-box;\">pues no</div>"
                  }
                },
                {
                  "type": "ImageComponent",
                  "coordinates": {
                    "x": -0.6311476571080591,
                    "y": -0.5598223340195362
                  },
                  "width": 223.9685353850833,
                  "height": 223.96853538508336,
                  "name": {
                    "source": "typed",
                    "value": "ImageComponent_1"
                  },
                  "stimulus": {
                    "source": "csv",
                    "value": "images"
                  }
                }
              ]
            },
            "response_components": {
              "source": "typed",
              "value": [
                {
                  "type": "ButtonResponseComponent",
                  "coordinates": {
                    "x": 0.0027472527472527375,
                    "y": 0.304029304029304
                  },
                  "width": 200,
                  "height": 50,
                  "name": {
                    "source": "typed",
                    "value": "ButtonResponseComponent_1"
                  },
                  "choices": {
                    "source": "typed",
                    "value": [
                      "ok"
                    ]
                  }
                }
              ]
            }
          },
          "csvJson": [
            {
              "images": "armadillo.png",
              "witdh": "100",
              "categories": "1",
              "order1": "1",
              "order2": "cofre.png",
              "button": "loca"
            },
            {
              "images": "bmw.png",
              "witdh": "12",
              "categories": "1",
              "order1": "2",
              "order2": "cube.png",
              "button": "cola"
            },
            {
              "images": "boat.png",
              "witdh": "100",
              "categories": "1",
              "order1": "3",
              "order2": "dis.png",
              "button": "loca"
            },
            {
              "images": "boat2.png",
              "witdh": "12",
              "categories": "1",
              "order1": "4",
              "order2": "floor.png",
              "button": "lwrknv"
            },
            {
              "images": "cofre.png",
              "witdh": "100",
              "categories": "2",
              "order1": "5",
              "order2": "green.png",
              "button": "rv"
            },
            {
              "images": "cube.png",
              "witdh": "12",
              "categories": "2",
              "order1": "6",
              "order2": "obstacle.png",
              "button": "e"
            },
            {
              "images": "dis.png",
              "witdh": "100",
              "categories": "2",
              "order1": "7",
              "button": "rv"
            },
            {
              "images": "floor.png",
              "witdh": "12",
              "categories": "3",
              "order1": "8",
              "button": "er"
            },
            {
              "images": "green.png",
              "witdh": "100",
              "categories": "3",
              "order1": "9",
              "button": "rere"
            },
            {
              "images": "obstacle.png",
              "witdh": "12",
              "categories": "3",
              "order1": "10",
              "button": "er"
            }
          ],
          "csvColumns": [
            "images",
            "witdh",
            "categories",
            "order1",
            "order2",
            "button"
          ],
          "orders": true,
          "orderColumns": [
            "order1"
          ],
          "stimuliOrders": [
            [
              0,
              1,
              2,
              3,
              4,
              5,
              6,
              7,
              8,
              9
            ]
          ],
          "categories": true,
          "categoryColumn": "categories",
          "categoryData": [
            "1",
            "1",
            "1",
            "1",
            "2",
            "2",
            "2",
            "3",
            "3",
            "3"
          ],
          "parentLoopId": null,
          "branches": [
            1769133935682
          ],
          "branchConditions": [],
          "repeatConditions": [],
          "paramsOverride": []
        },
        {
          "type": "Trial",
          "name": "New Trialb 2",
          "plugin": "plugin-dynamic",
          "parameters": {
            "includesExtensions": false,
            "extensionType": ""
          },
          "trialCode": "",
          "id": 1769054415115,
          "createdAt": "2026-01-22T04:00:15.115Z",
          "updatedAt": "2026-01-22T22:40:18.999Z",
          "branches": [
            1769054417382,
            "loop_1769054430260"
          ],
          "parentLoopId": "loop_1769054420851",
          "columnMapping": {
            "components": {
              "source": "typed",
              "value": [
                {
                  "type": "HtmlComponent",
                  "coordinates": {
                    "x": 0,
                    "y": 0
                  },
                  "width": 200,
                  "height": 50,
                  "name": {
                    "source": "typed",
                    "value": "HtmlComponent_1"
                  },
                  "stimulus": {
                    "source": "typed",
                    "value": "<div id=\"ikgb\" style=\"box-sizing: border-box;\">loco?</div>"
                  }
                }
              ]
            },
            "response_components": {
              "source": "typed",
              "value": [
                {
                  "type": "ButtonResponseComponent",
                  "coordinates": {
                    "x": -0.004098360655737765,
                    "y": 0.30601092896174853
                  },
                  "width": 200,
                  "height": 50,
                  "name": {
                    "source": "typed",
                    "value": "ButtonResponseComponent_1"
                  },
                  "choices": {
                    "source": "typed",
                    "value": [
                      "si",
                      "no"
                    ]
                  }
                }
              ]
            }
          },
          "branchConditions": [
            {
              "id": 1769054609999,
              "rules": [
                {
                  "column": "ButtonResponseComponent_1_response",
                  "op": "==",
                  "value": "no",
                  "fieldType": "response_components",
                  "componentIdx": "ButtonResponseComponent_1",
                  "prop": "response"
                }
              ],
              "nextTrialId": "1769054417382",
              "customParameters": {}
            },
            {
              "id": 1769054624031,
              "rules": [
                {
                  "column": "ButtonResponseComponent_1_response",
                  "op": "==",
                  "value": "si",
                  "fieldType": "response_components",
                  "componentIdx": "ButtonResponseComponent_1",
                  "prop": "response"
                }
              ],
              "nextTrialId": "loop_1769054430260",
              "customParameters": {}
            }
          ],
          "repeatConditions": [],
          "csvJson": [],
          "csvColumns": [],
          "orders": false,
          "orderColumns": [],
          "stimuliOrders": [],
          "categories": false,
          "categoryColumn": "",
          "categoryData": []
        },
        {
          "type": "Trial",
          "name": "New Trial 3",
          "plugin": "plugin-dynamic",
          "parameters": {
            "includesExtensions": false,
            "extensionType": ""
          },
          "trialCode": "",
          "id": 1769054417382,
          "createdAt": "2026-01-22T04:00:17.382Z",
          "updatedAt": "2026-01-22T23:59:48.741Z",
          "parentLoopId": "loop_1769054420851",
          "columnMapping": {
            "components": {
              "source": "typed",
              "value": [
                {
                  "type": "HtmlComponent",
                  "coordinates": {
                    "x": 0,
                    "y": 0
                  },
                  "width": 200,
                  "height": 50,
                  "name": {
                    "source": "typed",
                    "value": "HtmlComponent_1"
                  },
                  "stimulus": {
                    "source": "typed",
                    "value": "<div id=\"isj4\" style=\"box-sizing: border-box;\">pues no dentro de loop</div>"
                  }
                }
              ]
            },
            "response_components": {
              "source": "typed",
              "value": [
                {
                  "type": "ButtonResponseComponent",
                  "coordinates": {
                    "x": -0.004098360655737765,
                    "y": 0.26229508196721313
                  },
                  "width": 200,
                  "height": 50,
                  "name": {
                    "source": "typed",
                    "value": "ButtonResponseComponent_1"
                  },
                  "choices": {
                    "source": "typed",
                    "value": [
                      "ok"
                    ]
                  }
                }
              ]
            }
          },
          "csvJson": [],
          "csvColumns": [],
          "orders": false,
          "orderColumns": [],
          "stimuliOrders": [],
          "categories": false,
          "categoryColumn": "",
          "categoryData": [],
          "branches": [],
          "paramsOverride": [],
          "branchConditions": [],
          "repeatConditions": []
        },
        {
          "type": "Trial",
          "name": "New Trial 2",
          "plugin": "plugin-dynamic",
          "parameters": {
            "includesExtensions": false,
            "extensionType": ""
          },
          "trialCode": "",
          "id": 1769054422939,
          "createdAt": "2026-01-22T04:00:22.939Z",
          "updatedAt": "2026-01-22T23:09:02.690Z",
          "columnMapping": {
            "components": {
              "source": "typed",
              "value": [
                {
                  "type": "HtmlComponent",
                  "coordinates": {
                    "x": 0,
                    "y": 0
                  },
                  "width": 200,
                  "height": 50,
                  "name": {
                    "source": "typed",
                    "value": "HtmlComponent_1"
                  },
                  "stimulus": {
                    "source": "typed",
                    "value": "<div id=\"ifgp\" style=\"box-sizing: border-box;\">termina loop</div>"
                  }
                }
              ]
            }
          },
          "csvJson": [],
          "csvColumns": [],
          "orders": false,
          "orderColumns": [],
          "stimuliOrders": [],
          "categories": false,
          "categoryColumn": "",
          "categoryData": [],
          "parentLoopId": null,
          "branches": [],
          "paramsOverride": [
            {
              "id": 1769123342181,
              "rules": [
                {
                  "trialId": "",
                  "column": "",
                  "op": "==",
                  "value": "",
                  "prop": ""
                }
              ],
              "paramsToOverride": {}
            }
          ]
        },
        {
          "type": "Trial",
          "name": "New Tridalb 4",
          "plugin": "plugin-dynamic",
          "parameters": {
            "includesExtensions": false,
            "extensionType": ""
          },
          "trialCode": "",
          "parentLoopId": "loop_1769054430260",
          "id": 1769054425182,
          "createdAt": "2026-01-22T04:00:25.182Z",
          "updatedAt": "2026-01-22T23:08:41.069Z",
          "branches": [
            1769054426032,
            1769110039675
          ],
          "columnMapping": {
            "components": {
              "source": "typed",
              "value": [
                {
                  "type": "HtmlComponent",
                  "coordinates": {
                    "x": 0,
                    "y": 0
                  },
                  "width": 200,
                  "height": 50,
                  "name": {
                    "source": "typed",
                    "value": "HtmlComponent_1"
                  },
                  "stimulus": {
                    "source": "typed",
                    "value": "<div id=\"ik2w\" style=\"box-sizing: border-box;\">seguro nested loop?</div>"
                  }
                }
              ]
            },
            "response_components": {
              "source": "typed",
              "value": [
                {
                  "type": "ButtonResponseComponent",
                  "coordinates": {
                    "x": -0.004098360655737765,
                    "y": 0.273224043715847
                  },
                  "width": 200,
                  "height": 50,
                  "name": {
                    "source": "typed",
                    "value": "ButtonResponseComponent_1"
                  },
                  "choices": {
                    "source": "typed",
                    "value": [
                      "si",
                      "no"
                    ]
                  }
                }
              ]
            }
          },
          "branchConditions": [
            {
              "id": 1769054911466,
              "rules": [
                {
                  "column": "ButtonResponseComponent_1_response",
                  "op": "==",
                  "value": "si",
                  "fieldType": "response_components",
                  "componentIdx": "ButtonResponseComponent_1",
                  "prop": "response"
                }
              ],
              "nextTrialId": "1769110039675",
              "customParameters": {}
            },
            {
              "id": 1769054925882,
              "rules": [
                {
                  "column": "ButtonResponseComponent_1_response",
                  "op": "==",
                  "value": "no",
                  "fieldType": "response_components",
                  "componentIdx": "ButtonResponseComponent_1",
                  "prop": "response"
                }
              ],
              "nextTrialId": "1769054426032",
              "customParameters": {}
            }
          ],
          "repeatConditions": [],
          "csvJson": [],
          "csvColumns": [],
          "orders": false,
          "orderColumns": [],
          "stimuliOrders": [],
          "categories": false,
          "categoryColumn": "",
          "categoryData": []
        },
        {
          "type": "Trial",
          "name": "New Trial 5",
          "plugin": "plugin-dynamic",
          "parameters": {
            "includesExtensions": false,
            "extensionType": ""
          },
          "trialCode": "",
          "parentLoopId": "loop_1769054430260",
          "id": 1769054426032,
          "createdAt": "2026-01-22T04:00:26.032Z",
          "updatedAt": "2026-01-23T00:34:08.676Z",
          "columnMapping": {
            "components": {
              "source": "typed",
              "value": [
                {
                  "type": "HtmlComponent",
                  "coordinates": {
                    "x": 0,
                    "y": 0
                  },
                  "width": 200,
                  "height": 50,
                  "name": {
                    "source": "typed",
                    "value": "HtmlComponent_1"
                  },
                  "stimulus": {
                    "source": "typed",
                    "value": "<div id=\"ityh\" style=\"box-sizing: border-box;\">pues no dentro de nested loop</div>"
                  }
                }
              ]
            },
            "response_components": {
              "source": "typed",
              "value": [
                {
                  "type": "ButtonResponseComponent",
                  "coordinates": {
                    "x": 0,
                    "y": 0.30601092896174853
                  },
                  "width": 200,
                  "height": 50,
                  "name": {
                    "source": "typed",
                    "value": "ButtonResponseComponent_1"
                  },
                  "choices": {
                    "source": "typed",
                    "value": [
                      "ok"
                    ]
                  }
                }
              ]
            }
          },
          "csvJson": [],
          "csvColumns": [],
          "orders": false,
          "orderColumns": [],
          "stimuliOrders": [],
          "categories": false,
          "categoryColumn": "",
          "categoryData": [],
          "branches": [],
          "branchConditions": [],
          "repeatConditions": [
            {
              "id": 1769124654889,
              "rules": [
                {
                  "column": "",
                  "op": "==",
                  "value": "ok",
                  "fieldType": "response_components",
                  "componentIdx": "ButtonResponseComponent_1",
                  "prop": "response"
                }
              ],
              "jumpToTrialId": "1769054417382"
            },
            {
              "id": 1769124654889,
              "rules": [
                {
                  "column": "",
                  "op": "==",
                  "value": ""
                }
              ],
              "jumpToTrialId": "1769054417382"
            }
          ]
        },
        {
          "type": "Trial",
          "name": "nonested",
          "plugin": "plugin-dynamic",
          "parameters": {
            "includesExtensions": false,
            "extensionType": ""
          },
          "trialCode": "",
          "parentLoopId": "loop_1769054420851",
          "id": 1769110039675,
          "createdAt": "2026-01-22T19:27:19.675Z",
          "updatedAt": "2026-01-22T19:53:37.262Z",
          "branches": [
            1769110050795
          ],
          "columnMapping": {
            "components": {
              "source": "typed",
              "value": [
                {
                  "type": "HtmlComponent",
                  "coordinates": {
                    "x": 0,
                    "y": 0
                  },
                  "width": 200,
                  "height": 50,
                  "name": {
                    "source": "typed",
                    "value": "HtmlComponent_1"
                  },
                  "stimulus": {
                    "source": "typed",
                    "value": "<div id=\"ic4v\" style=\"box-sizing: border-box;\">este no es nested</div>"
                  }
                }
              ]
            },
            "response_components": {
              "source": "typed",
              "value": [
                {
                  "type": "ButtonResponseComponent",
                  "coordinates": {
                    "x": 0,
                    "y": 0.30054644808743164
                  },
                  "width": 200,
                  "height": 50,
                  "name": {
                    "source": "typed",
                    "value": "ButtonResponseComponent_1"
                  },
                  "choices": {
                    "source": "typed",
                    "value": [
                      "ok"
                    ]
                  }
                }
              ]
            }
          },
          "csvJson": [],
          "csvColumns": [],
          "orders": false,
          "orderColumns": [],
          "stimuliOrders": [],
          "categories": false,
          "categoryColumn": "",
          "categoryData": []
        },
        {
          "type": "Trial",
          "name": "saliendodenested",
          "plugin": "plugin-dynamic",
          "parameters": {},
          "trialCode": "",
          "parentLoopId": "loop_1769054420851",
          "id": 1769110050795,
          "createdAt": "2026-01-22T19:27:30.795Z",
          "updatedAt": "2026-01-22T23:08:53.318Z",
          "columnMapping": {
            "components": {
              "source": "typed",
              "value": [
                {
                  "type": "HtmlComponent",
                  "coordinates": {
                    "x": 0,
                    "y": 0
                  },
                  "width": 200,
                  "height": 50,
                  "name": {
                    "source": "typed",
                    "value": "HtmlComponent_1"
                  },
                  "stimulus": {
                    "source": "typed",
                    "value": "<div id=\"iyg7\" style=\"box-sizing: border-box;\">saliendo de nested</div>"
                  }
                }
              ]
            },
            "response_components": {
              "source": "typed",
              "value": [
                {
                  "type": "ButtonResponseComponent",
                  "coordinates": {
                    "x": -0.004098360655737765,
                    "y": 0.27322404371584685
                  },
                  "width": 200,
                  "height": 50,
                  "name": {
                    "source": "typed",
                    "value": "ButtonResponseComponent_1"
                  },
                  "choices": {
                    "source": "typed",
                    "value": [
                      "ok"
                    ]
                  }
                }
              ]
            }
          },
          "branches": [],
          "paramsOverride": [
            {
              "id": 1769123332813,
              "rules": [
                {
                  "trialId": "",
                  "column": "",
                  "op": "==",
                  "value": "",
                  "prop": ""
                }
              ],
              "paramsToOverride": {}
            }
          ]
        },
        {
          "type": "Trial",
          "name": "New Trial 1",
          "plugin": "plugin-dynamic",
          "parameters": {},
          "trialCode": "",
          "parentLoopId": "loop_1769054420851",
          "id": 1769116968980,
          "createdAt": "2026-01-22T21:22:48.980Z",
          "updatedAt": "2026-01-22T21:24:18.873Z",
          "columnMapping": {
            "components": {
              "source": "typed",
              "value": [
                {
                  "type": "HtmlComponent",
                  "coordinates": {
                    "x": 0,
                    "y": 0
                  },
                  "width": 200,
                  "height": 50,
                  "name": {
                    "source": "typed",
                    "value": "HtmlComponent_1"
                  },
                  "stimulus": {
                    "source": "typed",
                    "value": "<div id=\"isli\" style=\"box-sizing: border-box;\">branch de nested</div>"
                  }
                }
              ]
            },
            "response_components": {
              "source": "typed",
              "value": [
                {
                  "type": "ButtonResponseComponent",
                  "coordinates": {
                    "x": 0.012295081967212962,
                    "y": 0.38797814207650266
                  },
                  "width": 200,
                  "height": 50,
                  "name": {
                    "source": "typed",
                    "value": "ButtonResponseComponent_1"
                  },
                  "choices": {
                    "source": "typed",
                    "value": [
                      "loca"
                    ]
                  }
                }
              ]
            }
          },
          "branches": []
        },
        {
          "type": "Trial",
          "name": "New Trial",
          "plugin": "plugin-dynamic",
          "parameters": {},
          "trialCode": "",
          "id": 1769133935682,
          "createdAt": "2026-01-23T02:05:35.682Z",
          "updatedAt": "2026-01-23T02:05:51.036Z",
          "columnMapping": {
            "components": {
              "source": "typed",
              "value": [
                {
                  "type": "HtmlComponent",
                  "coordinates": {
                    "x": 0,
                    "y": 0
                  },
                  "width": 200,
                  "height": 50,
                  "name": {
                    "source": "typed",
                    "value": "HtmlComponent_1"
                  },
                  "stimulus": {
                    "source": "typed",
                    "value": "<div style=\"box-sizing: border-box;\">Type or design here</div>"
                  }
                }
              ]
            }
          }
        }
      ],
      "loops": [
        {
          "name": "Loop 1",
          "repetitions": 1,
          "randomize": false,
          "orders": false,
          "stimuliOrders": [],
          "orderColumns": [],
          "categoryColumn": "",
          "categories": false,
          "categoryData": [],
          "trials": [
            1769054415115,
            1769054417382,
            "loop_1769054430260"
          ],
          "code": "",
          "id": "loop_1769054420851",
          "createdAt": "2026-01-22T04:00:20.851Z",
          "updatedAt": "2026-01-22T23:42:44.921Z",
          "branches": [
            1769054422939
          ],
          "isConditionalLoop": true,
          "loopConditions": [
            {
              "id": 1769119681919,
              "rules": [
                {
                  "trialId": "1769054417382",
                  "column": "",
                  "op": "==",
                  "value": "ok",
                  "prop": "response",
                  "fieldType": "response_components",
                  "componentIdx": "ButtonResponseComponent_1"
                }
              ]
            }
          ],
          "csvJson": [],
          "csvColumns": []
        },
        {
          "name": "Nested Loop 1",
          "repetitions": 1,
          "randomize": false,
          "orders": false,
          "stimuliOrders": [],
          "orderColumns": [],
          "categoryColumn": "",
          "categories": false,
          "categoryData": [],
          "trials": [
            1769054425182,
            1769054426032
          ],
          "code": "",
          "parentLoopId": "loop_1769054420851",
          "id": "loop_1769054430260",
          "createdAt": "2026-01-22T04:00:30.260Z",
          "updatedAt": "2026-01-22T21:22:48.999Z",
          "branches": [
            1769116968980
          ],
          "isConditionalLoop": false,
          "loopConditions": [],
          "csvJson": [],
          "csvColumns": []
        }
      ],
      "timeline": [
        {
          "id": 1769054412868,
          "type": "trial",
          "name": "Loopsiono",
          "branches": [
            1769054414149,
            "loop_1769054420851"
          ]
        },
        {
          "id": 1769054414149,
          "type": "trial",
          "name": "no",
          "branches": [
            1769133935682
          ]
        },
        {
          "id": "loop_1769054420851",
          "type": "loop",
          "name": "Loop 1",
          "branches": [
            1769054422939
          ],
          "trials": [
            1769054415115,
            1769054417382,
            "loop_1769054430260"
          ]
        },
        {
          "id": 1769054422939,
          "type": "trial",
          "name": "New Trial 2",
          "branches": []
        },
        {
          "id": 1769133935682,
          "type": "trial",
          "name": "New Trial",
          "branches": []
        }
      ],
      "createdAt": "2026-01-22T03:57:19.781Z",
      "updatedAt": "2026-01-23T02:05:51.036Z"
    },
    {
      "experimentID": "e852734d-02be-4a66-b9c7-56c078e94d9b",
      "trials": [
        {
          "type": "Trial",
          "name": "New Trial",
          "plugin": "plugin-dynamic",
          "parameters": {},
          "trialCode": "",
          "id": 1769321170531,
          "createdAt": "2026-01-25T06:06:10.531Z",
          "updatedAt": "2026-01-25T06:06:30.284Z",
          "branches": [
            1769321171295,
            1769321172161
          ],
          "columnMapping": {}
        },
        {
          "type": "Trial",
          "name": "New Trial 1",
          "plugin": "plugin-dynamic",
          "parameters": {},
          "trialCode": "",
          "id": 1769321171295,
          "createdAt": "2026-01-25T06:06:11.295Z",
          "updatedAt": "2026-01-25T06:06:21.063Z",
          "branches": [
            1769321181046
          ]
        },
        {
          "type": "Trial",
          "name": "New Trial 2",
          "plugin": "plugin-dynamic",
          "parameters": {},
          "trialCode": "",
          "id": 1769321172161,
          "createdAt": "2026-01-25T06:06:12.161Z",
          "updatedAt": "2026-01-25T06:06:22.095Z",
          "branches": [
            1769321182078
          ]
        },
        {
          "type": "Trial",
          "name": "New Trial 3",
          "plugin": "plugin-dynamic",
          "parameters": {},
          "trialCode": "",
          "id": 1769321181046,
          "createdAt": "2026-01-25T06:06:21.046Z",
          "updatedAt": "2026-01-25T06:06:21.046Z"
        },
        {
          "type": "Trial",
          "name": "New Trial 4",
          "plugin": "plugin-dynamic",
          "parameters": {},
          "trialCode": "",
          "id": 1769321182078,
          "createdAt": "2026-01-25T06:06:22.078Z",
          "updatedAt": "2026-01-25T06:06:22.078Z"
        }
      ],
      "loops": [],
      "timeline": [
        {
          "id": 1769321170531,
          "type": "trial",
          "name": "New Trial",
          "branches": [
            1769321171295,
            1769321172161
          ]
        },
        {
          "id": 1769321171295,
          "type": "trial",
          "name": "New Trial 1",
          "branches": [
            1769321181046
          ]
        },
        {
          "id": 1769321172161,
          "type": "trial",
          "name": "New Trial 2",
          "branches": [
            1769321182078
          ]
        },
        {
          "id": 1769321181046,
          "type": "trial",
          "name": "New Trial 3",
          "branches": []
        },
        {
          "id": 1769321182078,
          "type": "trial",
          "name": "New Trial 4",
          "branches": []
        }
      ],
      "createdAt": "2026-01-25T06:06:10.534Z",
      "updatedAt": "2026-01-25T06:06:30.284Z"
    }
  ],
  "configs": [
    {
      "experimentID": "35c481f1-13f2-43a6-9aee-54e1e0bc2e42",
      "data": {
        "generatedCode": "\n  // --- Recolectar metadata del sistema ---\n  const getMetadata = () => {\n    const ua = navigator.userAgent;\n    let browserName = 'Unknown';\n    let browserVersion = 'Unknown';\n    \n    if (ua.indexOf('Firefox') > -1) {\n      browserName = 'Firefox';\n      browserVersion = ua.match(/Firefox\\/(\\d+\\.\\d+)/)?.[1] || 'Unknown';\n    } else if (ua.indexOf('Chrome') > -1) {\n      browserName = 'Chrome';\n      browserVersion = ua.match(/Chrome\\/(\\d+\\.\\d+)/)?.[1] || 'Unknown';\n    } else if (ua.indexOf('Safari') > -1) {\n      browserName = 'Safari';\n      browserVersion = ua.match(/Version\\/(\\d+\\.\\d+)/)?.[1] || 'Unknown';\n    } else if (ua.indexOf('Edg') > -1) {\n      browserName = 'Edge';\n      browserVersion = ua.match(/Edg\\/(\\d+\\.\\d+)/)?.[1] || 'Unknown';\n    }\n    \n    let osName = 'Unknown';\n    if (ua.indexOf('Win') > -1) osName = 'Windows';\n    else if (ua.indexOf('Mac') > -1) osName = 'macOS';\n    else if (ua.indexOf('Linux') > -1) osName = 'Linux';\n    else if (ua.indexOf('Android') > -1) osName = 'Android';\n    else if (ua.indexOf('iOS') > -1) osName = 'iOS';\n    \n    return {\n      browser: browserName,\n      browserVersion: browserVersion,\n      os: osName,\n      screenWidth: window.screen.width,\n      screenHeight: window.screen.height,\n      screenResolution: `${window.screen.width}x${window.screen.height}`,\n      viewportWidth: window.innerWidth,\n      viewportHeight: window.innerHeight,\n      language: navigator.language,\n      userAgent: ua,\n      startedAt: new Date().toISOString()\n    };\n  };\n  \n  const metadata = getMetadata();\n\n  // --- Firebase config ---\n  const firebaseConfig = {\n    apiKey: \"AIzaSyBEbJ-uGKzsaf2u24KPamBPVZrUmvhFk-Q\",\n    authDomain: \"test-e4cf9.firebaseapp.com\",\n    databaseURL: \"http://localhost:9000?ns=test-e4cf9\",\n    projectId: \"test-e4cf9\",\n    storageBucket: \"test-e4cf9.firebasestorage.app\",\n    messagingSenderId: \"414213417080\",\n    appId: \"1:414213417080:web:98607c621a54d07656e58d\"\n  };\n\n  // --- Cargar Firebase SDK ---\n  if (typeof window.firebase === 'undefined') {\n    const script = document.createElement('script');\n    script.src = 'https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js';\n    script.onload = () => {\n      const dbScript = document.createElement('script');\n      dbScript.src = 'https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js';\n      dbScript.onload = () => { window._firebaseReady = true; };\n      document.head.appendChild(dbScript);\n    };\n    document.head.appendChild(script);\n  } else {\n    window._firebaseReady = true;\n  }\n\n  function waitForFirebase() {\n    return new Promise(resolve => {\n      if (window._firebaseReady) return resolve();\n      const interval = setInterval(() => {\n        if (window._firebaseReady) {\n          clearInterval(interval);\n          resolve();\n        }\n      }, 50);\n    });\n  }\n\n \n  const userStr = null;\n\n  const Uid = userStr.uid\n\n  const trialSessionId =\n    \"online_\" + (crypto.randomUUID\n      ? crypto.randomUUID()\n      : Math.random().toString(36).slice(2, 10));\n\n  let participantNumber;\n\n  async function saveSession(trialSessionId) {\n    try {\n      const res = await fetch(\"http://localhost:5001/test-e4cf9/us-central1/apiData\", {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\", Accept: \"*/*\" },\n        body: JSON.stringify({\n          experimentID: \"35c481f1-13f2-43a6-9aee-54e1e0bc2e42\",\n          experimentName: \"wrc\", \n          sessionId: trialSessionId,\n          storage: \"drive\",\n          uid: Uid\n        }),\n      });\n      \n      console.log('Response status:', res.status);\n      \n      if (!res.ok) {\n        const errorText = await res.text();\n        console.error('Error creating session:', errorText);\n        throw new Error(`Failed to create session: ${res.status} - ${errorText}`);\n      }\n      \n      const result = await res.json();\n      console.log('Session created successfully:', result);\n      \n      if (!result.success) {\n        if (result.message?.includes(\"INVALID_GOOGLE_DRIVE_TOKEN\") || result.message?.includes(\"Invalid Google Drive token\")) {\n          alert(\"Warning: Google Drive token not found or invalid. Please reconnect your Drive account in Settings.\");\n        } else if (result.message?.includes(\"INVALID_DROPBOX_TOKEN\") || result.message?.includes(\"Invalid Dropbox token\")) {\n          alert(\"Warning: Dropbox token not found or invalid. Please reconnect your Dropbox account in Settings.\");\n        }\n        throw new Error(result.message || 'Failed to create session');\n      }\n      \n      participantNumber = result.participantNumber;\n      return participantNumber;\n    } catch (error) {\n      console.error('Error in saveSession:', error);\n      alert('Error creating session: ' + error.message);\n      throw error;\n    }\n  }\n\n  (async () => {\n    // Limpiar el localStorage de valores de sesiones anteriores\n    localStorage.removeItem('jsPsych_jumpToTrial');\n    \n    // Esperar e inicializar Firebase\n    await waitForFirebase();\n    if (!window.firebase.apps.length) {\n      window.firebase.initializeApp(firebaseConfig);\n    }\n    const db = window.firebase.database();\n\n    participantNumber = await saveSession(trialSessionId);\n\n    if (typeof participantNumber !== \"number\" || isNaN(participantNumber)) {\n      alert(\"The participant number is not assigned. Please, wait.\");\n      throw new Error(\"participantNumber not assigned\");\n    }\n\n    // --- Configurar onDisconnect para finalizar sesión automáticamente ---\n    const sessionRef = db.ref('sessions/35c481f1-13f2-43a6-9aee-54e1e0bc2e42/' + trialSessionId);\n    await sessionRef.set({\n      connected: true,\n      experimentID: '35c481f1-13f2-43a6-9aee-54e1e0bc2e42',\n      sessionId: trialSessionId,\n      startedAt: window.firebase.database.ServerValue.TIMESTAMP,\n      storage: 'drive',\n      state: 'initiated',\n      lastUpdate: window.firebase.database.ServerValue.TIMESTAMP,\n      metadata: metadata\n    });\n    \n    // Guardar metadata en db.json local también (para persistencia)\n    fetch('/api/save-online-session-metadata/35c481f1-13f2-43a6-9aee-54e1e0bc2e42', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        sessionId: trialSessionId,\n        metadata: metadata,\n        state: 'initiated'\n      })\n    }).catch(err => console.warn('Could not save metadata to local db:', err));\n    \n    // Cuando se desconecte sin completar, marcar como abandoned\n    // Incluir needsFinalization para que se procesen los datos en caso de desconexión\n    sessionRef.onDisconnect().update({\n      connected: false,\n      needsFinalization: true,\n      state: 'abandoned',\n      disconnectedAt: window.firebase.database.ServerValue.TIMESTAMP,\n      storage: 'drive'\n    });\n\n    // --- Branching logic functions (outside initJsPsych for timeline access) ---\n    window.nextTrialId = null;\n    window.skipRemaining = false;\n    window.branchingActive = false;\n    window.branchCustomParameters = null; // Store custom parameters for the next trial\n\n    const evaluateCondition = (trialData, condition) => {\n      // All rules in a condition must be true (AND logic)\n      return condition.rules.every(rule => {\n        // New flat structure: rule.column contains the direct column name\n        // e.g., \"ButtonResponseComponent_1_response\" or \"response\" for normal plugins\n        const columnName = rule.column || rule.prop; // Fallback to rule.prop for backward compatibility\n        \n        if (!columnName) {\n          console.warn('No column name specified in rule:', rule);\n          return false;\n        }\n        \n        // Get value directly from the column\n        const propValue = trialData[columnName];\n        \n        if (propValue === undefined) {\n          console.warn('Column not found in trial data:', columnName);\n          return false;\n        }\n        \n        const compareValue = rule.value;\n        \n        // Handle array responses (multi-select or single-select returned as array)\n        if (Array.isArray(propValue)) {\n          const matches = propValue.includes(compareValue) || propValue.includes(String(compareValue));\n          switch (rule.op) {\n            case '==':\n              return matches;\n            case '!=':\n              return !matches;\n            default:\n              return false;\n          }\n        }\n        \n        // Convert values for comparison (for non-array values)\n        const numPropValue = parseFloat(propValue);\n        const numCompareValue = parseFloat(compareValue);\n        const isNumeric = !isNaN(numPropValue) && !isNaN(numCompareValue);\n        \n        switch (rule.op) {\n          case '==':\n            return isNumeric ? numPropValue === numCompareValue : propValue == compareValue;\n          case '!=':\n            return isNumeric ? numPropValue !== numCompareValue : propValue != compareValue;\n          case '>':\n            return isNumeric && numPropValue > numCompareValue;\n          case '<':\n            return isNumeric && numPropValue < numCompareValue;\n          case '>=':\n            return isNumeric && numPropValue >= numCompareValue;\n          case '<=':\n            return isNumeric && numPropValue <= numCompareValue;\n          default:\n            return false;\n        }\n      });\n    };\n    \n    const getNextTrialId = (lastTrialData) => {\n      if (!lastTrialData || !lastTrialData.trials || !lastTrialData.trials[0]) {\n        return null;\n      }\n      \n      const trial = lastTrialData.trials[0];\n      \n      // Check if trial/loop has branches\n      if (!Array.isArray(trial.branches) || trial.branches.length === 0) {\n        return null;\n      }\n      \n      // Check if there are conditions to evaluate\n      const hasBranchConditions = Array.isArray(trial.branchConditions) && trial.branchConditions.length > 0;\n      \n      // Check if any condition has customParameters\n      const hasCustomParameters = hasBranchConditions && \n        trial.branchConditions.flat().some(condition => \n          condition && condition.customParameters && \n          Object.keys(condition.customParameters).length > 0\n        );\n      \n      // If there are no conditions AND no custom parameters, auto-branch to first branch\n      if (!hasBranchConditions && !hasCustomParameters) {\n        console.log('No conditions or custom parameters defined, auto-branching to first branch:', trial.branches[0]);\n        return trial.branches[0];\n      }\n      \n      // If there are no conditions but there ARE custom parameters, we can't auto-branch\n      // We need to evaluate conditions to know which customParameters to use\n      if (!hasBranchConditions && hasCustomParameters) {\n        console.log('Custom parameters exist but no conditions, cannot auto-branch');\n        return null;\n      }\n      \n      // If there ARE conditions, evaluate them (regardless of how many branches there are)\n      // branchConditions is an array of arrays, flatten it first\n      const conditions = trial.branchConditions.flat();\n      \n      // Evaluate each condition (OR logic between conditions)\n      for (const condition of conditions) {\n        if (!condition || !condition.rules) {\n          console.warn('Invalid condition structure:', condition);\n          continue;\n        }\n        \n        if (evaluateCondition(trial, condition)) {\n          // Store custom parameters if they exist\n          if (condition.customParameters) {\n            window.branchCustomParameters = condition.customParameters;\n          }\n          return condition.nextTrialId;\n        }\n      }\n      \n      // No condition matched - do NOT branch (conditions were defined but none matched)\n      return null;\n    };\n\n    // Track pending data saves to ensure all complete before finishing\n    const pendingDataSaves = [];\n\n    const jsPsych = initJsPsych({\n      display_element: document.getElementById('jspsych-container'),\n\n      on_trial_start: function(trial) {\n        const lastTrialData = jsPsych.data.get()\n        if (lastTrialData && trial.data) {\n        trial.data.prev_response = lastTrialData.response;\n        }\n      },\n\n      \n\n      on_data_update: function (data) {\n\n        // Actualizar estado a 'in-progress' en la primera actualización\n        if (data.trial_index === 0) {\n          sessionRef.update({\n            state: 'in-progress',\n            lastUpdate: window.firebase.database.ServerValue.TIMESTAMP\n          }).catch(err => console.error('Error updating state:', err));\n          \n          // Actualizar también en db.json local\n          fetch('/api/save-online-session-metadata/35c481f1-13f2-43a6-9aee-54e1e0bc2e42', {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify({\n              sessionId: trialSessionId,\n              state: 'in-progress'\n            })\n          }).catch(err => console.warn('Could not update state in local db:', err));\n        }\n\n        // Create and track the promise for this data save\n        const savePromise = fetch(\"http://localhost:5001/test-e4cf9/us-central1/apiData\", {\n          method: \"POST\",\n          headers: { \"Content-Type\": \"application/json\", Accept: \"*/*\" },\n          body: JSON.stringify({\n            experimentID: \"35c481f1-13f2-43a6-9aee-54e1e0bc2e42\",\n            sessionId: trialSessionId,\n            data: data,\n            storage: \"drive\",\n          }),\n        })\n        .then(res => {\n          if (!res.ok) {\n            return res.text().then(text => {\n              console.error('Error appending data:', text);\n            });\n          }\n          return res.json();\n        })\n        .then(result => {\n          if (result && result.success) {\n            console.log('Data appended to temporary storage');\n          }\n        })\n        .catch(error => {\n          console.error('Error in on_data_update:', error);\n        })\n        .finally(() => {\n          // Remove from pending once complete\n          const index = pendingDataSaves.indexOf(savePromise);\n          if (index > -1) {\n            pendingDataSaves.splice(index, 1);\n          }\n        });\n        \n        pendingDataSaves.push(savePromise);\n\n        // Solo evaluar branching si el trial/loop tiene un trial_id o loop_id válido\n      if ((!data.trial_id || data.trial_id === undefined) && (!data.loop_id || data.loop_id === undefined)) {\n        return;\n      }\n      \n      const lastTrialData = jsPsych.data.getLastTrialData();\n      const trial = lastTrialData.trials ? lastTrialData.trials[0] : null;\n      \n      // Verificar si este trial/loop tiene branches\n      if (!trial || !trial.branches || trial.branches.length === 0) {\n        return; // No tiene branches, no hay nada que hacer\n      }\n      \n      // IMPORTANTE: Si el trial está dentro de un loop (isInLoop = true),\n      // NO activar el branching global. Los trials dentro de loops usan su propio\n      // sistema de branching con variables locales (loopNextTrialId, etc.)\n      if (trial.isInLoop === true) {\n        return;\n      }\n      \n      const nextTrialId = getNextTrialId(lastTrialData);\n      \n      if (nextTrialId) {\n        // Check if nextTrialId is \"FINISH_EXPERIMENT\"\n        if (nextTrialId === 'FINISH_EXPERIMENT') {\n          console.log('🏁 [BRANCHING] Finishing experiment via branching');\n          jsPsych.abortExperiment('Experiment finished by branching condition', {});\n          return;\n        }\n        \n        console.log('🎯 [BRANCHING] Setting global branch target:', nextTrialId);\n        window.nextTrialId = nextTrialId;\n        window.skipRemaining = true;\n        window.branchingActive = true;\n        console.log('🎯 [BRANCHING] Skip remaining activated');\n      }\n      },\n\n      on_finish: async function() {\n        \n        // Wait for all pending data saves to complete\n        if (pendingDataSaves.length > 0) {\n          console.log('Waiting for', pendingDataSaves.length, 'pending data saves to complete...');\n          await Promise.allSettled(pendingDataSaves);\n          console.log('All data saves completed');\n        }\n        \n        // Cancelar el onDisconnect para evitar que marque como abandoned\n        sessionRef.onDisconnect().cancel();\n\n        // Finalizar la sesión normalmente y marcar en Firebase que terminó correctamente\n        console.log('Experiment finished normally, sending data to storage...');\n        \n        try {\n          \n          // Marcar en Firebase que terminó correctamente Y necesita finalización\n          await sessionRef.update({\n            connected: false,\n            finished: true,\n            needsFinalization: true,\n            state: 'completed',\n            finishedAt: window.firebase.database.ServerValue.TIMESTAMP,\n            lastUpdate: window.firebase.database.ServerValue.TIMESTAMP\n          });\n          \n          // Guardar estado completado en db.json local (persistencia)\n          await fetch('/api/save-online-session-metadata/35c481f1-13f2-43a6-9aee-54e1e0bc2e42', {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify({\n              sessionId: trialSessionId,\n              state: 'completed'\n            })\n          }).catch(err => console.warn('Could not update completed state in local db:', err));\n          \n          // El backend procesará la finalización al detectar needsFinalization=true\n          console.log('Session marked for finalization in Firebase');\n        } catch (error) {\n          console.error('Error marking session as finished:', error);\n        }\n      },\n  // Uncomment to see the json results after finishing a session experiment\n  // jsPsych.data.displayData('csv');\n});\n\nconst timeline = [];\n\n// Global preload for all uploaded files from Timeline\n\nconst globalPreload = {\n  type: jsPsychPreload,\n  files: [\"img/armadillo.png\",\"img/bmw.png\",\"img/boat.png\",\"img/boat2.png\",\"img/cofre.png\",\"img/cube.png\",\"img/dis.png\",\"img/floor.png\",\"img/green.png\",\"img/obstacle.png\"]\n};\ntimeline.push(globalPreload);\n\n\n\n    let test_stimuli_Loopsiono = [];\n    \n    console.log(\"=== DEBUG Loopsiono: Starting orders/categories logic ===\");\n    console.log(\"Trial name: Loopsiono\");\n    console.log(\"Trial ID: 1769054412868\");\n    console.log(\"orders flag:\", true);\n    console.log(\"categories flag:\", true);\n    console.log(\"typeof participantNumber:\", typeof participantNumber);\n    console.log(\"participantNumber value:\", participantNumber);\n    console.log(\"isNaN(participantNumber):\", isNaN(participantNumber));\n    console.log(\"Condition check (typeof participantNumber === 'number' && !isNaN(participantNumber)):\", (typeof participantNumber === \"number\" && !isNaN(participantNumber)));\n    \n    if (typeof participantNumber === \"number\" && !isNaN(participantNumber)) {\n      console.log(\"✓ INSIDE participantNumber check - condition passed\");\n      const stimuliOrders = [[0,1,2,3,4,5,6,7,8,9]];\n      const categoryData = [\"1\",\"1\",\"1\",\"1\",\"2\",\"2\",\"2\",\"3\",\"3\",\"3\"];\n      const test_stimuli_previous_Loopsiono = [{components: [{ type: \"HtmlComponent\", coordinates: {\"x\":0,\"y\":0}, width: 200, height: 50, name: \"HtmlComponent_1\", stimulus: \"<div id=\\\"ip0u\\\" style=\\\"box-sizing: border-box;\\\">loop?</div>\" }, { type: \"ImageComponent\", coordinates: {\"x\":-0.6501604646475405,\"y\":-0.5168634492003834}, width: 268.8730468382805, height: 268.8730468382805, name: \"ImageComponent_1\", stimulus: \"img/armadillo.png\" }],\nresponse_components: [{ type: \"ButtonResponseComponent\", coordinates: {\"x\":-0.016393442622950838,\"y\":0.4207650273224042}, width: 200, height: 50, name: \"ButtonResponseComponent_1\", choices: [\"si\", \"no\", \"nose\"] }]},{components: [{ type: \"HtmlComponent\", coordinates: {\"x\":0,\"y\":0}, width: 200, height: 50, name: \"HtmlComponent_1\", stimulus: \"<div id=\\\"ip0u\\\" style=\\\"box-sizing: border-box;\\\">loop?</div>\" }, { type: \"ImageComponent\", coordinates: {\"x\":-0.6501604646475405,\"y\":-0.5168634492003834}, width: 268.8730468382805, height: 268.8730468382805, name: \"ImageComponent_1\", stimulus: \"img/bmw.png\" }],\nresponse_components: [{ type: \"ButtonResponseComponent\", coordinates: {\"x\":-0.016393442622950838,\"y\":0.4207650273224042}, width: 200, height: 50, name: \"ButtonResponseComponent_1\", choices: [\"si\", \"no\", \"nose\"] }]},{components: [{ type: \"HtmlComponent\", coordinates: {\"x\":0,\"y\":0}, width: 200, height: 50, name: \"HtmlComponent_1\", stimulus: \"<div id=\\\"ip0u\\\" style=\\\"box-sizing: border-box;\\\">loop?</div>\" }, { type: \"ImageComponent\", coordinates: {\"x\":-0.6501604646475405,\"y\":-0.5168634492003834}, width: 268.8730468382805, height: 268.8730468382805, name: \"ImageComponent_1\", stimulus: \"img/boat.png\" }],\nresponse_components: [{ type: \"ButtonResponseComponent\", coordinates: {\"x\":-0.016393442622950838,\"y\":0.4207650273224042}, width: 200, height: 50, name: \"ButtonResponseComponent_1\", choices: [\"si\", \"no\", \"nose\"] }]},{components: [{ type: \"HtmlComponent\", coordinates: {\"x\":0,\"y\":0}, width: 200, height: 50, name: \"HtmlComponent_1\", stimulus: \"<div id=\\\"ip0u\\\" style=\\\"box-sizing: border-box;\\\">loop?</div>\" }, { type: \"ImageComponent\", coordinates: {\"x\":-0.6501604646475405,\"y\":-0.5168634492003834}, width: 268.8730468382805, height: 268.8730468382805, name: \"ImageComponent_1\", stimulus: \"img/boat2.png\" }],\nresponse_components: [{ type: \"ButtonResponseComponent\", coordinates: {\"x\":-0.016393442622950838,\"y\":0.4207650273224042}, width: 200, height: 50, name: \"ButtonResponseComponent_1\", choices: [\"si\", \"no\", \"nose\"] }]},{components: [{ type: \"HtmlComponent\", coordinates: {\"x\":0,\"y\":0}, width: 200, height: 50, name: \"HtmlComponent_1\", stimulus: \"<div id=\\\"ip0u\\\" style=\\\"box-sizing: border-box;\\\">loop?</div>\" }, { type: \"ImageComponent\", coordinates: {\"x\":-0.6501604646475405,\"y\":-0.5168634492003834}, width: 268.8730468382805, height: 268.8730468382805, name: \"ImageComponent_1\", stimulus: \"img/cofre.png\" }],\nresponse_components: [{ type: \"ButtonResponseComponent\", coordinates: {\"x\":-0.016393442622950838,\"y\":0.4207650273224042}, width: 200, height: 50, name: \"ButtonResponseComponent_1\", choices: [\"si\", \"no\", \"nose\"] }]},{components: [{ type: \"HtmlComponent\", coordinates: {\"x\":0,\"y\":0}, width: 200, height: 50, name: \"HtmlComponent_1\", stimulus: \"<div id=\\\"ip0u\\\" style=\\\"box-sizing: border-box;\\\">loop?</div>\" }, { type: \"ImageComponent\", coordinates: {\"x\":-0.6501604646475405,\"y\":-0.5168634492003834}, width: 268.8730468382805, height: 268.8730468382805, name: \"ImageComponent_1\", stimulus: \"img/cube.png\" }],\nresponse_components: [{ type: \"ButtonResponseComponent\", coordinates: {\"x\":-0.016393442622950838,\"y\":0.4207650273224042}, width: 200, height: 50, name: \"ButtonResponseComponent_1\", choices: [\"si\", \"no\", \"nose\"] }]},{components: [{ type: \"HtmlComponent\", coordinates: {\"x\":0,\"y\":0}, width: 200, height: 50, name: \"HtmlComponent_1\", stimulus: \"<div id=\\\"ip0u\\\" style=\\\"box-sizing: border-box;\\\">loop?</div>\" }, { type: \"ImageComponent\", coordinates: {\"x\":-0.6501604646475405,\"y\":-0.5168634492003834}, width: 268.8730468382805, height: 268.8730468382805, name: \"ImageComponent_1\", stimulus: \"img/dis.png\" }],\nresponse_components: [{ type: \"ButtonResponseComponent\", coordinates: {\"x\":-0.016393442622950838,\"y\":0.4207650273224042}, width: 200, height: 50, name: \"ButtonResponseComponent_1\", choices: [\"si\", \"no\", \"nose\"] }]},{components: [{ type: \"HtmlComponent\", coordinates: {\"x\":0,\"y\":0}, width: 200, height: 50, name: \"HtmlComponent_1\", stimulus: \"<div id=\\\"ip0u\\\" style=\\\"box-sizing: border-box;\\\">loop?</div>\" }, { type: \"ImageComponent\", coordinates: {\"x\":-0.6501604646475405,\"y\":-0.5168634492003834}, width: 268.8730468382805, height: 268.8730468382805, name: \"ImageComponent_1\", stimulus: \"img/floor.png\" }],\nresponse_components: [{ type: \"ButtonResponseComponent\", coordinates: {\"x\":-0.016393442622950838,\"y\":0.4207650273224042}, width: 200, height: 50, name: \"ButtonResponseComponent_1\", choices: [\"si\", \"no\", \"nose\"] }]},{components: [{ type: \"HtmlComponent\", coordinates: {\"x\":0,\"y\":0}, width: 200, height: 50, name: \"HtmlComponent_1\", stimulus: \"<div id=\\\"ip0u\\\" style=\\\"box-sizing: border-box;\\\">loop?</div>\" }, { type: \"ImageComponent\", coordinates: {\"x\":-0.6501604646475405,\"y\":-0.5168634492003834}, width: 268.8730468382805, height: 268.8730468382805, name: \"ImageComponent_1\", stimulus: \"img/green.png\" }],\nresponse_components: [{ type: \"ButtonResponseComponent\", coordinates: {\"x\":-0.016393442622950838,\"y\":0.4207650273224042}, width: 200, height: 50, name: \"ButtonResponseComponent_1\", choices: [\"si\", \"no\", \"nose\"] }]},{components: [{ type: \"HtmlComponent\", coordinates: {\"x\":0,\"y\":0}, width: 200, height: 50, name: \"HtmlComponent_1\", stimulus: \"<div id=\\\"ip0u\\\" style=\\\"box-sizing: border-box;\\\">loop?</div>\" }, { type: \"ImageComponent\", coordinates: {\"x\":-0.6501604646475405,\"y\":-0.5168634492003834}, width: 268.8730468382805, height: 268.8730468382805, name: \"ImageComponent_1\", stimulus: \"img/obstacle.png\" }],\nresponse_components: [{ type: \"ButtonResponseComponent\", coordinates: {\"x\":-0.016393442622950838,\"y\":0.4207650273224042}, width: 200, height: 50, name: \"ButtonResponseComponent_1\", choices: [\"si\", \"no\", \"nose\"] }]}];\n      \n      console.log(\"participantNumber:\", participantNumber);\n      console.log(\"stimuliOrders:\", stimuliOrders);\n      console.log(\"stimuliOrders.length:\", stimuliOrders.length);\n      console.log(\"categoryData:\", categoryData);\n      console.log(\"categoryData.length:\", categoryData.length);\n      console.log(\"test_stimuli_previous_Loopsiono.length:\", test_stimuli_previous_Loopsiono.length);\n      \n      if (categoryData.length > 0) {\n        console.log(\"ENTERING categoryData.length > 0 branch\");\n        // Obtener todas las categorías únicas\n        const allCategories = [...new Set(categoryData)];\n        console.log(\"allCategories:\", allCategories);\n        \n        // Determinar qué categoría le corresponde a este participante\n        const categoryIndex = (participantNumber - 1) % allCategories.length;\n        const participantCategory = allCategories[categoryIndex];\n        console.log(\"categoryIndex:\", categoryIndex);\n        console.log(\"participantCategory:\", participantCategory);\n        \n        // Encontrar los índices que corresponden a esta categoría\n        const categoryIndices = [];\n        categoryData.forEach((category, index) => {\n          if (category === participantCategory) {\n            categoryIndices.push(index);\n          }\n        });\n        console.log(\"categoryIndices:\", categoryIndices);\n        \n        // Filtrar los estímulos por categoría\n        const categoryFilteredStimuli = categoryIndices.map(index => \n          test_stimuli_previous_Loopsiono[index]\n        );\n        console.log(\"categoryFilteredStimuli.length:\", categoryFilteredStimuli.length);\n\n        // Aplicar el orden si existe\n        if (stimuliOrders.length > 0) {\n          console.log(\"ENTERING stimuliOrders.length > 0 sub-branch\");\n          const orderIndex = (participantNumber - 1) % stimuliOrders.length;\n          const index_order = stimuliOrders[orderIndex];\n          console.log(\"orderIndex:\", orderIndex);\n          console.log(\"index_order:\", index_order);\n          \n          // Crear mapeo de índices originales a índices filtrados\n          const indexMapping = {};\n          categoryIndices.forEach((originalIndex, filteredIndex) => {\n            indexMapping[originalIndex] = filteredIndex;\n          });\n          console.log(\"indexMapping:\", indexMapping);\n          \n          // Aplicar el orden solo a los índices que existen en la categoría filtrada\n          const orderedIndices = index_order\n            .filter(i => indexMapping.hasOwnProperty(i))\n            .map(i => indexMapping[i]);\n          console.log(\"orderedIndices:\", orderedIndices);\n          \n          test_stimuli_Loopsiono = orderedIndices\n            .filter(i => i >= 0 && i < categoryFilteredStimuli.length)\n            .map(i => categoryFilteredStimuli[i]);\n        } else {\n          console.log(\"ENTERING else (no orders) sub-branch\");\n          test_stimuli_Loopsiono = categoryFilteredStimuli;\n        }\n        \n        console.log(\"Participant:\", participantNumber, \"Category:\", participantCategory);\n        console.log(\"Category indices:\", categoryIndices);\n        console.log(\"Filtered stimuli:\", test_stimuli_Loopsiono);\n        console.log(\"Final test_stimuli_Loopsiono.length:\", test_stimuli_Loopsiono.length);\n      } else if (stimuliOrders.length > 0) {\n        console.log(\"ENTERING stimuliOrders.length > 0 branch (no categories)\");\n        // Lógica original sin categorías pero con órdenes\n        const orderIndex = (participantNumber - 1) % stimuliOrders.length;\n        const index_order = stimuliOrders[orderIndex];\n        console.log(\"orderIndex:\", orderIndex);\n        console.log(\"index_order:\", index_order);\n        \n        test_stimuli_Loopsiono = index_order\n          .filter((i) => i !== -1 && i >= 0 && i < test_stimuli_previous_Loopsiono.length)\n          .map((i) => test_stimuli_previous_Loopsiono[i]);\n          \n        console.log(test_stimuli_Loopsiono);\n        console.log(\"Final test_stimuli_Loopsiono.length:\", test_stimuli_Loopsiono.length);\n      } else {\n        console.log(\"ENTERING else branch (no categories, no orders)\");\n        // Sin categorías ni órdenes, usar todos los estímulos\n        test_stimuli_Loopsiono = test_stimuli_previous_Loopsiono;\n        console.log(\"Final test_stimuli_Loopsiono.length:\", test_stimuli_Loopsiono.length);\n      }\n    } else {\n      console.log(\"✗ FAILED participantNumber check\");\n      console.log(\"Reason: typeof participantNumber !== 'number' OR isNaN(participantNumber)\");\n      console.log(\"test_stimuli_Loopsiono will be empty array!\");\n    }\n    console.log(\"=== END DEBUG Loopsiono ===\");\n    console.log(\"Final test_stimuli_Loopsiono:\", test_stimuli_Loopsiono);\n    console.log(\"Final test_stimuli_Loopsiono.length:\", test_stimuli_Loopsiono.length);\n    const Loopsiono_timeline = {\n    type: DynamicPlugin, components: jsPsych.timelineVariable(\"components\"),\nresponse_components: jsPsych.timelineVariable(\"response_components\"),\n      data: {\n        rt: \"rt\",\n        trial_id: 1769054412868,\n        \n        \n        branches: [1769054414149, \"loop_1769054420851\"],\n        branchConditions: [[{\"id\":1769125088942,\"rules\":[{\"column\":\"\",\"op\":\"==\",\"value\":\"nose\",\"fieldType\":\"response_components\",\"componentIdx\":\"ButtonResponseComponent_1\",\"prop\":\"response\"}],\"nextTrialId\":\"1769054414149\",\"customParameters\":{}},{\"id\":1769125796392,\"rules\":[{\"column\":\"\",\"op\":\"==\",\"value\":\"si\",\"fieldType\":\"response_components\",\"componentIdx\":\"ButtonResponseComponent_1\",\"prop\":\"response\"}],\"nextTrialId\":\"loop_1769054420851\",\"customParameters\":{}}]] \n        \n      },\n    on_start: function(trial) {\n      // First, evaluate and apply params override conditions (if any)\n      const paramsOverrideConditions = [{\"id\":1769122722267,\"rules\":[{\"trialId\":\"\",\"column\":\"\",\"op\":\"==\",\"value\":\"\",\"prop\":\"\"}],\"paramsToOverride\":{}}];\n      \n      // Evaluate params override conditions\n      for (const condition of paramsOverrideConditions) {\n        if (!condition || !condition.rules) {\n          continue;\n        }\n        \n        // Get data from all previous trials\n        const allData = jsPsych.data.get().values();\n        \n        // Check if all rules match (AND logic within condition)\n        const allRulesMatch = condition.rules.every(rule => {\n          if (!rule.trialId) {\n            return false;\n          }\n          \n          // Find data from the referenced trial\n          const trialData = allData.filter(d => {\n            // Compare both as strings to handle type mismatches\n            return String(d.trial_id) === String(rule.trialId) || d.trial_id === rule.trialId;\n          });\n          if (trialData.length === 0) {\n            return false;\n          }\n          \n          // Use the most recent data if multiple exist\n          const data = trialData[trialData.length - 1];\n          \n          // Construct column name if empty (for dynamic plugins)\n          let columnName = rule.column || \"\";\n          if (!columnName && rule.componentIdx && rule.prop) {\n            columnName = rule.componentIdx + '_' + rule.prop;\n          }\n          \n          // Get the property value using the column name\n          const propValue = data[columnName || rule.prop];\n          const compareValue = rule.value;\n          \n          // Handle array responses (multi-select questions)\n          if (Array.isArray(propValue)) {\n            // For array values, check if compareValue is included in the array\n            switch (rule.op) {\n              case '==':\n                return propValue.includes(compareValue);\n              case '!=':\n                return !propValue.includes(compareValue);\n              default:\n                return false; // Comparison operators don't make sense for arrays\n            }\n          }\n          \n          // Convert values for comparison (for non-array values)\n          const numPropValue = parseFloat(propValue);\n          const numCompareValue = parseFloat(compareValue);\n          const isNumeric = !isNaN(numPropValue) && !isNaN(numCompareValue);\n          \n          switch (rule.op) {\n            case '==':\n              return isNumeric ? numPropValue === numCompareValue : propValue == compareValue;\n            case '!=':\n              return isNumeric ? numPropValue !== numCompareValue : propValue != compareValue;\n            case '>':\n              return isNumeric && numPropValue > numCompareValue;\n            case '<':\n              return isNumeric && numPropValue < numCompareValue;\n            case '>=':\n              return isNumeric && numPropValue >= numCompareValue;\n            case '<=':\n              return isNumeric && numPropValue <= numCompareValue;\n            default:\n              return false;\n          }\n        });\n        \n        // If all rules match, apply parameter overrides\n        if (allRulesMatch && condition.paramsToOverride) {\n          Object.entries(condition.paramsToOverride).forEach(([key, param]) => {\n            if (param && param.source !== 'none') {\n              // Parse key to check structure\n              const parts = key.split('::');\n              \n              if (parts.length === 4) {\n                // Format: fieldType::componentName::survey_json::questionName\n                const [fieldType, componentName, propName, questionName] = parts;\n                \n                if (fieldType && componentName && propName === 'survey_json' && questionName) {\n                  // Find the component by name in the field array\n                  const fieldArray = trial[fieldType];\n                  \n                  if (Array.isArray(fieldArray)) {\n                    const compIndex = fieldArray.findIndex(c => c.name === componentName);\n                    \n                    if (compIndex !== -1 && fieldArray[compIndex].survey_json) {\n                      // Find the question in survey_json.elements\n                      const elements = fieldArray[compIndex].survey_json.elements || [];\n                      const questionIndex = elements.findIndex(q => q.name === questionName);\n                      \n                      if (questionIndex !== -1) {\n                        // Apply the override value (from typed or csv)\n                        let valueToSet;\n                        if (param.source === 'typed') {\n                          valueToSet = String(param.value); // Convert to string for SurveyJS\n                        } else if (param.source === 'csv') {\n                          valueToSet = String(trial[param.value]); // Get from CSV column and convert to string\n                        }\n                        \n                        if (valueToSet !== undefined && valueToSet !== null) {\n                          fieldArray[compIndex].survey_json.elements[questionIndex].defaultValue = valueToSet;\n                        }\n                      }\n                    }\n                  }\n                }\n              } else if (parts.length === 3) {\n                // Format: fieldType::componentName::property (for dynamic plugin components like ButtonResponseComponent)\n                const [fieldType, componentName, propName] = parts;\n                \n                if (fieldType && componentName && propName) {\n                  // Find the component by name in the field array\n                  const fieldArray = trial[fieldType];\n                  \n                  if (Array.isArray(fieldArray)) {\n                    const compIndex = fieldArray.findIndex(c => c.name === componentName);\n                    \n                    if (compIndex !== -1) {\n                      // Apply the override value\n                      let valueToSet;\n                      if (param.source === 'typed') {\n                        valueToSet = param.value;\n                      } else if (param.source === 'csv') {\n                        valueToSet = trial[param.value]; // Get from CSV column\n                      }\n                      \n                      if (valueToSet !== undefined && valueToSet !== null) {\n                        fieldArray[compIndex][propName] = valueToSet;\n                      }\n                    }\n                  }\n                }\n              } else {\n                // Normal parameter (not nested)\n                if (param.source === 'typed' && param.value !== undefined && param.value !== null) {\n                  trial[key] = param.value;\n                } else if (param.source === 'csv' && param.value !== undefined && param.value !== null) {\n                  // For CSV source, param.value contains the column name, get the actual value from trial\n                  trial[key] = trial[param.value];\n                }\n              }\n            }\n          });\n          // Break after first matching condition (OR logic between conditions)\n          break;\n        }\n      }\n      \n      // Then apply custom parameters from branching conditions (higher priority)\n      // For trials outside loops, use window.branchCustomParameters\n      if (window.branchCustomParameters && typeof window.branchCustomParameters === 'object') {\n        Object.entries(window.branchCustomParameters).forEach(([key, param]) => {\n          if (param && param.source !== 'none') {\n            // Parse key to check if it's a nested survey question\n            const parts = key.split('::');\n            \n            if (parts.length === 4) {\n              // Format: fieldType::componentName::survey_json::questionName\n              const [fieldType, componentName, propName, questionName] = parts;\n              \n              if (fieldType && componentName && propName === 'survey_json' && questionName) {\n                // Find the component by name in the field array\n                const fieldArray = trial[fieldType];\n                if (Array.isArray(fieldArray)) {\n                  const compIndex = fieldArray.findIndex(c => c.name === componentName);\n                  if (compIndex !== -1 && fieldArray[compIndex].survey_json) {\n                    // Find the question in survey_json.elements\n                    const elements = fieldArray[compIndex].survey_json.elements || [];\n                    const questionIndex = elements.findIndex(q => q.name === questionName);\n                    \n                    if (questionIndex !== -1) {\n                      // Apply the override value (from typed or csv)\n                      let valueToSet;\n                      if (param.source === 'typed') {\n                        valueToSet = String(param.value); // Convert to string for SurveyJS\n                      } else if (param.source === 'csv') {\n                        valueToSet = String(trial[param.value]); // Get from CSV column and convert to string\n                      }\n                      \n                      if (valueToSet !== undefined && valueToSet !== null) {\n                        fieldArray[compIndex].survey_json.elements[questionIndex].defaultValue = valueToSet;\n                      }\n                    }\n                  }\n                }\n              }\n            } else if (parts.length === 3) {\n              // Format: fieldType::componentName::property (for DynamicPlugin components)\n              const [fieldType, componentName, propName] = parts;\n              \n              if (fieldType && componentName && propName) {\n                // Find the component by name in the field array\n                const fieldArray = trial[fieldType];\n                if (Array.isArray(fieldArray)) {\n                  const compIndex = fieldArray.findIndex(c => c.name === componentName);\n                  if (compIndex !== -1) {\n                    // Apply the override value (from typed or csv)\n                    let valueToSet;\n                    if (param.source === 'typed') {\n                      valueToSet = param.value;\n                    } else if (param.source === 'csv') {\n                      valueToSet = trial[param.value];\n                    }\n                    \n                    if (valueToSet !== undefined && valueToSet !== null) {\n                      fieldArray[compIndex][propName] = valueToSet;\n                    }\n                  }\n                }\n              }\n            } else {\n              // Normal parameter (not nested survey question)\n              if (param.source === 'typed' && param.value !== undefined && param.value !== null) {\n                trial[key] = param.value;\n              } else if (param.source === 'csv' && param.value !== undefined && param.value !== null) {\n                trial[key] = trial[param.value];\n              }\n            }\n          }\n        });\n        // Clear the custom parameters after applying them\n        window.branchCustomParameters = null;\n      }\n      \n    },\n    on_finish: function(data) {\n      // Evaluar condiciones del trial para branching global\n      console.log('🔍 [GLOBAL BRANCH] Evaluating branch conditions...');\n      const branches = [1769054414149, \"loop_1769054420851\"];\n      const branchConditions = [{\"id\":1769125088942,\"rules\":[{\"column\":\"\",\"op\":\"==\",\"value\":\"nose\",\"fieldType\":\"response_components\",\"componentIdx\":\"ButtonResponseComponent_1\",\"prop\":\"response\"}],\"nextTrialId\":\"1769054414149\",\"customParameters\":{}},{\"id\":1769125796392,\"rules\":[{\"column\":\"\",\"op\":\"==\",\"value\":\"si\",\"fieldType\":\"response_components\",\"componentIdx\":\"ButtonResponseComponent_1\",\"prop\":\"response\"}],\"nextTrialId\":\"loop_1769054420851\",\"customParameters\":{}}].flat();\n      console.log('🔍 [GLOBAL BRANCH] Available branches:', branches);\n      console.log('🔍 [GLOBAL BRANCH] Conditions to evaluate:', branchConditions.length);\n      \n      let nextTrialId = null;\n      let matchedCustomParameters = null;\n      \n      // Evaluar cada condición (lógica OR entre condiciones)\n      for (const condition of branchConditions) {\n        if (!condition || !condition.rules) {\n          continue;\n        }\n        \n        // Todas las reglas en una condición deben ser verdaderas (lógica AND)\n        const allRulesMatch = condition.rules.every(rule => {\n          let propValue;\n          \n          // Parse column name to extract component info for dynamic plugins\n          // Format: \"componentName_propertyName\" or \"componentName_questionName\" for surveys\n          // If column is empty, construct it from componentIdx and prop\n          let columnName = rule.column || \"\";\n          if (!columnName && rule.componentIdx && rule.prop) {\n            columnName = rule.componentIdx + '_' + rule.prop;\n          }\n          const parts = columnName.split(\"_\");\n          \n          // Check if this looks like a dynamic plugin column (has underscore)\n          if (parts.length >= 2) {\n            // Last part is the property or question name\n            const propertyOrQuestion = parts[parts.length - 1];\n            // Everything before the last underscore is the component name\n            const componentName = parts.slice(0, -1).join(\"_\");\n            \n            // Try to find the data in the format: componentName_response\n            const responseKey = componentName + '_response';\n            const responseData = data[responseKey];\n            \n            // If response data exists and is an object (SurveyComponent case)\n            if (responseData && typeof responseData === 'object' && !Array.isArray(responseData)) {\n              // This is likely a survey response - check if property is a question name\n              if (responseData[propertyOrQuestion] !== undefined) {\n                propValue = responseData[propertyOrQuestion];\n              } else {\n                return false;\n              }\n            } else {\n              // Not a survey response object, try direct property access\n              const directKey = componentName + '_' + propertyOrQuestion;\n              if (data[directKey] !== undefined) {\n                propValue = data[directKey];\n              } else {\n                return false;\n              }\n            }\n          } else {\n            // Normal plugin structure - direct property access\n            propValue = data[columnName];\n          }\n          \n          const compareValue = rule.value;\n          \n          // Handle array responses (multi-select or single-select returned as array)\n          if (Array.isArray(propValue)) {\n            const matches = propValue.includes(compareValue) || propValue.includes(String(compareValue));\n            switch (rule.op) {\n              case '==':\n                return matches;\n              case '!=':\n                return !matches;\n              default:\n                return false;\n            }\n          }\n          \n          // Convertir valores para comparación\n          const numPropValue = parseFloat(propValue);\n          const numCompareValue = parseFloat(compareValue);\n          const isNumeric = !isNaN(numPropValue) && !isNaN(numCompareValue);\n          \n          switch (rule.op) {\n            case '==':\n              return isNumeric ? numPropValue === numCompareValue : propValue == compareValue;\n            case '!=':\n              return isNumeric ? numPropValue !== numCompareValue : propValue != compareValue;\n            case '>':\n              return isNumeric && numPropValue > numCompareValue;\n            case '<':\n              return isNumeric && numPropValue < numCompareValue;\n            case '>=':\n              return isNumeric && numPropValue >= numCompareValue;\n            case '<=':\n              return isNumeric && numPropValue <= numCompareValue;\n            default:\n              return false;\n          }\n        });\n        \n        if (allRulesMatch) {\n          console.log('✅ [GLOBAL BRANCH] Condition matched! Next trial:', condition.nextTrialId);\n          nextTrialId = condition.nextTrialId;\n          // Store custom parameters if they exist\n          if (condition.customParameters) {\n            matchedCustomParameters = condition.customParameters;\n            console.log('✅ [GLOBAL BRANCH] Custom parameters:', matchedCustomParameters);\n          }\n          break;\n        }\n      }\n      \n      // Si se encontró match, activar branching\n      if (nextTrialId) {\n        console.log('🎯 [GLOBAL BRANCH] Activating branching to trial:', nextTrialId);\n        window.nextTrialId = nextTrialId;\n        window.skipRemaining = true;\n        window.branchingActive = true;\n        // Store custom parameters for the next trial\n        if (matchedCustomParameters) {\n          window.branchCustomParameters = matchedCustomParameters;\n        }\n      } else {\n        // No match - ir al primer branch por defecto\n        console.log('⚠️ [GLOBAL BRANCH] No condition matched, branching to first branch:', branches[0]);\n        window.nextTrialId = branches[0];\n        window.skipRemaining = true;\n        window.branchingActive = true;\n      }\n      \n    },};\n    console.log(\"=== PROCEDURE SETUP Loopsiono ===\");\n    console.log(\"test_stimuli_Loopsiono before procedure:\", test_stimuli_Loopsiono);\n    console.log(\"test_stimuli_Loopsiono.length:\", test_stimuli_Loopsiono ? test_stimuli_Loopsiono.length : 'undefined');\n    \n    const Loopsiono_procedure = {\n    timeline: \n    [Loopsiono_timeline],\n    timeline_variables: test_stimuli_Loopsiono,\n    \n    conditional_function: function() {\n      const currentId = 1769054412868;\n      \n      // Verificar si hay un trial objetivo guardado en localStorage (para repeat/jump)\n      const jumpToTrial = localStorage.getItem('jsPsych_jumpToTrial');\n      if (jumpToTrial) {\n        if (String(currentId) === String(jumpToTrial)) {\n          // Encontramos el trial objetivo para repeat/jump\n          console.log('🔁 [REPEAT/JUMP] Found target trial', currentId);\n          localStorage.removeItem('jsPsych_jumpToTrial');\n          return true;\n        }\n        // No es el objetivo, saltar\n        console.log('⏭️ [REPEAT/JUMP] Skipping trial', currentId);\n        return false;\n      }\n      \n      // Si skipRemaining está activo (branching normal), verificar si este es el trial objetivo\n      if (window.skipRemaining) {\n        console.log('🔍 [SKIP CHECK] Trial', currentId, '| Target:', window.nextTrialId, '| Match:', String(currentId) === String(window.nextTrialId));\n        if (String(currentId) === String(window.nextTrialId)) {\n          // Encontramos el trial objetivo\n          console.log('✅ [SKIP CHECK] Found target trial! Disabling skip mode');\n          window.skipRemaining = false;\n          window.nextTrialId = null;\n          return true;\n        }\n        // No es el objetivo, saltar\n        console.log('⏭️ [SKIP CHECK] Skipping trial', currentId);\n        return false;\n      }\n      \n      return true;\n    },\n  \n    \n    };\n    timeline.push(Loopsiono_procedure);\n  \n\n\n    let test_stimuli_no = [];\n    \n    console.log(\"=== DEBUG no: Starting orders/categories logic ===\");\n    console.log(\"Trial name: no\");\n    console.log(\"Trial ID: 1769054414149\");\n    console.log(\"orders flag:\", true);\n    console.log(\"categories flag:\", true);\n    console.log(\"typeof participantNumber:\", typeof participantNumber);\n    console.log(\"participantNumber value:\", participantNumber);\n    console.log(\"isNaN(participantNumber):\", isNaN(participantNumber));\n    console.log(\"Condition check (typeof participantNumber === 'number' && !isNaN(participantNumber)):\", (typeof participantNumber === \"number\" && !isNaN(participantNumber)));\n    \n    if (typeof participantNumber === \"number\" && !isNaN(participantNumber)) {\n      console.log(\"✓ INSIDE participantNumber check - condition passed\");\n      const stimuliOrders = [[0,1,2,3,4,5,6,7,8,9]];\n      const categoryData = [\"1\",\"1\",\"1\",\"1\",\"2\",\"2\",\"2\",\"3\",\"3\",\"3\"];\n      const test_stimuli_previous_no = [{components: [{ type: \"HtmlComponent\", coordinates: {\"x\":0,\"y\":0}, width: 200, height: 50, name: \"HtmlComponent_1\", stimulus: \"<div id=\\\"i29z\\\" style=\\\"box-sizing: border-box;\\\">pues no</div>\" }, { type: \"ImageComponent\", coordinates: {\"x\":-0.6311476571080591,\"y\":-0.5598223340195362}, width: 223.9685353850833, height: 223.96853538508336, name: \"ImageComponent_1\", stimulus: \"img/armadillo.png\" }],\nresponse_components: [{ type: \"ButtonResponseComponent\", coordinates: {\"x\":0.0027472527472527375,\"y\":0.304029304029304}, width: 200, height: 50, name: \"ButtonResponseComponent_1\", choices: [\"ok\"] }]},{components: [{ type: \"HtmlComponent\", coordinates: {\"x\":0,\"y\":0}, width: 200, height: 50, name: \"HtmlComponent_1\", stimulus: \"<div id=\\\"i29z\\\" style=\\\"box-sizing: border-box;\\\">pues no</div>\" }, { type: \"ImageComponent\", coordinates: {\"x\":-0.6311476571080591,\"y\":-0.5598223340195362}, width: 223.9685353850833, height: 223.96853538508336, name: \"ImageComponent_1\", stimulus: \"img/bmw.png\" }],\nresponse_components: [{ type: \"ButtonResponseComponent\", coordinates: {\"x\":0.0027472527472527375,\"y\":0.304029304029304}, width: 200, height: 50, name: \"ButtonResponseComponent_1\", choices: [\"ok\"] }]},{components: [{ type: \"HtmlComponent\", coordinates: {\"x\":0,\"y\":0}, width: 200, height: 50, name: \"HtmlComponent_1\", stimulus: \"<div id=\\\"i29z\\\" style=\\\"box-sizing: border-box;\\\">pues no</div>\" }, { type: \"ImageComponent\", coordinates: {\"x\":-0.6311476571080591,\"y\":-0.5598223340195362}, width: 223.9685353850833, height: 223.96853538508336, name: \"ImageComponent_1\", stimulus: \"img/boat.png\" }],\nresponse_components: [{ type: \"ButtonResponseComponent\", coordinates: {\"x\":0.0027472527472527375,\"y\":0.304029304029304}, width: 200, height: 50, name: \"ButtonResponseComponent_1\", choices: [\"ok\"] }]},{components: [{ type: \"HtmlComponent\", coordinates: {\"x\":0,\"y\":0}, width: 200, height: 50, name: \"HtmlComponent_1\", stimulus: \"<div id=\\\"i29z\\\" style=\\\"box-sizing: border-box;\\\">pues no</div>\" }, { type: \"ImageComponent\", coordinates: {\"x\":-0.6311476571080591,\"y\":-0.5598223340195362}, width: 223.9685353850833, height: 223.96853538508336, name: \"ImageComponent_1\", stimulus: \"img/boat2.png\" }],\nresponse_components: [{ type: \"ButtonResponseComponent\", coordinates: {\"x\":0.0027472527472527375,\"y\":0.304029304029304}, width: 200, height: 50, name: \"ButtonResponseComponent_1\", choices: [\"ok\"] }]},{components: [{ type: \"HtmlComponent\", coordinates: {\"x\":0,\"y\":0}, width: 200, height: 50, name: \"HtmlComponent_1\", stimulus: \"<div id=\\\"i29z\\\" style=\\\"box-sizing: border-box;\\\">pues no</div>\" }, { type: \"ImageComponent\", coordinates: {\"x\":-0.6311476571080591,\"y\":-0.5598223340195362}, width: 223.9685353850833, height: 223.96853538508336, name: \"ImageComponent_1\", stimulus: \"img/cofre.png\" }],\nresponse_components: [{ type: \"ButtonResponseComponent\", coordinates: {\"x\":0.0027472527472527375,\"y\":0.304029304029304}, width: 200, height: 50, name: \"ButtonResponseComponent_1\", choices: [\"ok\"] }]},{components: [{ type: \"HtmlComponent\", coordinates: {\"x\":0,\"y\":0}, width: 200, height: 50, name: \"HtmlComponent_1\", stimulus: \"<div id=\\\"i29z\\\" style=\\\"box-sizing: border-box;\\\">pues no</div>\" }, { type: \"ImageComponent\", coordinates: {\"x\":-0.6311476571080591,\"y\":-0.5598223340195362}, width: 223.9685353850833, height: 223.96853538508336, name: \"ImageComponent_1\", stimulus: \"img/cube.png\" }],\nresponse_components: [{ type: \"ButtonResponseComponent\", coordinates: {\"x\":0.0027472527472527375,\"y\":0.304029304029304}, width: 200, height: 50, name: \"ButtonResponseComponent_1\", choices: [\"ok\"] }]},{components: [{ type: \"HtmlComponent\", coordinates: {\"x\":0,\"y\":0}, width: 200, height: 50, name: \"HtmlComponent_1\", stimulus: \"<div id=\\\"i29z\\\" style=\\\"box-sizing: border-box;\\\">pues no</div>\" }, { type: \"ImageComponent\", coordinates: {\"x\":-0.6311476571080591,\"y\":-0.5598223340195362}, width: 223.9685353850833, height: 223.96853538508336, name: \"ImageComponent_1\", stimulus: \"img/dis.png\" }],\nresponse_components: [{ type: \"ButtonResponseComponent\", coordinates: {\"x\":0.0027472527472527375,\"y\":0.304029304029304}, width: 200, height: 50, name: \"ButtonResponseComponent_1\", choices: [\"ok\"] }]},{components: [{ type: \"HtmlComponent\", coordinates: {\"x\":0,\"y\":0}, width: 200, height: 50, name: \"HtmlComponent_1\", stimulus: \"<div id=\\\"i29z\\\" style=\\\"box-sizing: border-box;\\\">pues no</div>\" }, { type: \"ImageComponent\", coordinates: {\"x\":-0.6311476571080591,\"y\":-0.5598223340195362}, width: 223.9685353850833, height: 223.96853538508336, name: \"ImageComponent_1\", stimulus: \"img/floor.png\" }],\nresponse_components: [{ type: \"ButtonResponseComponent\", coordinates: {\"x\":0.0027472527472527375,\"y\":0.304029304029304}, width: 200, height: 50, name: \"ButtonResponseComponent_1\", choices: [\"ok\"] }]},{components: [{ type: \"HtmlComponent\", coordinates: {\"x\":0,\"y\":0}, width: 200, height: 50, name: \"HtmlComponent_1\", stimulus: \"<div id=\\\"i29z\\\" style=\\\"box-sizing: border-box;\\\">pues no</div>\" }, { type: \"ImageComponent\", coordinates: {\"x\":-0.6311476571080591,\"y\":-0.5598223340195362}, width: 223.9685353850833, height: 223.96853538508336, name: \"ImageComponent_1\", stimulus: \"img/green.png\" }],\nresponse_components: [{ type: \"ButtonResponseComponent\", coordinates: {\"x\":0.0027472527472527375,\"y\":0.304029304029304}, width: 200, height: 50, name: \"ButtonResponseComponent_1\", choices: [\"ok\"] }]},{components: [{ type: \"HtmlComponent\", coordinates: {\"x\":0,\"y\":0}, width: 200, height: 50, name: \"HtmlComponent_1\", stimulus: \"<div id=\\\"i29z\\\" style=\\\"box-sizing: border-box;\\\">pues no</div>\" }, { type: \"ImageComponent\", coordinates: {\"x\":-0.6311476571080591,\"y\":-0.5598223340195362}, width: 223.9685353850833, height: 223.96853538508336, name: \"ImageComponent_1\", stimulus: \"img/obstacle.png\" }],\nresponse_components: [{ type: \"ButtonResponseComponent\", coordinates: {\"x\":0.0027472527472527375,\"y\":0.304029304029304}, width: 200, height: 50, name: \"ButtonResponseComponent_1\", choices: [\"ok\"] }]}];\n      \n      console.log(\"participantNumber:\", participantNumber);\n      console.log(\"stimuliOrders:\", stimuliOrders);\n      console.log(\"stimuliOrders.length:\", stimuliOrders.length);\n      console.log(\"categoryData:\", categoryData);\n      console.log(\"categoryData.length:\", categoryData.length);\n      console.log(\"test_stimuli_previous_no.length:\", test_stimuli_previous_no.length);\n      \n      if (categoryData.length > 0) {\n        console.log(\"ENTERING categoryData.length > 0 branch\");\n        // Obtener todas las categorías únicas\n        const allCategories = [...new Set(categoryData)];\n        console.log(\"allCategories:\", allCategories);\n        \n        // Determinar qué categoría le corresponde a este participante\n        const categoryIndex = (participantNumber - 1) % allCategories.length;\n        const participantCategory = allCategories[categoryIndex];\n        console.log(\"categoryIndex:\", categoryIndex);\n        console.log(\"participantCategory:\", participantCategory);\n        \n        // Encontrar los índices que corresponden a esta categoría\n        const categoryIndices = [];\n        categoryData.forEach((category, index) => {\n          if (category === participantCategory) {\n            categoryIndices.push(index);\n          }\n        });\n        console.log(\"categoryIndices:\", categoryIndices);\n        \n        // Filtrar los estímulos por categoría\n        const categoryFilteredStimuli = categoryIndices.map(index => \n          test_stimuli_previous_no[index]\n        );\n        console.log(\"categoryFilteredStimuli.length:\", categoryFilteredStimuli.length);\n\n        // Aplicar el orden si existe\n        if (stimuliOrders.length > 0) {\n          console.log(\"ENTERING stimuliOrders.length > 0 sub-branch\");\n          const orderIndex = (participantNumber - 1) % stimuliOrders.length;\n          const index_order = stimuliOrders[orderIndex];\n          console.log(\"orderIndex:\", orderIndex);\n          console.log(\"index_order:\", index_order);\n          \n          // Crear mapeo de índices originales a índices filtrados\n          const indexMapping = {};\n          categoryIndices.forEach((originalIndex, filteredIndex) => {\n            indexMapping[originalIndex] = filteredIndex;\n          });\n          console.log(\"indexMapping:\", indexMapping);\n          \n          // Aplicar el orden solo a los índices que existen en la categoría filtrada\n          const orderedIndices = index_order\n            .filter(i => indexMapping.hasOwnProperty(i))\n            .map(i => indexMapping[i]);\n          console.log(\"orderedIndices:\", orderedIndices);\n          \n          test_stimuli_no = orderedIndices\n            .filter(i => i >= 0 && i < categoryFilteredStimuli.length)\n            .map(i => categoryFilteredStimuli[i]);\n        } else {\n          console.log(\"ENTERING else (no orders) sub-branch\");\n          test_stimuli_no = categoryFilteredStimuli;\n        }\n        \n        console.log(\"Participant:\", participantNumber, \"Category:\", participantCategory);\n        console.log(\"Category indices:\", categoryIndices);\n        console.log(\"Filtered stimuli:\", test_stimuli_no);\n        console.log(\"Final test_stimuli_no.length:\", test_stimuli_no.length);\n      } else if (stimuliOrders.length > 0) {\n        console.log(\"ENTERING stimuliOrders.length > 0 branch (no categories)\");\n        // Lógica original sin categorías pero con órdenes\n        const orderIndex = (participantNumber - 1) % stimuliOrders.length;\n        const index_order = stimuliOrders[orderIndex];\n        console.log(\"orderIndex:\", orderIndex);\n        console.log(\"index_order:\", index_order);\n        \n        test_stimuli_no = index_order\n          .filter((i) => i !== -1 && i >= 0 && i < test_stimuli_previous_no.length)\n          .map((i) => test_stimuli_previous_no[i]);\n          \n        console.log(test_stimuli_no);\n        console.log(\"Final test_stimuli_no.length:\", test_stimuli_no.length);\n      } else {\n        console.log(\"ENTERING else branch (no categories, no orders)\");\n        // Sin categorías ni órdenes, usar todos los estímulos\n        test_stimuli_no = test_stimuli_previous_no;\n        console.log(\"Final test_stimuli_no.length:\", test_stimuli_no.length);\n      }\n    } else {\n      console.log(\"✗ FAILED participantNumber check\");\n      console.log(\"Reason: typeof participantNumber !== 'number' OR isNaN(participantNumber)\");\n      console.log(\"test_stimuli_no will be empty array!\");\n    }\n    console.log(\"=== END DEBUG no ===\");\n    console.log(\"Final test_stimuli_no:\", test_stimuli_no);\n    console.log(\"Final test_stimuli_no.length:\", test_stimuli_no.length);\n    const no_timeline = {\n    type: DynamicPlugin, components: jsPsych.timelineVariable(\"components\"),\nresponse_components: jsPsych.timelineVariable(\"response_components\"),\n      data: {\n        rt: \"rt\",\n        trial_id: 1769054414149,\n        \n        \n        branches: [1769133935682],\n        branchConditions: [[]] \n        \n      },\n    on_start: function(trial) {\n      // Then apply custom parameters from branching conditions (higher priority)\n      // For trials outside loops, use window.branchCustomParameters\n      if (window.branchCustomParameters && typeof window.branchCustomParameters === 'object') {\n        Object.entries(window.branchCustomParameters).forEach(([key, param]) => {\n          if (param && param.source !== 'none') {\n            // Parse key to check if it's a nested survey question\n            const parts = key.split('::');\n            \n            if (parts.length === 4) {\n              // Format: fieldType::componentName::survey_json::questionName\n              const [fieldType, componentName, propName, questionName] = parts;\n              \n              if (fieldType && componentName && propName === 'survey_json' && questionName) {\n                // Find the component by name in the field array\n                const fieldArray = trial[fieldType];\n                if (Array.isArray(fieldArray)) {\n                  const compIndex = fieldArray.findIndex(c => c.name === componentName);\n                  if (compIndex !== -1 && fieldArray[compIndex].survey_json) {\n                    // Find the question in survey_json.elements\n                    const elements = fieldArray[compIndex].survey_json.elements || [];\n                    const questionIndex = elements.findIndex(q => q.name === questionName);\n                    \n                    if (questionIndex !== -1) {\n                      // Apply the override value (from typed or csv)\n                      let valueToSet;\n                      if (param.source === 'typed') {\n                        valueToSet = String(param.value); // Convert to string for SurveyJS\n                      } else if (param.source === 'csv') {\n                        valueToSet = String(trial[param.value]); // Get from CSV column and convert to string\n                      }\n                      \n                      if (valueToSet !== undefined && valueToSet !== null) {\n                        fieldArray[compIndex].survey_json.elements[questionIndex].defaultValue = valueToSet;\n                      }\n                    }\n                  }\n                }\n              }\n            } else if (parts.length === 3) {\n              // Format: fieldType::componentName::property (for DynamicPlugin components)\n              const [fieldType, componentName, propName] = parts;\n              \n              if (fieldType && componentName && propName) {\n                // Find the component by name in the field array\n                const fieldArray = trial[fieldType];\n                if (Array.isArray(fieldArray)) {\n                  const compIndex = fieldArray.findIndex(c => c.name === componentName);\n                  if (compIndex !== -1) {\n                    // Apply the override value (from typed or csv)\n                    let valueToSet;\n                    if (param.source === 'typed') {\n                      valueToSet = param.value;\n                    } else if (param.source === 'csv') {\n                      valueToSet = trial[param.value];\n                    }\n                    \n                    if (valueToSet !== undefined && valueToSet !== null) {\n                      fieldArray[compIndex][propName] = valueToSet;\n                    }\n                  }\n                }\n              }\n            } else {\n              // Normal parameter (not nested survey question)\n              if (param.source === 'typed' && param.value !== undefined && param.value !== null) {\n                trial[key] = param.value;\n              } else if (param.source === 'csv' && param.value !== undefined && param.value !== null) {\n                trial[key] = trial[param.value];\n              }\n            }\n          }\n        });\n        // Clear the custom parameters after applying them\n        window.branchCustomParameters = null;\n      }\n      \n    },\n    on_finish: function(data) {\n      // Branching automático al primer branch (global)\n      console.log('🔄 [GLOBAL BRANCH] Auto-branching to first branch:', 1769133935682);\n      window.nextTrialId = 1769133935682;\n      window.skipRemaining = true;\n      window.branchingActive = true;\n      \n    },};\n    console.log(\"=== PROCEDURE SETUP no ===\");\n    console.log(\"test_stimuli_no before procedure:\", test_stimuli_no);\n    console.log(\"test_stimuli_no.length:\", test_stimuli_no ? test_stimuli_no.length : 'undefined');\n    \n    const no_procedure = {\n    timeline: \n    [no_timeline],\n    timeline_variables: test_stimuli_no,\n    \n    conditional_function: function() {\n      const currentId = 1769054414149;\n      \n      // Verificar si hay un trial objetivo guardado en localStorage (para repeat/jump)\n      const jumpToTrial = localStorage.getItem('jsPsych_jumpToTrial');\n      if (jumpToTrial) {\n        if (String(currentId) === String(jumpToTrial)) {\n          // Encontramos el trial objetivo para repeat/jump\n          console.log('🔁 [REPEAT/JUMP] Found target trial', currentId);\n          localStorage.removeItem('jsPsych_jumpToTrial');\n          return true;\n        }\n        // No es el objetivo, saltar\n        console.log('⏭️ [REPEAT/JUMP] Skipping trial', currentId);\n        return false;\n      }\n      \n      // Si skipRemaining está activo (branching normal), verificar si este es el trial objetivo\n      if (window.skipRemaining) {\n        console.log('🔍 [SKIP CHECK] Trial', currentId, '| Target:', window.nextTrialId, '| Match:', String(currentId) === String(window.nextTrialId));\n        if (String(currentId) === String(window.nextTrialId)) {\n          // Encontramos el trial objetivo\n          console.log('✅ [SKIP CHECK] Found target trial! Disabling skip mode');\n          window.skipRemaining = false;\n          window.nextTrialId = null;\n          return true;\n        }\n        // No es el objetivo, saltar\n        console.log('⏭️ [SKIP CHECK] Skipping trial', currentId);\n        return false;\n      }\n      \n      return true;\n    },\n  \n    \n    };\n    timeline.push(no_procedure);\n  \n\n\n\n    const test_stimuli_loop_1769054420851 = [\n  {\n    \"components_New_Trialb_2\": [\n      {\n        \"type\": \"HtmlComponent\",\n        \"coordinates\": {\n          \"x\": 0,\n          \"y\": 0\n        },\n        \"width\": 200,\n        \"height\": 50,\n        \"name\": \"HtmlComponent_1\",\n        \"stimulus\": \"<div id=\\\"ikgb\\\" style=\\\"box-sizing: border-box;\\\">loco?</div>\"\n      }\n    ],\n    \"response_components_New_Trialb_2\": [\n      {\n        \"type\": \"ButtonResponseComponent\",\n        \"coordinates\": {\n          \"x\": -0.004098360655737765,\n          \"y\": 0.30601092896174853\n        },\n        \"width\": 200,\n        \"height\": 50,\n        \"name\": \"ButtonResponseComponent_1\",\n        \"choices\": [\n          \"si\",\n          \"no\"\n        ]\n      }\n    ],\n    \"components_New_Trial_3\": [\n      {\n        \"type\": \"HtmlComponent\",\n        \"coordinates\": {\n          \"x\": 0,\n          \"y\": 0\n        },\n        \"width\": 200,\n        \"height\": 50,\n        \"name\": \"HtmlComponent_1\",\n        \"stimulus\": \"<div id=\\\"isj4\\\" style=\\\"box-sizing: border-box;\\\">pues no dentro de loop</div>\"\n      }\n    ],\n    \"response_components_New_Trial_3\": [\n      {\n        \"type\": \"ButtonResponseComponent\",\n        \"coordinates\": {\n          \"x\": -0.004098360655737765,\n          \"y\": 0.26229508196721313\n        },\n        \"width\": 200,\n        \"height\": 50,\n        \"name\": \"ButtonResponseComponent_1\",\n        \"choices\": [\n          \"ok\"\n        ]\n      }\n    ],\n    \"components_New_Trial_1\": [\n      {\n        \"type\": \"HtmlComponent\",\n        \"coordinates\": {\n          \"x\": 0,\n          \"y\": 0\n        },\n        \"width\": 200,\n        \"height\": 50,\n        \"name\": \"HtmlComponent_1\",\n        \"stimulus\": \"<div id=\\\"isli\\\" style=\\\"box-sizing: border-box;\\\">branch de nested</div>\"\n      }\n    ],\n    \"response_components_New_Trial_1\": [\n      {\n        \"type\": \"ButtonResponseComponent\",\n        \"coordinates\": {\n          \"x\": 0.012295081967212962,\n          \"y\": 0.38797814207650266\n        },\n        \"width\": 200,\n        \"height\": 50,\n        \"name\": \"ButtonResponseComponent_1\",\n        \"choices\": [\n          \"loca\"\n        ]\n      }\n    ]\n  }\n];\n    \n    \n    \n    const New_Trialb_2_timeline = {\n    type: DynamicPlugin, components: jsPsych.timelineVariable(\"components_New_Trialb_2\"),\nresponse_components: jsPsych.timelineVariable(\"response_components_New_Trialb_2\"),\n      data: {\n        rt: \"rt_New_Trialb_2\",\n        trial_id: 1769054415115,\n        isInLoop: true,\n        \n        branches: [1769054417382, \"loop_1769054430260\"],\n        branchConditions: [[{\"id\":1769054609999,\"rules\":[{\"column\":\"ButtonResponseComponent_1_response\",\"op\":\"==\",\"value\":\"no\",\"fieldType\":\"response_components\",\"componentIdx\":\"ButtonResponseComponent_1\",\"prop\":\"response\"}],\"nextTrialId\":\"1769054417382\",\"customParameters\":{}},{\"id\":1769054624031,\"rules\":[{\"column\":\"ButtonResponseComponent_1_response\",\"op\":\"==\",\"value\":\"si\",\"fieldType\":\"response_components\",\"componentIdx\":\"ButtonResponseComponent_1\",\"prop\":\"response\"}],\"nextTrialId\":\"loop_1769054430260\",\"customParameters\":{}}]] \n        \n      },\n    on_start: function(trial) {\n      // Then apply custom parameters from branching conditions (higher priority)\n      // For trials in loops, use loop-specific BranchCustomParameters\n      if (typeof loop_loop_1769054420851_BranchCustomParameters !== 'undefined' && loop_loop_1769054420851_BranchCustomParameters && typeof loop_loop_1769054420851_BranchCustomParameters === 'object') {\n        Object.entries(loop_loop_1769054420851_BranchCustomParameters).forEach(([key, param]) => {\n          if (param && param.source !== 'none') {\n            // Parse key to check if it's a nested survey question\n            const parts = key.split('::');\n            \n            if (parts.length === 4) {\n              // Format: fieldType::componentName::survey_json::questionName\n              const [fieldType, componentName, propName, questionName] = parts;\n              \n              if (fieldType && componentName && propName === 'survey_json' && questionName) {\n                // Find the component by name in the field array\n                const fieldArray = trial[fieldType];\n                if (Array.isArray(fieldArray)) {\n                  const compIndex = fieldArray.findIndex(c => c.name === componentName);\n                  if (compIndex !== -1 && fieldArray[compIndex].survey_json) {\n                    // Find the question in survey_json.elements\n                    const elements = fieldArray[compIndex].survey_json.elements || [];\n                    const questionIndex = elements.findIndex(q => q.name === questionName);\n                    \n                    if (questionIndex !== -1) {\n                      // Apply the override value (from typed or csv)\n                      let valueToSet;\n                      if (param.source === 'typed') {\n                        valueToSet = String(param.value); // Convert to string for SurveyJS\n                      } else if (param.source === 'csv') {\n                        valueToSet = String(trial[param.value]); // Get from CSV column and convert to string\n                      }\n                      \n                      if (valueToSet !== undefined && valueToSet !== null) {\n                        fieldArray[compIndex].survey_json.elements[questionIndex].defaultValue = valueToSet;\n                      }\n                    }\n                  }\n                }\n              }\n            } else if (parts.length === 3) {\n              // Format: fieldType::componentName::property (for DynamicPlugin components)\n              const [fieldType, componentName, propName] = parts;\n              \n              if (fieldType && componentName && propName) {\n                // Find the component by name in the field array\n                const fieldArray = trial[fieldType];\n                if (Array.isArray(fieldArray)) {\n                  const compIndex = fieldArray.findIndex(c => c.name === componentName);\n                  if (compIndex !== -1) {\n                    // Apply the override value (from typed or csv)\n                    let valueToSet;\n                    if (param.source === 'typed') {\n                      valueToSet = param.value;\n                    } else if (param.source === 'csv') {\n                      valueToSet = trial[param.value];\n                    }\n                    \n                    if (valueToSet !== undefined && valueToSet !== null) {\n                      fieldArray[compIndex][propName] = valueToSet;\n                    }\n                  }\n                }\n              }\n            } else {\n              // Normal parameter (not nested survey question)\n              if (param.source === 'typed' && param.value !== undefined && param.value !== null) {\n                trial[key] = param.value;\n              } else if (param.source === 'csv' && param.value !== undefined && param.value !== null) {\n                trial[key] = trial[param.value];\n              }\n            }\n          }\n        });\n        // Clear the custom parameters after applying them\n        loop_loop_1769054420851_BranchCustomParameters = null;\n      }\n      \n    },\n    on_finish: function(data) {\n      // Evaluar condiciones del trial para branching interno del loop\n      console.log('🔍 [LOOP BRANCH] Evaluating branch conditions...');\n      const branches = [1769054417382, \"loop_1769054430260\"];\n      const branchConditions = [{\"id\":1769054609999,\"rules\":[{\"column\":\"ButtonResponseComponent_1_response\",\"op\":\"==\",\"value\":\"no\",\"fieldType\":\"response_components\",\"componentIdx\":\"ButtonResponseComponent_1\",\"prop\":\"response\"}],\"nextTrialId\":\"1769054417382\",\"customParameters\":{}},{\"id\":1769054624031,\"rules\":[{\"column\":\"ButtonResponseComponent_1_response\",\"op\":\"==\",\"value\":\"si\",\"fieldType\":\"response_components\",\"componentIdx\":\"ButtonResponseComponent_1\",\"prop\":\"response\"}],\"nextTrialId\":\"loop_1769054430260\",\"customParameters\":{}}].flat();\n      console.log('🔍 [LOOP BRANCH] Available branches:', branches);\n      console.log('🔍 [LOOP BRANCH] Conditions to evaluate:', branchConditions.length);\n      \n      let nextTrialId = null;\n      let matchedCustomParameters = null;\n      \n      // Evaluar cada condición (lógica OR entre condiciones)\n      for (const condition of branchConditions) {\n        if (!condition || !condition.rules) {\n          continue;\n        }\n        \n        // Todas las reglas en una condición deben ser verdaderas (lógica AND)\n        const allRulesMatch = condition.rules.every(rule => {\n          let propValue;\n          \n          // Parse column name to extract component info for dynamic plugins\n          // Format: \"componentName_propertyName\" or \"componentName_questionName\" for surveys\n          const columnName = rule.column || rule.prop || \"\";\n          const parts = columnName.split(\"_\");\n          \n          // Check if this looks like a dynamic plugin column (has underscore)\n          if (parts.length >= 2) {\n            // Last part is the property or question name\n            const propertyOrQuestion = parts[parts.length - 1];\n            // Everything before the last underscore is the component name\n            const componentName = parts.slice(0, -1).join(\"_\");\n            \n            // Try to find the data in the format: componentName_response\n            const responseKey = componentName + '_response';\n            const responseData = data[responseKey];\n            \n            console.log('Branch eval (loop): Checking column', columnName);\n            console.log('Branch eval (loop): Component name:', componentName, 'Property:', propertyOrQuestion);\n            console.log('Branch eval (loop): Looking for response key:', responseKey);\n            console.log('Branch eval (loop): Response data:', responseData);\n            \n            // If response data exists and is an object (SurveyComponent case)\n            if (responseData && typeof responseData === 'object' && !Array.isArray(responseData)) {\n              // This is likely a survey response - check if property is a question name\n              if (responseData[propertyOrQuestion] !== undefined) {\n                propValue = responseData[propertyOrQuestion];\n                console.log('Branch eval (loop): Found survey question response', propertyOrQuestion, '=', propValue);\n              } else {\n                console.log('Branch eval (loop): Survey question not found:', propertyOrQuestion);\n                return false;\n              }\n            } else {\n              // Not a survey response object, try direct property access\n              const directKey = componentName + '_' + propertyOrQuestion;\n              if (data[directKey] !== undefined) {\n                propValue = data[directKey];\n                console.log('Branch eval (loop): Found direct property', directKey, '=', propValue);\n              } else {\n                console.log('Branch eval (loop): Property not found:', directKey);\n                return false;\n              }\n            }\n          } else {\n            // Normal plugin structure - direct property access\n            propValue = data[columnName];\n            console.log('Branch eval (loop): Direct property access', columnName, '=', propValue);\n          }\n          \n          const compareValue = rule.value;\n          console.log('Branch eval (loop): Comparing', propValue, rule.op, compareValue);\n          \n          // Handle array responses (multi-select or single-select returned as array)\n          if (Array.isArray(propValue)) {\n            const matches = propValue.includes(compareValue) || propValue.includes(String(compareValue));\n            console.log('Branch eval (loop): Array comparison result', matches);\n            switch (rule.op) {\n              case '==':\n                return matches;\n              case '!=':\n                return !matches;\n              default:\n                return false;\n            }\n          }\n          \n          // Convertir valores para comparación\n          const numPropValue = parseFloat(propValue);\n          const numCompareValue = parseFloat(compareValue);\n          const isNumeric = !isNaN(numPropValue) && !isNaN(numCompareValue);\n          \n          switch (rule.op) {\n            case '==':\n              return isNumeric ? numPropValue === numCompareValue : propValue == compareValue;\n            case '!=':\n              return isNumeric ? numPropValue !== numCompareValue : propValue != compareValue;\n            case '>':\n              return isNumeric && numPropValue > numCompareValue;\n            case '<':\n              return isNumeric && numPropValue < numCompareValue;\n            case '>=':\n              return isNumeric && numPropValue >= numCompareValue;\n            case '<=':\n              return isNumeric && numPropValue <= numCompareValue;\n            default:\n              return false;\n          }\n        });\n        \n        if (allRulesMatch) {\n          console.log('✅ [LOOP BRANCH] Condition matched! Next trial:', condition.nextTrialId);\n          nextTrialId = condition.nextTrialId;\n          // Store custom parameters if they exist\n          if (condition.customParameters) {\n            matchedCustomParameters = condition.customParameters;\n            console.log('✅ [LOOP BRANCH] Custom parameters:', matchedCustomParameters);\n          }\n          break;\n        }\n      }\n      \n      // Si se encontró match, activar branching\n      if (nextTrialId) {\n        console.log('🎯 [LOOP BRANCH] Activating branching to trial:', nextTrialId);\n        loop_loop_1769054420851_NextTrialId = nextTrialId;\n        loop_loop_1769054420851_SkipRemaining = true;\n        loop_loop_1769054420851_BranchingActive = true;\n        // Store custom parameters for the next trial in the loop\n        if (matchedCustomParameters) {\n          loop_loop_1769054420851_BranchCustomParameters = matchedCustomParameters;\n        }\n      } else {\n        // No match - ir al primer branch por defecto\n        console.log('⚠️ [LOOP BRANCH] No condition matched, branching to first branch:', branches[0]);\n        loop_loop_1769054420851_NextTrialId = branches[0];\n        loop_loop_1769054420851_SkipRemaining = true;\n        loop_loop_1769054420851_BranchingActive = true;\n      }\n      \n    },};\n\n\n\n    \n    const New_Trial_3_timeline = {\n    type: DynamicPlugin, components: jsPsych.timelineVariable(\"components_New_Trial_3\"),\nresponse_components: jsPsych.timelineVariable(\"response_components_New_Trial_3\"),\n      data: {\n        rt: \"rt_New_Trial_3\",\n        trial_id: 1769054417382,\n        isInLoop: true,\n        \n      },\n    on_start: function(trial) {\n      // Then apply custom parameters from branching conditions (higher priority)\n      // For trials in loops, use loop-specific BranchCustomParameters\n      if (typeof loop_loop_1769054420851_BranchCustomParameters !== 'undefined' && loop_loop_1769054420851_BranchCustomParameters && typeof loop_loop_1769054420851_BranchCustomParameters === 'object') {\n        Object.entries(loop_loop_1769054420851_BranchCustomParameters).forEach(([key, param]) => {\n          if (param && param.source !== 'none') {\n            // Parse key to check if it's a nested survey question\n            const parts = key.split('::');\n            \n            if (parts.length === 4) {\n              // Format: fieldType::componentName::survey_json::questionName\n              const [fieldType, componentName, propName, questionName] = parts;\n              \n              if (fieldType && componentName && propName === 'survey_json' && questionName) {\n                // Find the component by name in the field array\n                const fieldArray = trial[fieldType];\n                if (Array.isArray(fieldArray)) {\n                  const compIndex = fieldArray.findIndex(c => c.name === componentName);\n                  if (compIndex !== -1 && fieldArray[compIndex].survey_json) {\n                    // Find the question in survey_json.elements\n                    const elements = fieldArray[compIndex].survey_json.elements || [];\n                    const questionIndex = elements.findIndex(q => q.name === questionName);\n                    \n                    if (questionIndex !== -1) {\n                      // Apply the override value (from typed or csv)\n                      let valueToSet;\n                      if (param.source === 'typed') {\n                        valueToSet = String(param.value); // Convert to string for SurveyJS\n                      } else if (param.source === 'csv') {\n                        valueToSet = String(trial[param.value]); // Get from CSV column and convert to string\n                      }\n                      \n                      if (valueToSet !== undefined && valueToSet !== null) {\n                        fieldArray[compIndex].survey_json.elements[questionIndex].defaultValue = valueToSet;\n                      }\n                    }\n                  }\n                }\n              }\n            } else if (parts.length === 3) {\n              // Format: fieldType::componentName::property (for DynamicPlugin components)\n              const [fieldType, componentName, propName] = parts;\n              \n              if (fieldType && componentName && propName) {\n                // Find the component by name in the field array\n                const fieldArray = trial[fieldType];\n                if (Array.isArray(fieldArray)) {\n                  const compIndex = fieldArray.findIndex(c => c.name === componentName);\n                  if (compIndex !== -1) {\n                    // Apply the override value (from typed or csv)\n                    let valueToSet;\n                    if (param.source === 'typed') {\n                      valueToSet = param.value;\n                    } else if (param.source === 'csv') {\n                      valueToSet = trial[param.value];\n                    }\n                    \n                    if (valueToSet !== undefined && valueToSet !== null) {\n                      fieldArray[compIndex][propName] = valueToSet;\n                    }\n                  }\n                }\n              }\n            } else {\n              // Normal parameter (not nested survey question)\n              if (param.source === 'typed' && param.value !== undefined && param.value !== null) {\n                trial[key] = param.value;\n              } else if (param.source === 'csv' && param.value !== undefined && param.value !== null) {\n                trial[key] = trial[param.value];\n              }\n            }\n          }\n        });\n        // Clear the custom parameters after applying them\n        loop_loop_1769054420851_BranchCustomParameters = null;\n      }\n      \n    },\n    on_finish: function(data) {\n      // Este trial no tiene branches ni repeat conditions, verificar si el loop padre tiene branches\n      if (typeof loop_loop_1769054420851_HasBranches !== 'undefined' && loop_loop_1769054420851_HasBranches) {\n        // El loop tiene branches, activar branching del loop al terminar\n        // Esto se manejará en el on_finish del loop\n        loop_loop_1769054420851_ShouldBranchOnFinish = true;\n      } else if (!loop_loop_1769054420851_HasBranches) {\n        // Ni el trial ni el loop tienen branches - trial terminal\n        // Si llegamos aquí después de un branching global, terminar el experimento\n        if (window.branchingActive) {\n          jsPsych.abortExperiment('', {});\n        }\n      }\n    },};\n\n\n\n\n    const test_stimuli_loop_1769054430260 = [\n  {\n    \"components_New_Tridalb_4\": [\n      {\n        \"type\": \"HtmlComponent\",\n        \"coordinates\": {\n          \"x\": 0,\n          \"y\": 0\n        },\n        \"width\": 200,\n        \"height\": 50,\n        \"name\": \"HtmlComponent_1\",\n        \"stimulus\": \"<div id=\\\"ik2w\\\" style=\\\"box-sizing: border-box;\\\">seguro nested loop?</div>\"\n      }\n    ],\n    \"response_components_New_Tridalb_4\": [\n      {\n        \"type\": \"ButtonResponseComponent\",\n        \"coordinates\": {\n          \"x\": -0.004098360655737765,\n          \"y\": 0.273224043715847\n        },\n        \"width\": 200,\n        \"height\": 50,\n        \"name\": \"ButtonResponseComponent_1\",\n        \"choices\": [\n          \"si\",\n          \"no\"\n        ]\n      }\n    ],\n    \"components_New_Trial_5\": [\n      {\n        \"type\": \"HtmlComponent\",\n        \"coordinates\": {\n          \"x\": 0,\n          \"y\": 0\n        },\n        \"width\": 200,\n        \"height\": 50,\n        \"name\": \"HtmlComponent_1\",\n        \"stimulus\": \"<div id=\\\"ityh\\\" style=\\\"box-sizing: border-box;\\\">pues no dentro de nested loop</div>\"\n      }\n    ],\n    \"response_components_New_Trial_5\": [\n      {\n        \"type\": \"ButtonResponseComponent\",\n        \"coordinates\": {\n          \"x\": 0,\n          \"y\": 0.30601092896174853\n        },\n        \"width\": 200,\n        \"height\": 50,\n        \"name\": \"ButtonResponseComponent_1\",\n        \"choices\": [\n          \"ok\"\n        ]\n      }\n    ],\n    \"components_nonested\": [\n      {\n        \"type\": \"HtmlComponent\",\n        \"coordinates\": {\n          \"x\": 0,\n          \"y\": 0\n        },\n        \"width\": 200,\n        \"height\": 50,\n        \"name\": \"HtmlComponent_1\",\n        \"stimulus\": \"<div id=\\\"ic4v\\\" style=\\\"box-sizing: border-box;\\\">este no es nested</div>\"\n      }\n    ],\n    \"response_components_nonested\": [\n      {\n        \"type\": \"ButtonResponseComponent\",\n        \"coordinates\": {\n          \"x\": 0,\n          \"y\": 0.30054644808743164\n        },\n        \"width\": 200,\n        \"height\": 50,\n        \"name\": \"ButtonResponseComponent_1\",\n        \"choices\": [\n          \"ok\"\n        ]\n      }\n    ],\n    \"components_saliendodenested\": [\n      {\n        \"type\": \"HtmlComponent\",\n        \"coordinates\": {\n          \"x\": 0,\n          \"y\": 0\n        },\n        \"width\": 200,\n        \"height\": 50,\n        \"name\": \"HtmlComponent_1\",\n        \"stimulus\": \"<div id=\\\"iyg7\\\" style=\\\"box-sizing: border-box;\\\">saliendo de nested</div>\"\n      }\n    ],\n    \"response_components_saliendodenested\": [\n      {\n        \"type\": \"ButtonResponseComponent\",\n        \"coordinates\": {\n          \"x\": -0.004098360655737765,\n          \"y\": 0.27322404371584685\n        },\n        \"width\": 200,\n        \"height\": 50,\n        \"name\": \"ButtonResponseComponent_1\",\n        \"choices\": [\n          \"ok\"\n        ]\n      }\n    ]\n  }\n];\n    \n    \n    \n    const New_Tridalb_4_timeline = {\n    type: DynamicPlugin, components: jsPsych.timelineVariable(\"components_New_Tridalb_4\"),\nresponse_components: jsPsych.timelineVariable(\"response_components_New_Tridalb_4\"),\n      data: {\n        rt: \"rt_New_Tridalb_4\",\n        trial_id: 1769054425182,\n        isInLoop: true,\n        \n        branches: [1769054426032, 1769110039675],\n        branchConditions: [[{\"id\":1769054911466,\"rules\":[{\"column\":\"ButtonResponseComponent_1_response\",\"op\":\"==\",\"value\":\"si\",\"fieldType\":\"response_components\",\"componentIdx\":\"ButtonResponseComponent_1\",\"prop\":\"response\"}],\"nextTrialId\":\"1769110039675\",\"customParameters\":{}},{\"id\":1769054925882,\"rules\":[{\"column\":\"ButtonResponseComponent_1_response\",\"op\":\"==\",\"value\":\"no\",\"fieldType\":\"response_components\",\"componentIdx\":\"ButtonResponseComponent_1\",\"prop\":\"response\"}],\"nextTrialId\":\"1769054426032\",\"customParameters\":{}}]] \n        \n      },\n    on_start: function(trial) {\n      // Then apply custom parameters from branching conditions (higher priority)\n      // For trials in loops, use loop-specific BranchCustomParameters\n      if (typeof loop_loop_1769054430260_BranchCustomParameters !== 'undefined' && loop_loop_1769054430260_BranchCustomParameters && typeof loop_loop_1769054430260_BranchCustomParameters === 'object') {\n        Object.entries(loop_loop_1769054430260_BranchCustomParameters).forEach(([key, param]) => {\n          if (param && param.source !== 'none') {\n            // Parse key to check if it's a nested survey question\n            const parts = key.split('::');\n            \n            if (parts.length === 4) {\n              // Format: fieldType::componentName::survey_json::questionName\n              const [fieldType, componentName, propName, questionName] = parts;\n              \n              if (fieldType && componentName && propName === 'survey_json' && questionName) {\n                // Find the component by name in the field array\n                const fieldArray = trial[fieldType];\n                if (Array.isArray(fieldArray)) {\n                  const compIndex = fieldArray.findIndex(c => c.name === componentName);\n                  if (compIndex !== -1 && fieldArray[compIndex].survey_json) {\n                    // Find the question in survey_json.elements\n                    const elements = fieldArray[compIndex].survey_json.elements || [];\n                    const questionIndex = elements.findIndex(q => q.name === questionName);\n                    \n                    if (questionIndex !== -1) {\n                      // Apply the override value (from typed or csv)\n                      let valueToSet;\n                      if (param.source === 'typed') {\n                        valueToSet = String(param.value); // Convert to string for SurveyJS\n                      } else if (param.source === 'csv') {\n                        valueToSet = String(trial[param.value]); // Get from CSV column and convert to string\n                      }\n                      \n                      if (valueToSet !== undefined && valueToSet !== null) {\n                        fieldArray[compIndex].survey_json.elements[questionIndex].defaultValue = valueToSet;\n                      }\n                    }\n                  }\n                }\n              }\n            } else if (parts.length === 3) {\n              // Format: fieldType::componentName::property (for DynamicPlugin components)\n              const [fieldType, componentName, propName] = parts;\n              \n              if (fieldType && componentName && propName) {\n                // Find the component by name in the field array\n                const fieldArray = trial[fieldType];\n                if (Array.isArray(fieldArray)) {\n                  const compIndex = fieldArray.findIndex(c => c.name === componentName);\n                  if (compIndex !== -1) {\n                    // Apply the override value (from typed or csv)\n                    let valueToSet;\n                    if (param.source === 'typed') {\n                      valueToSet = param.value;\n                    } else if (param.source === 'csv') {\n                      valueToSet = trial[param.value];\n                    }\n                    \n                    if (valueToSet !== undefined && valueToSet !== null) {\n                      fieldArray[compIndex][propName] = valueToSet;\n                    }\n                  }\n                }\n              }\n            } else {\n              // Normal parameter (not nested survey question)\n              if (param.source === 'typed' && param.value !== undefined && param.value !== null) {\n                trial[key] = param.value;\n              } else if (param.source === 'csv' && param.value !== undefined && param.value !== null) {\n                trial[key] = trial[param.value];\n              }\n            }\n          }\n        });\n        // Clear the custom parameters after applying them\n        loop_loop_1769054430260_BranchCustomParameters = null;\n      }\n      \n    },\n    on_finish: function(data) {\n      // Evaluar condiciones del trial para branching interno del loop\n      console.log('🔍 [LOOP BRANCH] Evaluating branch conditions...');\n      const branches = [1769054426032, 1769110039675];\n      const branchConditions = [{\"id\":1769054911466,\"rules\":[{\"column\":\"ButtonResponseComponent_1_response\",\"op\":\"==\",\"value\":\"si\",\"fieldType\":\"response_components\",\"componentIdx\":\"ButtonResponseComponent_1\",\"prop\":\"response\"}],\"nextTrialId\":\"1769110039675\",\"customParameters\":{}},{\"id\":1769054925882,\"rules\":[{\"column\":\"ButtonResponseComponent_1_response\",\"op\":\"==\",\"value\":\"no\",\"fieldType\":\"response_components\",\"componentIdx\":\"ButtonResponseComponent_1\",\"prop\":\"response\"}],\"nextTrialId\":\"1769054426032\",\"customParameters\":{}}].flat();\n      console.log('🔍 [LOOP BRANCH] Available branches:', branches);\n      console.log('🔍 [LOOP BRANCH] Conditions to evaluate:', branchConditions.length);\n      \n      let nextTrialId = null;\n      let matchedCustomParameters = null;\n      \n      // Evaluar cada condición (lógica OR entre condiciones)\n      for (const condition of branchConditions) {\n        if (!condition || !condition.rules) {\n          continue;\n        }\n        \n        // Todas las reglas en una condición deben ser verdaderas (lógica AND)\n        const allRulesMatch = condition.rules.every(rule => {\n          let propValue;\n          \n          // Parse column name to extract component info for dynamic plugins\n          // Format: \"componentName_propertyName\" or \"componentName_questionName\" for surveys\n          const columnName = rule.column || rule.prop || \"\";\n          const parts = columnName.split(\"_\");\n          \n          // Check if this looks like a dynamic plugin column (has underscore)\n          if (parts.length >= 2) {\n            // Last part is the property or question name\n            const propertyOrQuestion = parts[parts.length - 1];\n            // Everything before the last underscore is the component name\n            const componentName = parts.slice(0, -1).join(\"_\");\n            \n            // Try to find the data in the format: componentName_response\n            const responseKey = componentName + '_response';\n            const responseData = data[responseKey];\n            \n            console.log('Branch eval (loop): Checking column', columnName);\n            console.log('Branch eval (loop): Component name:', componentName, 'Property:', propertyOrQuestion);\n            console.log('Branch eval (loop): Looking for response key:', responseKey);\n            console.log('Branch eval (loop): Response data:', responseData);\n            \n            // If response data exists and is an object (SurveyComponent case)\n            if (responseData && typeof responseData === 'object' && !Array.isArray(responseData)) {\n              // This is likely a survey response - check if property is a question name\n              if (responseData[propertyOrQuestion] !== undefined) {\n                propValue = responseData[propertyOrQuestion];\n                console.log('Branch eval (loop): Found survey question response', propertyOrQuestion, '=', propValue);\n              } else {\n                console.log('Branch eval (loop): Survey question not found:', propertyOrQuestion);\n                return false;\n              }\n            } else {\n              // Not a survey response object, try direct property access\n              const directKey = componentName + '_' + propertyOrQuestion;\n              if (data[directKey] !== undefined) {\n                propValue = data[directKey];\n                console.log('Branch eval (loop): Found direct property', directKey, '=', propValue);\n              } else {\n                console.log('Branch eval (loop): Property not found:', directKey);\n                return false;\n              }\n            }\n          } else {\n            // Normal plugin structure - direct property access\n            propValue = data[columnName];\n            console.log('Branch eval (loop): Direct property access', columnName, '=', propValue);\n          }\n          \n          const compareValue = rule.value;\n          console.log('Branch eval (loop): Comparing', propValue, rule.op, compareValue);\n          \n          // Handle array responses (multi-select or single-select returned as array)\n          if (Array.isArray(propValue)) {\n            const matches = propValue.includes(compareValue) || propValue.includes(String(compareValue));\n            console.log('Branch eval (loop): Array comparison result', matches);\n            switch (rule.op) {\n              case '==':\n                return matches;\n              case '!=':\n                return !matches;\n              default:\n                return false;\n            }\n          }\n          \n          // Convertir valores para comparación\n          const numPropValue = parseFloat(propValue);\n          const numCompareValue = parseFloat(compareValue);\n          const isNumeric = !isNaN(numPropValue) && !isNaN(numCompareValue);\n          \n          switch (rule.op) {\n            case '==':\n              return isNumeric ? numPropValue === numCompareValue : propValue == compareValue;\n            case '!=':\n              return isNumeric ? numPropValue !== numCompareValue : propValue != compareValue;\n            case '>':\n              return isNumeric && numPropValue > numCompareValue;\n            case '<':\n              return isNumeric && numPropValue < numCompareValue;\n            case '>=':\n              return isNumeric && numPropValue >= numCompareValue;\n            case '<=':\n              return isNumeric && numPropValue <= numCompareValue;\n            default:\n              return false;\n          }\n        });\n        \n        if (allRulesMatch) {\n          console.log('✅ [LOOP BRANCH] Condition matched! Next trial:', condition.nextTrialId);\n          nextTrialId = condition.nextTrialId;\n          // Store custom parameters if they exist\n          if (condition.customParameters) {\n            matchedCustomParameters = condition.customParameters;\n            console.log('✅ [LOOP BRANCH] Custom parameters:', matchedCustomParameters);\n          }\n          break;\n        }\n      }\n      \n      // Si se encontró match, activar branching\n      if (nextTrialId) {\n        console.log('🎯 [LOOP BRANCH] Activating branching to trial:', nextTrialId);\n        loop_loop_1769054430260_NextTrialId = nextTrialId;\n        loop_loop_1769054430260_SkipRemaining = true;\n        loop_loop_1769054430260_BranchingActive = true;\n        // Store custom parameters for the next trial in the loop\n        if (matchedCustomParameters) {\n          loop_loop_1769054430260_BranchCustomParameters = matchedCustomParameters;\n        }\n      } else {\n        // No match - ir al primer branch por defecto\n        console.log('⚠️ [LOOP BRANCH] No condition matched, branching to first branch:', branches[0]);\n        loop_loop_1769054430260_NextTrialId = branches[0];\n        loop_loop_1769054430260_SkipRemaining = true;\n        loop_loop_1769054430260_BranchingActive = true;\n      }\n      \n    },};\n\n\n\n    \n    const New_Trial_5_timeline = {\n    type: DynamicPlugin, components: jsPsych.timelineVariable(\"components_New_Trial_5\"),\nresponse_components: jsPsych.timelineVariable(\"response_components_New_Trial_5\"),\n      data: {\n        rt: \"rt_New_Trial_5\",\n        trial_id: 1769054426032,\n        isInLoop: true,\n        \n      },\n    on_start: function(trial) {\n      // Then apply custom parameters from branching conditions (higher priority)\n      // For trials in loops, use loop-specific BranchCustomParameters\n      if (typeof loop_loop_1769054430260_BranchCustomParameters !== 'undefined' && loop_loop_1769054430260_BranchCustomParameters && typeof loop_loop_1769054430260_BranchCustomParameters === 'object') {\n        Object.entries(loop_loop_1769054430260_BranchCustomParameters).forEach(([key, param]) => {\n          if (param && param.source !== 'none') {\n            // Parse key to check if it's a nested survey question\n            const parts = key.split('::');\n            \n            if (parts.length === 4) {\n              // Format: fieldType::componentName::survey_json::questionName\n              const [fieldType, componentName, propName, questionName] = parts;\n              \n              if (fieldType && componentName && propName === 'survey_json' && questionName) {\n                // Find the component by name in the field array\n                const fieldArray = trial[fieldType];\n                if (Array.isArray(fieldArray)) {\n                  const compIndex = fieldArray.findIndex(c => c.name === componentName);\n                  if (compIndex !== -1 && fieldArray[compIndex].survey_json) {\n                    // Find the question in survey_json.elements\n                    const elements = fieldArray[compIndex].survey_json.elements || [];\n                    const questionIndex = elements.findIndex(q => q.name === questionName);\n                    \n                    if (questionIndex !== -1) {\n                      // Apply the override value (from typed or csv)\n                      let valueToSet;\n                      if (param.source === 'typed') {\n                        valueToSet = String(param.value); // Convert to string for SurveyJS\n                      } else if (param.source === 'csv') {\n                        valueToSet = String(trial[param.value]); // Get from CSV column and convert to string\n                      }\n                      \n                      if (valueToSet !== undefined && valueToSet !== null) {\n                        fieldArray[compIndex].survey_json.elements[questionIndex].defaultValue = valueToSet;\n                      }\n                    }\n                  }\n                }\n              }\n            } else if (parts.length === 3) {\n              // Format: fieldType::componentName::property (for DynamicPlugin components)\n              const [fieldType, componentName, propName] = parts;\n              \n              if (fieldType && componentName && propName) {\n                // Find the component by name in the field array\n                const fieldArray = trial[fieldType];\n                if (Array.isArray(fieldArray)) {\n                  const compIndex = fieldArray.findIndex(c => c.name === componentName);\n                  if (compIndex !== -1) {\n                    // Apply the override value (from typed or csv)\n                    let valueToSet;\n                    if (param.source === 'typed') {\n                      valueToSet = param.value;\n                    } else if (param.source === 'csv') {\n                      valueToSet = trial[param.value];\n                    }\n                    \n                    if (valueToSet !== undefined && valueToSet !== null) {\n                      fieldArray[compIndex][propName] = valueToSet;\n                    }\n                  }\n                }\n              }\n            } else {\n              // Normal parameter (not nested survey question)\n              if (param.source === 'typed' && param.value !== undefined && param.value !== null) {\n                trial[key] = param.value;\n              } else if (param.source === 'csv' && param.value !== undefined && param.value !== null) {\n                trial[key] = trial[param.value];\n              }\n            }\n          }\n        });\n        // Clear the custom parameters after applying them\n        loop_loop_1769054430260_BranchCustomParameters = null;\n      }\n      \n    },\n    on_finish: function(data) {\n      // Evaluar repeat conditions (para reiniciar el experimento desde un trial específico)\n      const repeatConditionsArray = [{\"id\":1769124654889,\"rules\":[{\"column\":\"\",\"op\":\"==\",\"value\":\"ok\",\"fieldType\":\"response_components\",\"componentIdx\":\"ButtonResponseComponent_1\",\"prop\":\"response\"}],\"jumpToTrialId\":\"1769054417382\"},{\"id\":1769124654889,\"rules\":[{\"column\":\"\",\"op\":\"==\",\"value\":\"\"}],\"jumpToTrialId\":\"1769054417382\"}];\n      \n      let shouldRepeat = false;\n      for (const condition of repeatConditionsArray) {\n        if (!condition || !condition.rules) {\n          continue;\n        }\n        \n        // Todas las reglas en una condición deben ser verdaderas (lógica AND)\n        const allRulesMatch = condition.rules.every(rule => {\n          // Construct column name if empty (for dynamic plugins)\n          let columnName = rule.column || \"\";\n          if (!columnName && rule.componentIdx && rule.prop) {\n            columnName = rule.componentIdx + '_' + rule.prop;\n          }\n          \n          // Get the property value using the column name\n          const propValue = data[columnName || rule.prop];\n          const compareValue = rule.value;\n          \n          // Handle array responses (multi-select questions)\n          if (Array.isArray(propValue)) {\n            // For array values, check if compareValue is included in the array\n            switch (rule.op) {\n              case '==':\n                return propValue.includes(compareValue);\n              case '!=':\n                return !propValue.includes(compareValue);\n              default:\n                return false; // Comparison operators don't make sense for arrays\n            }\n          }\n          \n          // Convertir valores para comparación (for non-array values)\n          const numPropValue = parseFloat(propValue);\n          const numCompareValue = parseFloat(compareValue);\n          const isNumeric = !isNaN(numPropValue) && !isNaN(numCompareValue);\n          \n          switch (rule.op) {\n            case '==':\n              return isNumeric ? numPropValue === numCompareValue : propValue == compareValue;\n            case '!=':\n              return isNumeric ? numPropValue !== numCompareValue : propValue != compareValue;\n            case '>':\n              return isNumeric && numPropValue > numCompareValue;\n            case '<':\n              return isNumeric && numPropValue < numCompareValue;\n            case '>=':\n              return isNumeric && numPropValue >= numCompareValue;\n            case '<=':\n              return isNumeric && numPropValue <= numCompareValue;\n            default:\n              return false;\n          }\n        });\n        \n        if (allRulesMatch && condition.jumpToTrialId) {\n          console.log('Repeat condition matched! Jumping to trial:', condition.jumpToTrialId);\n          // Guardar el trial objetivo en localStorage\n          localStorage.setItem('jsPsych_jumpToTrial', String(condition.jumpToTrialId));\n          shouldRepeat = true;\n          break;\n        }\n      }\n      \n      if (shouldRepeat) {\n        // Limpiar el contenedor de jsPsych (jspsych-container es el display_element)\n        const container = document.getElementById('jspsych-container');\n        if (container) {\n          // Limpiar todo el contenido del container\n          container.innerHTML = '';\n        }\n        // Reiniciar el timeline\n        setTimeout(() => {\n          jsPsych.run(timeline);\n        }, 100);\n        return;\n      }\n      \n      // Este trial no tiene branches, verificar si el loop padre tiene branches\n      if (typeof loop_loop_1769054430260_HasBranches !== 'undefined' && loop_loop_1769054430260_HasBranches) {\n        // El loop tiene branches, activar branching del loop al terminar\n        // Esto se manejará en el on_finish del loop\n        loop_loop_1769054430260_ShouldBranchOnFinish = true;\n      } else if (!loop_loop_1769054430260_HasBranches) {\n        // Ni el trial ni el loop tienen branches - trial terminal\n        // Si llegamos aquí después de un branching global, terminar el experimento\n        if (window.branchingActive) {\n          jsPsych.abortExperiment('', {});\n        }\n      }\n    },};\n\n\n\n    \n    const nonested_timeline = {\n    type: DynamicPlugin, components: jsPsych.timelineVariable(\"components_nonested\"),\nresponse_components: jsPsych.timelineVariable(\"response_components_nonested\"),\n      data: {\n        rt: \"rt_nonested\",\n        trial_id: 1769110039675,\n        isInLoop: true,\n        \n        branches: [1769110050795],\n        branchConditions: [undefined] \n        \n      },\n    on_start: function(trial) {\n      // Then apply custom parameters from branching conditions (higher priority)\n      // For trials in loops, use loop-specific BranchCustomParameters\n      if (typeof loop_loop_1769054420851_BranchCustomParameters !== 'undefined' && loop_loop_1769054420851_BranchCustomParameters && typeof loop_loop_1769054420851_BranchCustomParameters === 'object') {\n        Object.entries(loop_loop_1769054420851_BranchCustomParameters).forEach(([key, param]) => {\n          if (param && param.source !== 'none') {\n            // Parse key to check if it's a nested survey question\n            const parts = key.split('::');\n            \n            if (parts.length === 4) {\n              // Format: fieldType::componentName::survey_json::questionName\n              const [fieldType, componentName, propName, questionName] = parts;\n              \n              if (fieldType && componentName && propName === 'survey_json' && questionName) {\n                // Find the component by name in the field array\n                const fieldArray = trial[fieldType];\n                if (Array.isArray(fieldArray)) {\n                  const compIndex = fieldArray.findIndex(c => c.name === componentName);\n                  if (compIndex !== -1 && fieldArray[compIndex].survey_json) {\n                    // Find the question in survey_json.elements\n                    const elements = fieldArray[compIndex].survey_json.elements || [];\n                    const questionIndex = elements.findIndex(q => q.name === questionName);\n                    \n                    if (questionIndex !== -1) {\n                      // Apply the override value (from typed or csv)\n                      let valueToSet;\n                      if (param.source === 'typed') {\n                        valueToSet = String(param.value); // Convert to string for SurveyJS\n                      } else if (param.source === 'csv') {\n                        valueToSet = String(trial[param.value]); // Get from CSV column and convert to string\n                      }\n                      \n                      if (valueToSet !== undefined && valueToSet !== null) {\n                        fieldArray[compIndex].survey_json.elements[questionIndex].defaultValue = valueToSet;\n                      }\n                    }\n                  }\n                }\n              }\n            } else if (parts.length === 3) {\n              // Format: fieldType::componentName::property (for DynamicPlugin components)\n              const [fieldType, componentName, propName] = parts;\n              \n              if (fieldType && componentName && propName) {\n                // Find the component by name in the field array\n                const fieldArray = trial[fieldType];\n                if (Array.isArray(fieldArray)) {\n                  const compIndex = fieldArray.findIndex(c => c.name === componentName);\n                  if (compIndex !== -1) {\n                    // Apply the override value (from typed or csv)\n                    let valueToSet;\n                    if (param.source === 'typed') {\n                      valueToSet = param.value;\n                    } else if (param.source === 'csv') {\n                      valueToSet = trial[param.value];\n                    }\n                    \n                    if (valueToSet !== undefined && valueToSet !== null) {\n                      fieldArray[compIndex][propName] = valueToSet;\n                    }\n                  }\n                }\n              }\n            } else {\n              // Normal parameter (not nested survey question)\n              if (param.source === 'typed' && param.value !== undefined && param.value !== null) {\n                trial[key] = param.value;\n              } else if (param.source === 'csv' && param.value !== undefined && param.value !== null) {\n                trial[key] = trial[param.value];\n              }\n            }\n          }\n        });\n        // Clear the custom parameters after applying them\n        loop_loop_1769054420851_BranchCustomParameters = null;\n      }\n      \n    },\n    on_finish: function(data) {\n      // Branching automático al primer branch (dentro del loop)\n      const branches = [1769110050795];\n      if (branches.length > 0) {\n        console.log('🔄 [LOOP BRANCH] Auto-branching to first branch:', branches[0]);\n        loop_loop_1769054420851_NextTrialId = branches[0];\n        loop_loop_1769054420851_SkipRemaining = true;\n        loop_loop_1769054420851_BranchingActive = true;\n      }\n      \n    },};\n\n\n\n    \n    const saliendodenested_timeline = {\n    type: DynamicPlugin, components: jsPsych.timelineVariable(\"components_saliendodenested\"),\nresponse_components: jsPsych.timelineVariable(\"response_components_saliendodenested\"),\n      data: {\n        rt: \"rt_saliendodenested\",\n        trial_id: 1769110050795,\n        isInLoop: true,\n        \n      },\n    on_start: function(trial) {\n      // First, evaluate and apply params override conditions (if any)\n      const paramsOverrideConditions = [{\"id\":1769123332813,\"rules\":[{\"trialId\":\"\",\"column\":\"\",\"op\":\"==\",\"value\":\"\",\"prop\":\"\"}],\"paramsToOverride\":{}}];\n      \n      // Evaluate params override conditions\n      for (const condition of paramsOverrideConditions) {\n        if (!condition || !condition.rules) {\n          continue;\n        }\n        \n        // Get data from all previous trials\n        const allData = jsPsych.data.get().values();\n        \n        // Check if all rules match (AND logic within condition)\n        const allRulesMatch = condition.rules.every(rule => {\n          if (!rule.trialId) {\n            return false;\n          }\n          \n          // Find data from the referenced trial\n          const trialData = allData.filter(d => {\n            // Compare both as strings to handle type mismatches\n            return String(d.trial_id) === String(rule.trialId) || d.trial_id === rule.trialId;\n          });\n          if (trialData.length === 0) {\n            return false;\n          }\n          \n          // Use the most recent data if multiple exist\n          const data = trialData[trialData.length - 1];\n          \n          // Construct column name if empty (for dynamic plugins)\n          let columnName = rule.column || \"\";\n          if (!columnName && rule.componentIdx && rule.prop) {\n            columnName = rule.componentIdx + '_' + rule.prop;\n          }\n          \n          // Get the property value using the column name\n          const propValue = data[columnName || rule.prop];\n          const compareValue = rule.value;\n          \n          // Handle array responses (multi-select questions)\n          if (Array.isArray(propValue)) {\n            // For array values, check if compareValue is included in the array\n            switch (rule.op) {\n              case '==':\n                return propValue.includes(compareValue);\n              case '!=':\n                return !propValue.includes(compareValue);\n              default:\n                return false; // Comparison operators don't make sense for arrays\n            }\n          }\n          \n          // Convert values for comparison (for non-array values)\n          const numPropValue = parseFloat(propValue);\n          const numCompareValue = parseFloat(compareValue);\n          const isNumeric = !isNaN(numPropValue) && !isNaN(numCompareValue);\n          \n          switch (rule.op) {\n            case '==':\n              return isNumeric ? numPropValue === numCompareValue : propValue == compareValue;\n            case '!=':\n              return isNumeric ? numPropValue !== numCompareValue : propValue != compareValue;\n            case '>':\n              return isNumeric && numPropValue > numCompareValue;\n            case '<':\n              return isNumeric && numPropValue < numCompareValue;\n            case '>=':\n              return isNumeric && numPropValue >= numCompareValue;\n            case '<=':\n              return isNumeric && numPropValue <= numCompareValue;\n            default:\n              return false;\n          }\n        });\n        \n        // If all rules match, apply parameter overrides\n        if (allRulesMatch && condition.paramsToOverride) {\n          Object.entries(condition.paramsToOverride).forEach(([key, param]) => {\n            if (param && param.source !== 'none') {\n              // Parse key to check structure\n              const parts = key.split('::');\n              \n              if (parts.length === 4) {\n                // Format: fieldType::componentName::survey_json::questionName\n                const [fieldType, componentName, propName, questionName] = parts;\n                \n                if (fieldType && componentName && propName === 'survey_json' && questionName) {\n                  // Find the component by name in the field array\n                  const fieldArray = trial[fieldType];\n                  \n                  if (Array.isArray(fieldArray)) {\n                    const compIndex = fieldArray.findIndex(c => c.name === componentName);\n                    \n                    if (compIndex !== -1 && fieldArray[compIndex].survey_json) {\n                      // Find the question in survey_json.elements\n                      const elements = fieldArray[compIndex].survey_json.elements || [];\n                      const questionIndex = elements.findIndex(q => q.name === questionName);\n                      \n                      if (questionIndex !== -1) {\n                        // Apply the override value (from typed or csv)\n                        let valueToSet;\n                        if (param.source === 'typed') {\n                          valueToSet = String(param.value); // Convert to string for SurveyJS\n                        } else if (param.source === 'csv') {\n                          valueToSet = String(trial[param.value]); // Get from CSV column and convert to string\n                        }\n                        \n                        if (valueToSet !== undefined && valueToSet !== null) {\n                          fieldArray[compIndex].survey_json.elements[questionIndex].defaultValue = valueToSet;\n                        }\n                      }\n                    }\n                  }\n                }\n              } else if (parts.length === 3) {\n                // Format: fieldType::componentName::property (for dynamic plugin components like ButtonResponseComponent)\n                const [fieldType, componentName, propName] = parts;\n                \n                if (fieldType && componentName && propName) {\n                  // Find the component by name in the field array\n                  const fieldArray = trial[fieldType];\n                  \n                  if (Array.isArray(fieldArray)) {\n                    const compIndex = fieldArray.findIndex(c => c.name === componentName);\n                    \n                    if (compIndex !== -1) {\n                      // Apply the override value\n                      let valueToSet;\n                      if (param.source === 'typed') {\n                        valueToSet = param.value;\n                      } else if (param.source === 'csv') {\n                        valueToSet = trial[param.value]; // Get from CSV column\n                      }\n                      \n                      if (valueToSet !== undefined && valueToSet !== null) {\n                        fieldArray[compIndex][propName] = valueToSet;\n                      }\n                    }\n                  }\n                }\n              } else {\n                // Normal parameter (not nested)\n                if (param.source === 'typed' && param.value !== undefined && param.value !== null) {\n                  trial[key] = param.value;\n                } else if (param.source === 'csv' && param.value !== undefined && param.value !== null) {\n                  // For CSV source, param.value contains the column name, get the actual value from trial\n                  trial[key] = trial[param.value];\n                }\n              }\n            }\n          });\n          // Break after first matching condition (OR logic between conditions)\n          break;\n        }\n      }\n      \n      // Then apply custom parameters from branching conditions (higher priority)\n      // For trials in loops, use loop-specific BranchCustomParameters\n      if (typeof loop_loop_1769054420851_BranchCustomParameters !== 'undefined' && loop_loop_1769054420851_BranchCustomParameters && typeof loop_loop_1769054420851_BranchCustomParameters === 'object') {\n        Object.entries(loop_loop_1769054420851_BranchCustomParameters).forEach(([key, param]) => {\n          if (param && param.source !== 'none') {\n            // Parse key to check if it's a nested survey question\n            const parts = key.split('::');\n            \n            if (parts.length === 4) {\n              // Format: fieldType::componentName::survey_json::questionName\n              const [fieldType, componentName, propName, questionName] = parts;\n              \n              if (fieldType && componentName && propName === 'survey_json' && questionName) {\n                // Find the component by name in the field array\n                const fieldArray = trial[fieldType];\n                if (Array.isArray(fieldArray)) {\n                  const compIndex = fieldArray.findIndex(c => c.name === componentName);\n                  if (compIndex !== -1 && fieldArray[compIndex].survey_json) {\n                    // Find the question in survey_json.elements\n                    const elements = fieldArray[compIndex].survey_json.elements || [];\n                    const questionIndex = elements.findIndex(q => q.name === questionName);\n                    \n                    if (questionIndex !== -1) {\n                      // Apply the override value (from typed or csv)\n                      let valueToSet;\n                      if (param.source === 'typed') {\n                        valueToSet = String(param.value); // Convert to string for SurveyJS\n                      } else if (param.source === 'csv') {\n                        valueToSet = String(trial[param.value]); // Get from CSV column and convert to string\n                      }\n                      \n                      if (valueToSet !== undefined && valueToSet !== null) {\n                        fieldArray[compIndex].survey_json.elements[questionIndex].defaultValue = valueToSet;\n                      }\n                    }\n                  }\n                }\n              }\n            } else if (parts.length === 3) {\n              // Format: fieldType::componentName::property (for DynamicPlugin components)\n              const [fieldType, componentName, propName] = parts;\n              \n              if (fieldType && componentName && propName) {\n                // Find the component by name in the field array\n                const fieldArray = trial[fieldType];\n                if (Array.isArray(fieldArray)) {\n                  const compIndex = fieldArray.findIndex(c => c.name === componentName);\n                  if (compIndex !== -1) {\n                    // Apply the override value (from typed or csv)\n                    let valueToSet;\n                    if (param.source === 'typed') {\n                      valueToSet = param.value;\n                    } else if (param.source === 'csv') {\n                      valueToSet = trial[param.value];\n                    }\n                    \n                    if (valueToSet !== undefined && valueToSet !== null) {\n                      fieldArray[compIndex][propName] = valueToSet;\n                    }\n                  }\n                }\n              }\n            } else {\n              // Normal parameter (not nested survey question)\n              if (param.source === 'typed' && param.value !== undefined && param.value !== null) {\n                trial[key] = param.value;\n              } else if (param.source === 'csv' && param.value !== undefined && param.value !== null) {\n                trial[key] = trial[param.value];\n              }\n            }\n          }\n        });\n        // Clear the custom parameters after applying them\n        loop_loop_1769054420851_BranchCustomParameters = null;\n      }\n      \n    },\n    on_finish: function(data) {\n      // Este trial no tiene branches ni repeat conditions, verificar si el loop padre tiene branches\n      if (typeof loop_loop_1769054420851_HasBranches !== 'undefined' && loop_loop_1769054420851_HasBranches) {\n        // El loop tiene branches, activar branching del loop al terminar\n        // Esto se manejará en el on_finish del loop\n        loop_loop_1769054420851_ShouldBranchOnFinish = true;\n      } else if (!loop_loop_1769054420851_HasBranches) {\n        // Ni el trial ni el loop tienen branches - trial terminal\n        // Si llegamos aquí después de un branching global, terminar el experimento\n        if (window.branchingActive) {\n          jsPsych.abortExperiment('', {});\n        }\n      }\n    },};\n\n\n// --- Branching logic variables for loop loop_1769054430260 ---\nlet loop_loop_1769054430260_NextTrialId = null;\nlet loop_loop_1769054430260_SkipRemaining = false;\nlet loop_loop_1769054430260_BranchingActive = false;\nlet loop_loop_1769054430260_BranchCustomParameters = null; // Store custom parameters for branching within loops\nlet loop_loop_1769054430260_TargetExecuted = false; // Indica si el trial objetivo ya se ejecutó en esta iteración\nlet loop_loop_1769054430260_IterationComplete = false; // Indica que la iteración actual terminó\nconst loop_loop_1769054430260_HasBranches = true;\nlet loop_loop_1769054430260_ShouldBranchOnFinish = false;\n\n\n    const New_Tridalb_4_wrapper = {\n      timeline: [New_Tridalb_4_timeline],\n      conditional_function: function() {\n        const currentId = New_Tridalb_4_timeline.data.trial_id;\n        \n        // Verificar si hay un trial/loop objetivo guardado en localStorage (para repeat/jump global)\n        const jumpToTrial = localStorage.getItem('jsPsych_jumpToTrial');\n        if (jumpToTrial) {\n          if (String(currentId) === String(jumpToTrial)) {\n            // Encontramos el trial/loop objetivo para repeat/jump\n            console.log('Repeat/jump: Found target trial/loop inside loop', currentId);\n            localStorage.removeItem('jsPsych_jumpToTrial');\n            return true;\n          }\n          // No es el objetivo, saltar\n          console.log('Repeat/jump: Skipping trial/loop inside loop', currentId);\n          return false;\n        }\n        \n        // Si el item objetivo ya fue ejecutado, saltar todos los items restantes en esta iteración\n        if (loop_loop_1769054430260_TargetExecuted) {\n          \n          return false;\n        }\n        \n        // Si loopSkipRemaining está activo, verificar si este es el item objetivo\n        if (loop_loop_1769054430260_SkipRemaining) {\n          if (String(currentId) === String(loop_loop_1769054430260_NextTrialId)) {\n            // Encontramos el item objetivo dentro del loop\n            loop_loop_1769054430260_TargetExecuted = true;\n            return true;\n          }\n          // No es el objetivo, saltar\n          return false;\n        }\n        \n        // No hay branching activo, ejecutar normalmente\n        return true;\n      },\n      on_timeline_finish: function() {\n        \n      }\n    };\n\n\n    const New_Trial_5_wrapper = {\n      timeline: [New_Trial_5_timeline],\n      conditional_function: function() {\n        const currentId = New_Trial_5_timeline.data.trial_id;\n        \n        // Verificar si hay un trial/loop objetivo guardado en localStorage (para repeat/jump global)\n        const jumpToTrial = localStorage.getItem('jsPsych_jumpToTrial');\n        if (jumpToTrial) {\n          if (String(currentId) === String(jumpToTrial)) {\n            // Encontramos el trial/loop objetivo para repeat/jump\n            console.log('Repeat/jump: Found target trial/loop inside loop', currentId);\n            localStorage.removeItem('jsPsych_jumpToTrial');\n            return true;\n          }\n          // No es el objetivo, saltar\n          console.log('Repeat/jump: Skipping trial/loop inside loop', currentId);\n          return false;\n        }\n        \n        // Si el item objetivo ya fue ejecutado, saltar todos los items restantes en esta iteración\n        if (loop_loop_1769054430260_TargetExecuted) {\n          \n          return false;\n        }\n        \n        // Si loopSkipRemaining está activo, verificar si este es el item objetivo\n        if (loop_loop_1769054430260_SkipRemaining) {\n          if (String(currentId) === String(loop_loop_1769054430260_NextTrialId)) {\n            // Encontramos el item objetivo dentro del loop\n            loop_loop_1769054430260_TargetExecuted = true;\n            return true;\n          }\n          // No es el objetivo, saltar\n          return false;\n        }\n        \n        // No hay branching activo, ejecutar normalmente\n        return true;\n      },\n      on_timeline_finish: function() {\n        \n      }\n    };\n\n\n    const nonested_wrapper = {\n      timeline: [nonested_timeline],\n      conditional_function: function() {\n        const currentId = nonested_timeline.data.trial_id;\n        \n        // Verificar si hay un trial/loop objetivo guardado en localStorage (para repeat/jump global)\n        const jumpToTrial = localStorage.getItem('jsPsych_jumpToTrial');\n        if (jumpToTrial) {\n          if (String(currentId) === String(jumpToTrial)) {\n            // Encontramos el trial/loop objetivo para repeat/jump\n            console.log('Repeat/jump: Found target trial/loop inside loop', currentId);\n            localStorage.removeItem('jsPsych_jumpToTrial');\n            return true;\n          }\n          // No es el objetivo, saltar\n          console.log('Repeat/jump: Skipping trial/loop inside loop', currentId);\n          return false;\n        }\n        \n        // Si el item objetivo ya fue ejecutado, saltar todos los items restantes en esta iteración\n        if (loop_loop_1769054430260_TargetExecuted) {\n          \n          return false;\n        }\n        \n        // Si loopSkipRemaining está activo, verificar si este es el item objetivo\n        if (loop_loop_1769054430260_SkipRemaining) {\n          if (String(currentId) === String(loop_loop_1769054430260_NextTrialId)) {\n            // Encontramos el item objetivo dentro del loop\n            loop_loop_1769054430260_TargetExecuted = true;\n            return true;\n          }\n          // No es el objetivo, saltar\n          return false;\n        }\n        \n        // No hay branching activo, ejecutar normalmente\n        return true;\n      },\n      on_timeline_finish: function() {\n        \n      }\n    };\n\n\n    const saliendodenested_wrapper = {\n      timeline: [saliendodenested_timeline],\n      conditional_function: function() {\n        const currentId = saliendodenested_timeline.data.trial_id;\n        \n        // Verificar si hay un trial/loop objetivo guardado en localStorage (para repeat/jump global)\n        const jumpToTrial = localStorage.getItem('jsPsych_jumpToTrial');\n        if (jumpToTrial) {\n          if (String(currentId) === String(jumpToTrial)) {\n            // Encontramos el trial/loop objetivo para repeat/jump\n            console.log('Repeat/jump: Found target trial/loop inside loop', currentId);\n            localStorage.removeItem('jsPsych_jumpToTrial');\n            return true;\n          }\n          // No es el objetivo, saltar\n          console.log('Repeat/jump: Skipping trial/loop inside loop', currentId);\n          return false;\n        }\n        \n        // Si el item objetivo ya fue ejecutado, saltar todos los items restantes en esta iteración\n        if (loop_loop_1769054430260_TargetExecuted) {\n          \n          // Último item: resetear flags para la siguiente iteración/repetición\n          loop_loop_1769054430260_NextTrialId = null;\n          loop_loop_1769054430260_SkipRemaining = false;\n          loop_loop_1769054430260_TargetExecuted = false;\n          loop_loop_1769054430260_BranchingActive = false;\n          loop_loop_1769054430260_BranchCustomParameters = null;\n          loop_loop_1769054430260_IterationComplete = false;\n          return false;\n        }\n        \n        // Si loopSkipRemaining está activo, verificar si este es el item objetivo\n        if (loop_loop_1769054430260_SkipRemaining) {\n          if (String(currentId) === String(loop_loop_1769054430260_NextTrialId)) {\n            // Encontramos el item objetivo dentro del loop\n            loop_loop_1769054430260_TargetExecuted = true;\n            return true;\n          }\n          // No es el objetivo, saltar\n          return false;\n        }\n        \n        // No hay branching activo, ejecutar normalmente\n        return true;\n      },\n      on_timeline_finish: function() {\n        \n        // Último item del timeline: resetear flags para la siguiente iteración/repetición\n        loop_loop_1769054430260_NextTrialId = null;\n        loop_loop_1769054430260_SkipRemaining = false;\n        loop_loop_1769054430260_TargetExecuted = false;\n        loop_loop_1769054430260_BranchingActive = false;\n        loop_loop_1769054430260_BranchCustomParameters = null;\n        loop_loop_1769054430260_IterationComplete = false;\n      }\n    };\n\nconst evaluateLoopCondition_loop_1769054430260 = (trialData, condition) => {\n  // All rules in a condition must be true (AND logic)\n  return condition.rules.every(rule => {\n    const propValue = trialData[rule.prop];\n    const compareValue = rule.value;\n    \n    // Convert values for comparison\n    const numPropValue = parseFloat(propValue);\n    const numCompareValue = parseFloat(compareValue);\n    const isNumeric = !isNaN(numPropValue) && !isNaN(numCompareValue);\n    \n    switch (rule.op) {\n      case '==':\n        return isNumeric ? numPropValue === numCompareValue : propValue == compareValue;\n      case '!=':\n        return isNumeric ? numPropValue !== numCompareValue : propValue != compareValue;\n      case '>':\n        return isNumeric && numPropValue > numCompareValue;\n      case '<':\n        return isNumeric && numPropValue < numCompareValue;\n      case '>=':\n        return isNumeric && numPropValue >= numCompareValue;\n      case '<=':\n        return isNumeric && numPropValue <= numCompareValue;\n      default:\n        return false;\n    }\n  });\n};\n\nconst getNextLoopTrialId_loop_1769054430260 = (lastTrialData) => {\n  if (!lastTrialData || !lastTrialData.trials || !lastTrialData.trials[0]) {\n    return null;\n  }\n  \n  const trial = lastTrialData.trials[0];\n  \n  // Check if trial has branches\n  if (!Array.isArray(trial.branches) || trial.branches.length === 0) {\n    return null;\n  }\n  \n  // Si solo hay un branch O no hay condiciones, seguir al primer branch automáticamente\n  const hasMultipleBranches = trial.branches.length > 1;\n  const hasBranchConditions = Array.isArray(trial.branchConditions) && trial.branchConditions.length > 0;\n  \n  if (!hasMultipleBranches || !hasBranchConditions) {\n    console.log('Loop internal: Auto-branching to first branch:', trial.branches[0]);\n    return trial.branches[0];\n  }\n  \n  // Si hay múltiples branches Y condiciones, evaluar las condiciones\n  const conditions = trial.branchConditions.flat();\n  \n  // Evaluate each condition (OR logic between conditions)\n  for (const condition of conditions) {\n    if (!condition || !condition.rules) {\n      console.warn('Invalid condition structure:', condition);\n      continue;\n    }\n    \n    if (evaluateLoopCondition_loop_1769054430260(trial, condition)) {\n      console.log('Loop internal: Condition matched:', condition);\n      return condition.nextTrialId;\n    }\n  }\n  \n  // No condition matched - seguir al primer branch por defecto\n  console.log('Loop internal: No condition matched, defaulting to first branch:', trial.branches[0]);\n  return trial.branches[0];\n};\n\nconst loop_1769054430260_procedure = {\n  timeline: [New_Tridalb_4_wrapper, New_Trial_5_wrapper, nonested_wrapper, saliendodenested_wrapper],\n  timeline_variables: test_stimuli_loop_1769054430260,\n  repetitions: 1,\n  randomize_order: false,\n  \n  conditional_function: function() {\n    const currentId = \"loop_1769054430260\";\n    \n    // Verificar si hay un trial objetivo guardado en localStorage (para repeat/jump)\n    const jumpToTrial = localStorage.getItem('jsPsych_jumpToTrial');\n    if (jumpToTrial) {\n      if (String(currentId) === String(jumpToTrial)) {\n        // Encontramos el loop objetivo para repeat/jump\n        console.log('Repeat/jump: Found target loop', currentId);\n        localStorage.removeItem('jsPsych_jumpToTrial');\n        return true;\n      }\n      // No es el objetivo, saltar\n      console.log('Repeat/jump: Skipping loop', currentId);\n      return false;\n    }\n    \n    // Si skipRemaining está activo (branching normal), verificar si este es el loop objetivo\n    if (window.skipRemaining) {\n      if (String(currentId) === String(window.nextTrialId)) {\n        // Encontramos el loop objetivo\n        window.skipRemaining = false;\n        window.nextTrialId = null;\n        return true;\n      }\n      // No es el objetivo, saltar\n      return false;\n    }\n    \n    return true;\n  },\n  on_timeline_start: function() {\n    // Resetear las flags al inicio de cada iteración del loop\n    // Esto permite que cada repetición del loop funcione correctamente\n    loop_loop_1769054430260_NextTrialId = null;\n    loop_loop_1769054430260_SkipRemaining = false;\n    loop_loop_1769054430260_BranchingActive = false;\n    loop_loop_1769054430260_BranchCustomParameters = null;\n    loop_loop_1769054430260_TargetExecuted = false;\n    loop_loop_1769054430260_IterationComplete = false;\n    loop_loop_1769054430260_ShouldBranchOnFinish = false;\n    \n    // IMPORTANTE: Si el loop es condicional, resetear también el branching GLOBAL\n    // para que se regenere durante esta iteración del loop\n    \n  },\n  on_timeline_finish: function() {\n    // Resetear las flags al finalizar todas las repeticiones del loop\n    loop_loop_1769054430260_NextTrialId = null;\n    loop_loop_1769054430260_SkipRemaining = false;\n    loop_loop_1769054430260_TargetExecuted = false;\n    loop_loop_1769054430260_BranchingActive = false;\n    loop_loop_1769054430260_BranchCustomParameters = null;\n    \n    // Verificar si se debe hacer branching porque un trial sin branches se completó\n    // pero el loop tiene branches\n    if (loop_loop_1769054430260_ShouldBranchOnFinish && loop_loop_1769054430260_HasBranches) {\n      const branches = [1769116968980];\n      if (branches.length > 0) {\n        \n        // Este es un loop raíz - activar branching global\n        window.nextTrialId = branches[0];\n        window.skipRemaining = true;\n        window.branchingActive = true;\n        console.log('Root loop finished (from internal trial), branching to:', branches[0]);\n      }\n    }\n    \n    // Resetear todas las variables de branching del loop\n    loop_loop_1769054430260_NextTrialId = null;\n    loop_loop_1769054430260_SkipRemaining = false;\n    loop_loop_1769054430260_BranchingActive = false;\n    loop_loop_1769054430260_BranchCustomParameters = null;\n    loop_loop_1769054430260_ShouldBranchOnFinish = false;\n  },\n\n  data: {\n    loop_id: \"loop_1769054430260\"\n  },\n  on_finish: function(data) {\n    // Branching automático al primer branch del loop\n    // Solo si NO se activó desde trial interno (ShouldBranchOnFinish o BranchingActive)\n    if (!loop_loop_1769054430260_ShouldBranchOnFinish && !loop_loop_1769054430260_BranchingActive) {\n      const branches = [1769116968980];\n      if (branches.length > 0) {\n        window.nextTrialId = branches[0];\n        window.skipRemaining = true;\n        window.branchingActive = true;\n        console.log('Loop on_finish: branching to', branches[0]);\n      }\n    }\n  },\n};\ntimeline.push(loop_1769054430260_procedure);\n\n\n\n    \n    const New_Trial_1_timeline = {\n    type: DynamicPlugin, components: jsPsych.timelineVariable(\"components_New_Trial_1\"),\nresponse_components: jsPsych.timelineVariable(\"response_components_New_Trial_1\"),\n      data: {\n        rt: \"rt_New_Trial_1\",\n        trial_id: 1769116968980,\n        isInLoop: true,\n        \n      },\n    on_start: function(trial) {\n      // Then apply custom parameters from branching conditions (higher priority)\n      // For trials in loops, use loop-specific BranchCustomParameters\n      if (typeof loop_loop_1769054420851_BranchCustomParameters !== 'undefined' && loop_loop_1769054420851_BranchCustomParameters && typeof loop_loop_1769054420851_BranchCustomParameters === 'object') {\n        Object.entries(loop_loop_1769054420851_BranchCustomParameters).forEach(([key, param]) => {\n          if (param && param.source !== 'none') {\n            // Parse key to check if it's a nested survey question\n            const parts = key.split('::');\n            \n            if (parts.length === 4) {\n              // Format: fieldType::componentName::survey_json::questionName\n              const [fieldType, componentName, propName, questionName] = parts;\n              \n              if (fieldType && componentName && propName === 'survey_json' && questionName) {\n                // Find the component by name in the field array\n                const fieldArray = trial[fieldType];\n                if (Array.isArray(fieldArray)) {\n                  const compIndex = fieldArray.findIndex(c => c.name === componentName);\n                  if (compIndex !== -1 && fieldArray[compIndex].survey_json) {\n                    // Find the question in survey_json.elements\n                    const elements = fieldArray[compIndex].survey_json.elements || [];\n                    const questionIndex = elements.findIndex(q => q.name === questionName);\n                    \n                    if (questionIndex !== -1) {\n                      // Apply the override value (from typed or csv)\n                      let valueToSet;\n                      if (param.source === 'typed') {\n                        valueToSet = String(param.value); // Convert to string for SurveyJS\n                      } else if (param.source === 'csv') {\n                        valueToSet = String(trial[param.value]); // Get from CSV column and convert to string\n                      }\n                      \n                      if (valueToSet !== undefined && valueToSet !== null) {\n                        fieldArray[compIndex].survey_json.elements[questionIndex].defaultValue = valueToSet;\n                      }\n                    }\n                  }\n                }\n              }\n            } else if (parts.length === 3) {\n              // Format: fieldType::componentName::property (for DynamicPlugin components)\n              const [fieldType, componentName, propName] = parts;\n              \n              if (fieldType && componentName && propName) {\n                // Find the component by name in the field array\n                const fieldArray = trial[fieldType];\n                if (Array.isArray(fieldArray)) {\n                  const compIndex = fieldArray.findIndex(c => c.name === componentName);\n                  if (compIndex !== -1) {\n                    // Apply the override value (from typed or csv)\n                    let valueToSet;\n                    if (param.source === 'typed') {\n                      valueToSet = param.value;\n                    } else if (param.source === 'csv') {\n                      valueToSet = trial[param.value];\n                    }\n                    \n                    if (valueToSet !== undefined && valueToSet !== null) {\n                      fieldArray[compIndex][propName] = valueToSet;\n                    }\n                  }\n                }\n              }\n            } else {\n              // Normal parameter (not nested survey question)\n              if (param.source === 'typed' && param.value !== undefined && param.value !== null) {\n                trial[key] = param.value;\n              } else if (param.source === 'csv' && param.value !== undefined && param.value !== null) {\n                trial[key] = trial[param.value];\n              }\n            }\n          }\n        });\n        // Clear the custom parameters after applying them\n        loop_loop_1769054420851_BranchCustomParameters = null;\n      }\n      \n    },\n    on_finish: function(data) {\n      // Este trial no tiene branches ni repeat conditions, verificar si el loop padre tiene branches\n      if (typeof loop_loop_1769054420851_HasBranches !== 'undefined' && loop_loop_1769054420851_HasBranches) {\n        // El loop tiene branches, activar branching del loop al terminar\n        // Esto se manejará en el on_finish del loop\n        loop_loop_1769054420851_ShouldBranchOnFinish = true;\n      } else if (!loop_loop_1769054420851_HasBranches) {\n        // Ni el trial ni el loop tienen branches - trial terminal\n        // Si llegamos aquí después de un branching global, terminar el experimento\n        if (window.branchingActive) {\n          jsPsych.abortExperiment('', {});\n        }\n      }\n    },};\n\n\n// --- Branching logic variables for loop loop_1769054420851 ---\nlet loop_loop_1769054420851_NextTrialId = null;\nlet loop_loop_1769054420851_SkipRemaining = false;\nlet loop_loop_1769054420851_BranchingActive = false;\nlet loop_loop_1769054420851_BranchCustomParameters = null; // Store custom parameters for branching within loops\nlet loop_loop_1769054420851_TargetExecuted = false; // Indica si el trial objetivo ya se ejecutó en esta iteración\nlet loop_loop_1769054420851_IterationComplete = false; // Indica que la iteración actual terminó\nconst loop_loop_1769054420851_HasBranches = true;\nlet loop_loop_1769054420851_ShouldBranchOnFinish = false;\n\n\n    const New_Trialb_2_wrapper = {\n      timeline: [New_Trialb_2_timeline],\n      conditional_function: function() {\n        const currentId = New_Trialb_2_timeline.data.trial_id;\n        \n        // Verificar si hay un trial/loop objetivo guardado en localStorage (para repeat/jump global)\n        const jumpToTrial = localStorage.getItem('jsPsych_jumpToTrial');\n        if (jumpToTrial) {\n          if (String(currentId) === String(jumpToTrial)) {\n            // Encontramos el trial/loop objetivo para repeat/jump\n            console.log('Repeat/jump: Found target trial/loop inside loop', currentId);\n            localStorage.removeItem('jsPsych_jumpToTrial');\n            return true;\n          }\n          // No es el objetivo, saltar\n          console.log('Repeat/jump: Skipping trial/loop inside loop', currentId);\n          return false;\n        }\n        \n        // Si el item objetivo ya fue ejecutado, saltar todos los items restantes en esta iteración\n        if (loop_loop_1769054420851_TargetExecuted) {\n          \n          return false;\n        }\n        \n        // Si loopSkipRemaining está activo, verificar si este es el item objetivo\n        if (loop_loop_1769054420851_SkipRemaining) {\n          if (String(currentId) === String(loop_loop_1769054420851_NextTrialId)) {\n            // Encontramos el item objetivo dentro del loop\n            loop_loop_1769054420851_TargetExecuted = true;\n            return true;\n          }\n          // No es el objetivo, saltar\n          return false;\n        }\n        \n        // No hay branching activo, ejecutar normalmente\n        return true;\n      },\n      on_timeline_finish: function() {\n        \n      }\n    };\n\n\n    const New_Trial_3_wrapper = {\n      timeline: [New_Trial_3_timeline],\n      conditional_function: function() {\n        const currentId = New_Trial_3_timeline.data.trial_id;\n        \n        // Verificar si hay un trial/loop objetivo guardado en localStorage (para repeat/jump global)\n        const jumpToTrial = localStorage.getItem('jsPsych_jumpToTrial');\n        if (jumpToTrial) {\n          if (String(currentId) === String(jumpToTrial)) {\n            // Encontramos el trial/loop objetivo para repeat/jump\n            console.log('Repeat/jump: Found target trial/loop inside loop', currentId);\n            localStorage.removeItem('jsPsych_jumpToTrial');\n            return true;\n          }\n          // No es el objetivo, saltar\n          console.log('Repeat/jump: Skipping trial/loop inside loop', currentId);\n          return false;\n        }\n        \n        // Si el item objetivo ya fue ejecutado, saltar todos los items restantes en esta iteración\n        if (loop_loop_1769054420851_TargetExecuted) {\n          \n          return false;\n        }\n        \n        // Si loopSkipRemaining está activo, verificar si este es el item objetivo\n        if (loop_loop_1769054420851_SkipRemaining) {\n          if (String(currentId) === String(loop_loop_1769054420851_NextTrialId)) {\n            // Encontramos el item objetivo dentro del loop\n            loop_loop_1769054420851_TargetExecuted = true;\n            return true;\n          }\n          // No es el objetivo, saltar\n          return false;\n        }\n        \n        // No hay branching activo, ejecutar normalmente\n        return true;\n      },\n      on_timeline_finish: function() {\n        \n      }\n    };\n\n\n    const Nested_Loop_1_wrapper = {\n      timeline: [loop_1769054430260_procedure],\n      conditional_function: function() {\n        const currentId = \"loop_1769054430260\";\n        \n        // Verificar si hay un trial/loop objetivo guardado en localStorage (para repeat/jump global)\n        const jumpToTrial = localStorage.getItem('jsPsych_jumpToTrial');\n        if (jumpToTrial) {\n          if (String(currentId) === String(jumpToTrial)) {\n            // Encontramos el trial/loop objetivo para repeat/jump\n            console.log('Repeat/jump: Found target trial/loop inside loop', currentId);\n            localStorage.removeItem('jsPsych_jumpToTrial');\n            return true;\n          }\n          // No es el objetivo, saltar\n          console.log('Repeat/jump: Skipping trial/loop inside loop', currentId);\n          return false;\n        }\n        \n        // Si el item objetivo ya fue ejecutado, saltar todos los items restantes en esta iteración\n        if (loop_loop_1769054420851_TargetExecuted) {\n          \n          return false;\n        }\n        \n        // Si loopSkipRemaining está activo, verificar si este es el item objetivo\n        if (loop_loop_1769054420851_SkipRemaining) {\n          if (String(currentId) === String(loop_loop_1769054420851_NextTrialId)) {\n            // Encontramos el item objetivo dentro del loop\n            loop_loop_1769054420851_TargetExecuted = true;\n            return true;\n          }\n          // No es el objetivo, saltar\n          return false;\n        }\n        \n        // No hay branching activo, ejecutar normalmente\n        return true;\n      },\n      on_timeline_finish: function() {\n        \n      }\n    };\n\n\n    const New_Trial_1_wrapper = {\n      timeline: [New_Trial_1_timeline],\n      conditional_function: function() {\n        const currentId = New_Trial_1_timeline.data.trial_id;\n        \n        // Verificar si hay un trial/loop objetivo guardado en localStorage (para repeat/jump global)\n        const jumpToTrial = localStorage.getItem('jsPsych_jumpToTrial');\n        if (jumpToTrial) {\n          if (String(currentId) === String(jumpToTrial)) {\n            // Encontramos el trial/loop objetivo para repeat/jump\n            console.log('Repeat/jump: Found target trial/loop inside loop', currentId);\n            localStorage.removeItem('jsPsych_jumpToTrial');\n            return true;\n          }\n          // No es el objetivo, saltar\n          console.log('Repeat/jump: Skipping trial/loop inside loop', currentId);\n          return false;\n        }\n        \n        // Si el item objetivo ya fue ejecutado, saltar todos los items restantes en esta iteración\n        if (loop_loop_1769054420851_TargetExecuted) {\n          \n          // Último item: resetear flags para la siguiente iteración/repetición\n          loop_loop_1769054420851_NextTrialId = null;\n          loop_loop_1769054420851_SkipRemaining = false;\n          loop_loop_1769054420851_TargetExecuted = false;\n          loop_loop_1769054420851_BranchingActive = false;\n          loop_loop_1769054420851_BranchCustomParameters = null;\n          loop_loop_1769054420851_IterationComplete = false;\n          return false;\n        }\n        \n        // Si loopSkipRemaining está activo, verificar si este es el item objetivo\n        if (loop_loop_1769054420851_SkipRemaining) {\n          if (String(currentId) === String(loop_loop_1769054420851_NextTrialId)) {\n            // Encontramos el item objetivo dentro del loop\n            loop_loop_1769054420851_TargetExecuted = true;\n            return true;\n          }\n          // No es el objetivo, saltar\n          return false;\n        }\n        \n        // No hay branching activo, ejecutar normalmente\n        return true;\n      },\n      on_timeline_finish: function() {\n        \n        // Último item del timeline: resetear flags para la siguiente iteración/repetición\n        loop_loop_1769054420851_NextTrialId = null;\n        loop_loop_1769054420851_SkipRemaining = false;\n        loop_loop_1769054420851_TargetExecuted = false;\n        loop_loop_1769054420851_BranchingActive = false;\n        loop_loop_1769054420851_BranchCustomParameters = null;\n        loop_loop_1769054420851_IterationComplete = false;\n      }\n    };\n\nconst evaluateLoopCondition_loop_1769054420851 = (trialData, condition) => {\n  // All rules in a condition must be true (AND logic)\n  return condition.rules.every(rule => {\n    const propValue = trialData[rule.prop];\n    const compareValue = rule.value;\n    \n    // Convert values for comparison\n    const numPropValue = parseFloat(propValue);\n    const numCompareValue = parseFloat(compareValue);\n    const isNumeric = !isNaN(numPropValue) && !isNaN(numCompareValue);\n    \n    switch (rule.op) {\n      case '==':\n        return isNumeric ? numPropValue === numCompareValue : propValue == compareValue;\n      case '!=':\n        return isNumeric ? numPropValue !== numCompareValue : propValue != compareValue;\n      case '>':\n        return isNumeric && numPropValue > numCompareValue;\n      case '<':\n        return isNumeric && numPropValue < numCompareValue;\n      case '>=':\n        return isNumeric && numPropValue >= numCompareValue;\n      case '<=':\n        return isNumeric && numPropValue <= numCompareValue;\n      default:\n        return false;\n    }\n  });\n};\n\nconst getNextLoopTrialId_loop_1769054420851 = (lastTrialData) => {\n  if (!lastTrialData || !lastTrialData.trials || !lastTrialData.trials[0]) {\n    return null;\n  }\n  \n  const trial = lastTrialData.trials[0];\n  \n  // Check if trial has branches\n  if (!Array.isArray(trial.branches) || trial.branches.length === 0) {\n    return null;\n  }\n  \n  // Si solo hay un branch O no hay condiciones, seguir al primer branch automáticamente\n  const hasMultipleBranches = trial.branches.length > 1;\n  const hasBranchConditions = Array.isArray(trial.branchConditions) && trial.branchConditions.length > 0;\n  \n  if (!hasMultipleBranches || !hasBranchConditions) {\n    console.log('Loop internal: Auto-branching to first branch:', trial.branches[0]);\n    return trial.branches[0];\n  }\n  \n  // Si hay múltiples branches Y condiciones, evaluar las condiciones\n  const conditions = trial.branchConditions.flat();\n  \n  // Evaluate each condition (OR logic between conditions)\n  for (const condition of conditions) {\n    if (!condition || !condition.rules) {\n      console.warn('Invalid condition structure:', condition);\n      continue;\n    }\n    \n    if (evaluateLoopCondition_loop_1769054420851(trial, condition)) {\n      console.log('Loop internal: Condition matched:', condition);\n      return condition.nextTrialId;\n    }\n  }\n  \n  // No condition matched - seguir al primer branch por defecto\n  console.log('Loop internal: No condition matched, defaulting to first branch:', trial.branches[0]);\n  return trial.branches[0];\n};\n\nconst loop_1769054420851_procedure = {\n  timeline: [New_Trialb_2_wrapper, New_Trial_3_wrapper, Nested_Loop_1_wrapper, New_Trial_1_wrapper],\n  timeline_variables: test_stimuli_loop_1769054420851,\n  repetitions: 1,\n  randomize_order: false,\n  loop_function: function(data) {\n    // Evaluate loop conditions to determine if the loop should repeat\n    const loopConditionsArray = [{\"id\":1769119681919,\"rules\":[{\"trialId\":\"1769054417382\",\"column\":\"\",\"op\":\"==\",\"value\":\"ok\",\"prop\":\"response\",\"fieldType\":\"response_components\",\"componentIdx\":\"ButtonResponseComponent_1\"}]}];\n    \n    // Helper function to get data from a specific trial\n    const getTrialData = (trialId) => {\n      // Get all trials data\n      const allTrials = data.values();\n      \n      // Find the last occurrence of the trial with matching trial_id\n      for (let i = allTrials.length - 1; i >= 0; i--) {\n        const trial = allTrials[i];\n        if (String(trial.trial_id) === String(trialId)) {\n          return trial;\n        }\n      }\n      return null;\n    };\n    \n    // Evaluate a single condition (AND logic between rules)\n    const evaluateCondition = (condition) => {\n      return condition.rules.every(rule => {\n        const trialData = getTrialData(rule.trialId);\n        \n        if (!trialData) {\n          return false;\n        }\n        \n        // Construct column name if empty (for dynamic plugins)\n        let columnName = rule.column || \"\";\n        if (!columnName && rule.componentIdx && rule.prop) {\n          columnName = rule.componentIdx + '_' + rule.prop;\n        }\n        \n        // Get the property value using the column name\n        const propValue = trialData[columnName || rule.prop];\n        const compareValue = rule.value;\n        \n        // Convert values for comparison\n        const numPropValue = parseFloat(propValue);\n        const numCompareValue = parseFloat(compareValue);\n        const isNumeric = !isNaN(numPropValue) && !isNaN(numCompareValue);\n        \n        let result;\n        switch (rule.op) {\n          case '==':\n            result = isNumeric ? numPropValue === numCompareValue : propValue == compareValue;\n            break;\n          case '!=':\n            result = isNumeric ? numPropValue !== numCompareValue : propValue != compareValue;\n            break;\n          case '>':\n            result = isNumeric && numPropValue > numCompareValue;\n            break;\n          case '<':\n            result = isNumeric && numPropValue < numCompareValue;\n            break;\n          case '>=':\n            result = isNumeric && numPropValue >= numCompareValue;\n            break;\n          case '<=':\n            result = isNumeric && numPropValue <= numCompareValue;\n            break;\n          default:\n            result = false;\n        }\n        \n        return result;\n      });\n    };\n    \n    // Evaluate all conditions (OR logic between conditions)\n    const shouldRepeat = loopConditionsArray.some(condition => evaluateCondition(condition));\n    \n    return shouldRepeat;\n  },\n  conditional_function: function() {\n    const currentId = \"loop_1769054420851\";\n    \n    // Verificar si hay un trial objetivo guardado en localStorage (para repeat/jump)\n    const jumpToTrial = localStorage.getItem('jsPsych_jumpToTrial');\n    if (jumpToTrial) {\n      if (String(currentId) === String(jumpToTrial)) {\n        // Encontramos el loop objetivo para repeat/jump\n        console.log('Repeat/jump: Found target loop', currentId);\n        localStorage.removeItem('jsPsych_jumpToTrial');\n        return true;\n      }\n      // No es el objetivo, saltar\n      console.log('Repeat/jump: Skipping loop', currentId);\n      return false;\n    }\n    \n    // Si skipRemaining está activo (branching normal), verificar si este es el loop objetivo\n    if (window.skipRemaining) {\n      if (String(currentId) === String(window.nextTrialId)) {\n        // Encontramos el loop objetivo\n        window.skipRemaining = false;\n        window.nextTrialId = null;\n        return true;\n      }\n      // No es el objetivo, saltar\n      return false;\n    }\n    \n    return true;\n  },\n  on_timeline_start: function() {\n    // Resetear las flags al inicio de cada iteración del loop\n    // Esto permite que cada repetición del loop funcione correctamente\n    loop_loop_1769054420851_NextTrialId = null;\n    loop_loop_1769054420851_SkipRemaining = false;\n    loop_loop_1769054420851_BranchingActive = false;\n    loop_loop_1769054420851_BranchCustomParameters = null;\n    loop_loop_1769054420851_TargetExecuted = false;\n    loop_loop_1769054420851_IterationComplete = false;\n    loop_loop_1769054420851_ShouldBranchOnFinish = false;\n    \n    // IMPORTANTE: Si el loop es condicional, resetear también el branching GLOBAL\n    // para que se regenere durante esta iteración del loop\n    \n    window.nextTrialId = null;\n    window.skipRemaining = false;\n    window.branchingActive = false;\n    window.branchCustomParameters = null;\n    console.log('Conditional loop iteration starting, reset global branching flags');\n    \n  },\n  on_timeline_finish: function() {\n    // Resetear las flags al finalizar todas las repeticiones del loop\n    loop_loop_1769054420851_NextTrialId = null;\n    loop_loop_1769054420851_SkipRemaining = false;\n    loop_loop_1769054420851_TargetExecuted = false;\n    loop_loop_1769054420851_BranchingActive = false;\n    loop_loop_1769054420851_BranchCustomParameters = null;\n    \n    // Verificar si se debe hacer branching porque un trial sin branches se completó\n    // pero el loop tiene branches\n    if (loop_loop_1769054420851_ShouldBranchOnFinish && loop_loop_1769054420851_HasBranches) {\n      const branches = [1769054422939];\n      if (branches.length > 0) {\n        \n        // Este es un loop raíz - activar branching global\n        window.nextTrialId = branches[0];\n        window.skipRemaining = true;\n        window.branchingActive = true;\n        console.log('Root loop finished (from internal trial), branching to:', branches[0]);\n      }\n    }\n    \n    // Resetear todas las variables de branching del loop\n    loop_loop_1769054420851_NextTrialId = null;\n    loop_loop_1769054420851_SkipRemaining = false;\n    loop_loop_1769054420851_BranchingActive = false;\n    loop_loop_1769054420851_BranchCustomParameters = null;\n    loop_loop_1769054420851_ShouldBranchOnFinish = false;\n  },\n\n  data: {\n    loop_id: \"loop_1769054420851\"\n  },\n  on_finish: function(data) {\n    // Branching automático al primer branch del loop\n    // Solo si NO se activó desde trial interno (ShouldBranchOnFinish o BranchingActive)\n    if (!loop_loop_1769054420851_ShouldBranchOnFinish && !loop_loop_1769054420851_BranchingActive) {\n      const branches = [1769054422939];\n      if (branches.length > 0) {\n        window.nextTrialId = branches[0];\n        window.skipRemaining = true;\n        window.branchingActive = true;\n        console.log('Loop on_finish: branching to', branches[0]);\n      }\n    }\n  },\n};\ntimeline.push(loop_1769054420851_procedure);\n\n\n\n    const test_stimuli_New_Trial_2 = [{components: [{ type: \"HtmlComponent\", coordinates: {\"x\":0,\"y\":0}, width: 200, height: 50, name: \"HtmlComponent_1\", stimulus: \"<div id=\\\"ifgp\\\" style=\\\"box-sizing: border-box;\\\">termina loop</div>\" }],\nresponse_components: []}];\n    const New_Trial_2_timeline = {\n    type: DynamicPlugin, components: jsPsych.timelineVariable(\"components\"),\n      data: {\n        rt: \"rt\",\n        trial_id: 1769054422939,\n        \n        \n      },\n    on_start: function(trial) {\n      // First, evaluate and apply params override conditions (if any)\n      const paramsOverrideConditions = [{\"id\":1769123342181,\"rules\":[{\"trialId\":\"\",\"column\":\"\",\"op\":\"==\",\"value\":\"\",\"prop\":\"\"}],\"paramsToOverride\":{}}];\n      \n      // Evaluate params override conditions\n      for (const condition of paramsOverrideConditions) {\n        if (!condition || !condition.rules) {\n          continue;\n        }\n        \n        // Get data from all previous trials\n        const allData = jsPsych.data.get().values();\n        \n        // Check if all rules match (AND logic within condition)\n        const allRulesMatch = condition.rules.every(rule => {\n          if (!rule.trialId) {\n            return false;\n          }\n          \n          // Find data from the referenced trial\n          const trialData = allData.filter(d => {\n            // Compare both as strings to handle type mismatches\n            return String(d.trial_id) === String(rule.trialId) || d.trial_id === rule.trialId;\n          });\n          if (trialData.length === 0) {\n            return false;\n          }\n          \n          // Use the most recent data if multiple exist\n          const data = trialData[trialData.length - 1];\n          \n          // Construct column name if empty (for dynamic plugins)\n          let columnName = rule.column || \"\";\n          if (!columnName && rule.componentIdx && rule.prop) {\n            columnName = rule.componentIdx + '_' + rule.prop;\n          }\n          \n          // Get the property value using the column name\n          const propValue = data[columnName || rule.prop];\n          const compareValue = rule.value;\n          \n          // Handle array responses (multi-select questions)\n          if (Array.isArray(propValue)) {\n            // For array values, check if compareValue is included in the array\n            switch (rule.op) {\n              case '==':\n                return propValue.includes(compareValue);\n              case '!=':\n                return !propValue.includes(compareValue);\n              default:\n                return false; // Comparison operators don't make sense for arrays\n            }\n          }\n          \n          // Convert values for comparison (for non-array values)\n          const numPropValue = parseFloat(propValue);\n          const numCompareValue = parseFloat(compareValue);\n          const isNumeric = !isNaN(numPropValue) && !isNaN(numCompareValue);\n          \n          switch (rule.op) {\n            case '==':\n              return isNumeric ? numPropValue === numCompareValue : propValue == compareValue;\n            case '!=':\n              return isNumeric ? numPropValue !== numCompareValue : propValue != compareValue;\n            case '>':\n              return isNumeric && numPropValue > numCompareValue;\n            case '<':\n              return isNumeric && numPropValue < numCompareValue;\n            case '>=':\n              return isNumeric && numPropValue >= numCompareValue;\n            case '<=':\n              return isNumeric && numPropValue <= numCompareValue;\n            default:\n              return false;\n          }\n        });\n        \n        // If all rules match, apply parameter overrides\n        if (allRulesMatch && condition.paramsToOverride) {\n          Object.entries(condition.paramsToOverride).forEach(([key, param]) => {\n            if (param && param.source !== 'none') {\n              // Parse key to check structure\n              const parts = key.split('::');\n              \n              if (parts.length === 4) {\n                // Format: fieldType::componentName::survey_json::questionName\n                const [fieldType, componentName, propName, questionName] = parts;\n                \n                if (fieldType && componentName && propName === 'survey_json' && questionName) {\n                  // Find the component by name in the field array\n                  const fieldArray = trial[fieldType];\n                  \n                  if (Array.isArray(fieldArray)) {\n                    const compIndex = fieldArray.findIndex(c => c.name === componentName);\n                    \n                    if (compIndex !== -1 && fieldArray[compIndex].survey_json) {\n                      // Find the question in survey_json.elements\n                      const elements = fieldArray[compIndex].survey_json.elements || [];\n                      const questionIndex = elements.findIndex(q => q.name === questionName);\n                      \n                      if (questionIndex !== -1) {\n                        // Apply the override value (from typed or csv)\n                        let valueToSet;\n                        if (param.source === 'typed') {\n                          valueToSet = String(param.value); // Convert to string for SurveyJS\n                        } else if (param.source === 'csv') {\n                          valueToSet = String(trial[param.value]); // Get from CSV column and convert to string\n                        }\n                        \n                        if (valueToSet !== undefined && valueToSet !== null) {\n                          fieldArray[compIndex].survey_json.elements[questionIndex].defaultValue = valueToSet;\n                        }\n                      }\n                    }\n                  }\n                }\n              } else if (parts.length === 3) {\n                // Format: fieldType::componentName::property (for dynamic plugin components like ButtonResponseComponent)\n                const [fieldType, componentName, propName] = parts;\n                \n                if (fieldType && componentName && propName) {\n                  // Find the component by name in the field array\n                  const fieldArray = trial[fieldType];\n                  \n                  if (Array.isArray(fieldArray)) {\n                    const compIndex = fieldArray.findIndex(c => c.name === componentName);\n                    \n                    if (compIndex !== -1) {\n                      // Apply the override value\n                      let valueToSet;\n                      if (param.source === 'typed') {\n                        valueToSet = param.value;\n                      } else if (param.source === 'csv') {\n                        valueToSet = trial[param.value]; // Get from CSV column\n                      }\n                      \n                      if (valueToSet !== undefined && valueToSet !== null) {\n                        fieldArray[compIndex][propName] = valueToSet;\n                      }\n                    }\n                  }\n                }\n              } else {\n                // Normal parameter (not nested)\n                if (param.source === 'typed' && param.value !== undefined && param.value !== null) {\n                  trial[key] = param.value;\n                } else if (param.source === 'csv' && param.value !== undefined && param.value !== null) {\n                  // For CSV source, param.value contains the column name, get the actual value from trial\n                  trial[key] = trial[param.value];\n                }\n              }\n            }\n          });\n          // Break after first matching condition (OR logic between conditions)\n          break;\n        }\n      }\n      \n      // Then apply custom parameters from branching conditions (higher priority)\n      // For trials outside loops, use window.branchCustomParameters\n      if (window.branchCustomParameters && typeof window.branchCustomParameters === 'object') {\n        Object.entries(window.branchCustomParameters).forEach(([key, param]) => {\n          if (param && param.source !== 'none') {\n            // Parse key to check if it's a nested survey question\n            const parts = key.split('::');\n            \n            if (parts.length === 4) {\n              // Format: fieldType::componentName::survey_json::questionName\n              const [fieldType, componentName, propName, questionName] = parts;\n              \n              if (fieldType && componentName && propName === 'survey_json' && questionName) {\n                // Find the component by name in the field array\n                const fieldArray = trial[fieldType];\n                if (Array.isArray(fieldArray)) {\n                  const compIndex = fieldArray.findIndex(c => c.name === componentName);\n                  if (compIndex !== -1 && fieldArray[compIndex].survey_json) {\n                    // Find the question in survey_json.elements\n                    const elements = fieldArray[compIndex].survey_json.elements || [];\n                    const questionIndex = elements.findIndex(q => q.name === questionName);\n                    \n                    if (questionIndex !== -1) {\n                      // Apply the override value (from typed or csv)\n                      let valueToSet;\n                      if (param.source === 'typed') {\n                        valueToSet = String(param.value); // Convert to string for SurveyJS\n                      } else if (param.source === 'csv') {\n                        valueToSet = String(trial[param.value]); // Get from CSV column and convert to string\n                      }\n                      \n                      if (valueToSet !== undefined && valueToSet !== null) {\n                        fieldArray[compIndex].survey_json.elements[questionIndex].defaultValue = valueToSet;\n                      }\n                    }\n                  }\n                }\n              }\n            } else if (parts.length === 3) {\n              // Format: fieldType::componentName::property (for DynamicPlugin components)\n              const [fieldType, componentName, propName] = parts;\n              \n              if (fieldType && componentName && propName) {\n                // Find the component by name in the field array\n                const fieldArray = trial[fieldType];\n                if (Array.isArray(fieldArray)) {\n                  const compIndex = fieldArray.findIndex(c => c.name === componentName);\n                  if (compIndex !== -1) {\n                    // Apply the override value (from typed or csv)\n                    let valueToSet;\n                    if (param.source === 'typed') {\n                      valueToSet = param.value;\n                    } else if (param.source === 'csv') {\n                      valueToSet = trial[param.value];\n                    }\n                    \n                    if (valueToSet !== undefined && valueToSet !== null) {\n                      fieldArray[compIndex][propName] = valueToSet;\n                    }\n                  }\n                }\n              }\n            } else {\n              // Normal parameter (not nested survey question)\n              if (param.source === 'typed' && param.value !== undefined && param.value !== null) {\n                trial[key] = param.value;\n              } else if (param.source === 'csv' && param.value !== undefined && param.value !== null) {\n                trial[key] = trial[param.value];\n              }\n            }\n          }\n        });\n        // Clear the custom parameters after applying them\n        window.branchCustomParameters = null;\n      }\n      \n    },\n    on_finish: function(data) {\n      // Trial terminal - si llegamos aquí después de branching, terminar el experimento\n      if (window.branchingActive) {\n        jsPsych.abortExperiment('', {});\n      }\n    },};\n    console.log(\"=== PROCEDURE SETUP New_Trial_2 ===\");\n    console.log(\"test_stimuli_New_Trial_2 before procedure:\", test_stimuli_New_Trial_2);\n    console.log(\"test_stimuli_New_Trial_2.length:\", test_stimuli_New_Trial_2 ? test_stimuli_New_Trial_2.length : 'undefined');\n    \n    const New_Trial_2_procedure = {\n    timeline: \n    [New_Trial_2_timeline],\n    timeline_variables: test_stimuli_New_Trial_2,\n    \n    conditional_function: function() {\n      const currentId = 1769054422939;\n      \n      // Verificar si hay un trial objetivo guardado en localStorage (para repeat/jump)\n      const jumpToTrial = localStorage.getItem('jsPsych_jumpToTrial');\n      if (jumpToTrial) {\n        if (String(currentId) === String(jumpToTrial)) {\n          // Encontramos el trial objetivo para repeat/jump\n          console.log('🔁 [REPEAT/JUMP] Found target trial', currentId);\n          localStorage.removeItem('jsPsych_jumpToTrial');\n          return true;\n        }\n        // No es el objetivo, saltar\n        console.log('⏭️ [REPEAT/JUMP] Skipping trial', currentId);\n        return false;\n      }\n      \n      // Si skipRemaining está activo (branching normal), verificar si este es el trial objetivo\n      if (window.skipRemaining) {\n        console.log('🔍 [SKIP CHECK] Trial', currentId, '| Target:', window.nextTrialId, '| Match:', String(currentId) === String(window.nextTrialId));\n        if (String(currentId) === String(window.nextTrialId)) {\n          // Encontramos el trial objetivo\n          console.log('✅ [SKIP CHECK] Found target trial! Disabling skip mode');\n          window.skipRemaining = false;\n          window.nextTrialId = null;\n          return true;\n        }\n        // No es el objetivo, saltar\n        console.log('⏭️ [SKIP CHECK] Skipping trial', currentId);\n        return false;\n      }\n      \n      return true;\n    },\n  \n    \n    };\n    timeline.push(New_Trial_2_procedure);\n  \n\n\n    const test_stimuli_New_Trial = [{components: [{ type: \"HtmlComponent\", coordinates: {\"x\":0,\"y\":0}, width: 200, height: 50, name: \"HtmlComponent_1\", stimulus: \"<div style=\\\"box-sizing: border-box;\\\">Type or design here</div>\" }],\nresponse_components: []}];\n    const New_Trial_timeline = {\n    type: DynamicPlugin, components: jsPsych.timelineVariable(\"components\"),\n      data: {\n        rt: \"rt\",\n        trial_id: 1769133935682,\n        \n        \n      },\n    on_start: function(trial) {\n      // Then apply custom parameters from branching conditions (higher priority)\n      // For trials outside loops, use window.branchCustomParameters\n      if (window.branchCustomParameters && typeof window.branchCustomParameters === 'object') {\n        Object.entries(window.branchCustomParameters).forEach(([key, param]) => {\n          if (param && param.source !== 'none') {\n            // Parse key to check if it's a nested survey question\n            const parts = key.split('::');\n            \n            if (parts.length === 4) {\n              // Format: fieldType::componentName::survey_json::questionName\n              const [fieldType, componentName, propName, questionName] = parts;\n              \n              if (fieldType && componentName && propName === 'survey_json' && questionName) {\n                // Find the component by name in the field array\n                const fieldArray = trial[fieldType];\n                if (Array.isArray(fieldArray)) {\n                  const compIndex = fieldArray.findIndex(c => c.name === componentName);\n                  if (compIndex !== -1 && fieldArray[compIndex].survey_json) {\n                    // Find the question in survey_json.elements\n                    const elements = fieldArray[compIndex].survey_json.elements || [];\n                    const questionIndex = elements.findIndex(q => q.name === questionName);\n                    \n                    if (questionIndex !== -1) {\n                      // Apply the override value (from typed or csv)\n                      let valueToSet;\n                      if (param.source === 'typed') {\n                        valueToSet = String(param.value); // Convert to string for SurveyJS\n                      } else if (param.source === 'csv') {\n                        valueToSet = String(trial[param.value]); // Get from CSV column and convert to string\n                      }\n                      \n                      if (valueToSet !== undefined && valueToSet !== null) {\n                        fieldArray[compIndex].survey_json.elements[questionIndex].defaultValue = valueToSet;\n                      }\n                    }\n                  }\n                }\n              }\n            } else if (parts.length === 3) {\n              // Format: fieldType::componentName::property (for DynamicPlugin components)\n              const [fieldType, componentName, propName] = parts;\n              \n              if (fieldType && componentName && propName) {\n                // Find the component by name in the field array\n                const fieldArray = trial[fieldType];\n                if (Array.isArray(fieldArray)) {\n                  const compIndex = fieldArray.findIndex(c => c.name === componentName);\n                  if (compIndex !== -1) {\n                    // Apply the override value (from typed or csv)\n                    let valueToSet;\n                    if (param.source === 'typed') {\n                      valueToSet = param.value;\n                    } else if (param.source === 'csv') {\n                      valueToSet = trial[param.value];\n                    }\n                    \n                    if (valueToSet !== undefined && valueToSet !== null) {\n                      fieldArray[compIndex][propName] = valueToSet;\n                    }\n                  }\n                }\n              }\n            } else {\n              // Normal parameter (not nested survey question)\n              if (param.source === 'typed' && param.value !== undefined && param.value !== null) {\n                trial[key] = param.value;\n              } else if (param.source === 'csv' && param.value !== undefined && param.value !== null) {\n                trial[key] = trial[param.value];\n              }\n            }\n          }\n        });\n        // Clear the custom parameters after applying them\n        window.branchCustomParameters = null;\n      }\n      \n    },\n    on_finish: function(data) {\n      // Trial terminal - si llegamos aquí después de branching, terminar el experimento\n      if (window.branchingActive) {\n        jsPsych.abortExperiment('', {});\n      }\n    },};\n    console.log(\"=== PROCEDURE SETUP New_Trial ===\");\n    console.log(\"test_stimuli_New_Trial before procedure:\", test_stimuli_New_Trial);\n    console.log(\"test_stimuli_New_Trial.length:\", test_stimuli_New_Trial ? test_stimuli_New_Trial.length : 'undefined');\n    \n    const New_Trial_procedure = {\n    timeline: \n    [New_Trial_timeline],\n    timeline_variables: test_stimuli_New_Trial,\n    \n    conditional_function: function() {\n      const currentId = 1769133935682;\n      \n      // Verificar si hay un trial objetivo guardado en localStorage (para repeat/jump)\n      const jumpToTrial = localStorage.getItem('jsPsych_jumpToTrial');\n      if (jumpToTrial) {\n        if (String(currentId) === String(jumpToTrial)) {\n          // Encontramos el trial objetivo para repeat/jump\n          console.log('🔁 [REPEAT/JUMP] Found target trial', currentId);\n          localStorage.removeItem('jsPsych_jumpToTrial');\n          return true;\n        }\n        // No es el objetivo, saltar\n        console.log('⏭️ [REPEAT/JUMP] Skipping trial', currentId);\n        return false;\n      }\n      \n      // Si skipRemaining está activo (branching normal), verificar si este es el trial objetivo\n      if (window.skipRemaining) {\n        console.log('🔍 [SKIP CHECK] Trial', currentId, '| Target:', window.nextTrialId, '| Match:', String(currentId) === String(window.nextTrialId));\n        if (String(currentId) === String(window.nextTrialId)) {\n          // Encontramos el trial objetivo\n          console.log('✅ [SKIP CHECK] Found target trial! Disabling skip mode');\n          window.skipRemaining = false;\n          window.nextTrialId = null;\n          return true;\n        }\n        // No es el objetivo, saltar\n        console.log('⏭️ [SKIP CHECK] Skipping trial', currentId);\n        return false;\n      }\n      \n      return true;\n    },\n  \n    \n    };\n    timeline.push(New_Trial_procedure);\n  \n\njsPsych.run(timeline);\n\n})();\n"
      },
      "isDevMode": false,
      "createdAt": "2026-01-22T03:57:20.229Z",
      "updatedAt": "2026-01-25T06:06:02.889Z"
    },
    {
      "experimentID": "e852734d-02be-4a66-b9c7-56c078e94d9b",
      "data": {
        "generatedCode": ""
      },
      "isDevMode": false,
      "createdAt": "2026-01-25T06:06:10.895Z",
      "updatedAt": "2026-01-25T06:06:20.330Z"
    }
  ],
  "pluginConfigs": [],
  "sessionResults": []
}