{
  "experiments": [
    {
      "experimentID": "5de9a3dd-867e-46d2-bed9-b0b461b56880",
      "name": "Hola",
      "createdAt": "2026-02-18T21:22:57.079Z",
      "updatedAt": "2026-02-18T21:22:57.079Z"
    }
  ],
  "trials": [
    {
      "experimentID": "5de9a3dd-867e-46d2-bed9-b0b461b56880",
      "trials": [
        {
          "type": "Trial",
          "name": "New Trial",
          "plugin": "plugin-dynamic",
          "parameters": {},
          "trialCode": "",
          "id": 1771449779189,
          "createdAt": "2026-02-18T21:22:59.189Z",
          "updatedAt": "2026-02-21T22:19:45.458Z",
          "columnMapping": {
            "components": {
              "source": "typed",
              "value": [
                {
                  "type": "ImageComponent",
                  "coordinates": {
                    "x": -0.556640625,
                    "y": 0.5807291666666666
                  },
                  "zIndex": 1,
                  "name": {
                    "source": "typed",
                    "value": "ImageComponent_1"
                  },
                  "stimulus": {
                    "source": "typed",
                    "value": "img/armadillo.png"
                  }
                },
                {
                  "type": "HtmlComponent",
                  "coordinates": {
                    "x": 0.17213114754098346,
                    "y": 0
                  },
                  "width": 200,
                  "height": 50,
                  "zIndex": 3,
                  "name": {
                    "source": "typed",
                    "value": "HtmlComponent_1"
                  },
                  "stimulus": {
                    "source": "typed",
                    "value": "<div style=\"box-sizing: border-box;\">Type or design here</div>"
                  }
                }
              ]
            },
            "response_components": {
              "source": "typed",
              "value": [
                {
                  "type": "ButtonResponseComponent",
                  "coordinates": {
                    "x": 0.012295081967213184,
                    "y": -0.42076502732240445
                  },
                  "width": 200,
                  "height": 50,
                  "zIndex": 4,
                  "name": {
                    "source": "typed",
                    "value": "ButtonResponseComponent_1"
                  },
                  "choices": {
                    "source": "typed",
                    "value": [
                      "hola"
                    ]
                  }
                }
              ]
            }
          },
          "branches": [
            1771712362456
          ]
        },
        {
          "type": "Trial",
          "name": "New Trial 1",
          "plugin": "plugin-dynamic",
          "parameters": {},
          "trialCode": "",
          "id": 1771712362456,
          "createdAt": "2026-02-21T22:19:22.456Z",
          "updatedAt": "2026-02-21T22:20:11.010Z",
          "branches": [
            1771712363606
          ],
          "columnMapping": {
            "components": {
              "source": "typed",
              "value": [
                {
                  "type": "HtmlComponent",
                  "coordinates": {
                    "x": 0,
                    "y": 0
                  },
                  "width": 200,
                  "height": 50,
                  "zIndex": 1,
                  "name": {
                    "source": "typed",
                    "value": "HtmlComponent_1"
                  },
                  "stimulus": {
                    "source": "typed",
                    "value": "<div style=\"box-sizing: border-box;\">Type or design here</div>"
                  }
                }
              ]
            },
            "response_components": {
              "source": "typed",
              "value": [
                {
                  "type": "ButtonResponseComponent",
                  "coordinates": {
                    "x": 0,
                    "y": -0.3333333333333333
                  },
                  "width": 200,
                  "height": 50,
                  "zIndex": 2,
                  "name": {
                    "source": "typed",
                    "value": "ButtonResponseComponent_1"
                  },
                  "choices": {
                    "source": "typed",
                    "value": [
                      "2"
                    ]
                  }
                }
              ]
            }
          }
        },
        {
          "type": "Trial",
          "name": "New Trial 2",
          "plugin": "plugin-dynamic",
          "parameters": {},
          "trialCode": "",
          "id": 1771712363606,
          "createdAt": "2026-02-21T22:19:23.606Z",
          "updatedAt": "2026-02-21T23:02:17.625Z",
          "columnMapping": {
            "components": {
              "source": "typed",
              "value": [
                {
                  "type": "HtmlComponent",
                  "coordinates": {
                    "x": 0,
                    "y": 0
                  },
                  "width": 200,
                  "height": 50,
                  "zIndex": 1,
                  "name": {
                    "source": "typed",
                    "value": "HtmlComponent_1"
                  },
                  "stimulus": {
                    "source": "typed",
                    "value": "<div style=\"box-sizing: border-box;\">Type or design here</div>"
                  }
                }
              ]
            },
            "response_components": {
              "source": "typed",
              "value": [
                {
                  "type": "ButtonResponseComponent",
                  "coordinates": {
                    "x": 0,
                    "y": -0.20765027322404364
                  },
                  "width": 200,
                  "height": 50,
                  "zIndex": 2,
                  "name": {
                    "source": "typed",
                    "value": "ButtonResponseComponent_1"
                  },
                  "choices": {
                    "source": "typed",
                    "value": [
                      "3"
                    ]
                  }
                }
              ]
            }
          },
          "branchConditions": [],
          "repeatConditions": [
            {
              "id": 1771714900583,
              "rules": [
                {
                  "column": "",
                  "op": "==",
                  "value": "3",
                  "fieldType": "response_components",
                  "componentIdx": "ButtonResponseComponent_1",
                  "prop": "response"
                }
              ],
              "jumpToTrialId": "1771712362456"
            }
          ]
        }
      ],
      "loops": [],
      "timeline": [
        {
          "id": 1771449779189,
          "type": "trial",
          "name": "New Trial",
          "branches": [
            1771712362456
          ]
        },
        {
          "id": 1771712362456,
          "type": "trial",
          "name": "New Trial 1",
          "branches": [
            1771712363606
          ]
        },
        {
          "id": 1771712363606,
          "type": "trial",
          "name": "New Trial 2",
          "branches": []
        }
      ],
      "createdAt": "2026-02-18T21:22:59.189Z",
      "updatedAt": "2026-02-21T23:02:17.625Z"
    }
  ],
  "configs": [
    {
      "experimentID": "5de9a3dd-867e-46d2-bed9-b0b461b56880",
      "data": {
        "generatedCode": "\n  // --- Recolectar metadata del sistema ---\n  const getMetadata = () => {\n    const ua = navigator.userAgent;\n    let browserName = 'Unknown';\n    let browserVersion = 'Unknown';\n    \n    if (ua.indexOf('Firefox') > -1) {\n      browserName = 'Firefox';\n      browserVersion = ua.match(/Firefox\\/(\\d+\\.\\d+)/)?.[1] || 'Unknown';\n    } else if (ua.indexOf('Chrome') > -1) {\n      browserName = 'Chrome';\n      browserVersion = ua.match(/Chrome\\/(\\d+\\.\\d+)/)?.[1] || 'Unknown';\n    } else if (ua.indexOf('Safari') > -1) {\n      browserName = 'Safari';\n      browserVersion = ua.match(/Version\\/(\\d+\\.\\d+)/)?.[1] || 'Unknown';\n    } else if (ua.indexOf('Edg') > -1) {\n      browserName = 'Edge';\n      browserVersion = ua.match(/Edg\\/(\\d+\\.\\d+)/)?.[1] || 'Unknown';\n    }\n    \n    let osName = 'Unknown';\n    if (ua.indexOf('Win') > -1) osName = 'Windows';\n    else if (ua.indexOf('Mac') > -1) osName = 'macOS';\n    else if (ua.indexOf('Linux') > -1) osName = 'Linux';\n    else if (ua.indexOf('Android') > -1) osName = 'Android';\n    else if (ua.indexOf('iOS') > -1) osName = 'iOS';\n    \n    return {\n      browser: browserName,\n      browserVersion: browserVersion,\n      os: osName,\n      screenWidth: window.screen.width,\n      screenHeight: window.screen.height,\n      screenResolution: `${window.screen.width}x${window.screen.height}`,\n      viewportWidth: window.innerWidth,\n      viewportHeight: window.innerHeight,\n      language: navigator.language,\n      userAgent: ua,\n      startedAt: new Date().toISOString()\n    };\n  };\n  \n  const metadata = getMetadata();\n\n  // --- Socket.IO para tracking en tiempo real ---\n  const socketScript = document.createElement('script');\n  socketScript.src = '/socket.io/socket.io.js';\n  socketScript.onload = () => {\n    window._socketReady = true;\n  };\n  document.head.appendChild(socketScript);\n\n  function waitForSocket() {\n    return new Promise(resolve => {\n      if (window._socketReady) return resolve();\n      const interval = setInterval(() => {\n        if (window._socketReady) {\n          clearInterval(interval);\n          resolve();\n        }\n      }, 50);\n    });\n  }\n\n  // Recuperar sessionId de localStorage o crear uno nuevo\n  let trialSessionId = localStorage.getItem('jsPsych_currentSessionId');\n  let isResuming = false;\n\n  if (!trialSessionId) {\n    trialSessionId = crypto.randomUUID\n      ? crypto.randomUUID()\n      : Math.random().toString(36).slice(2, 10);\n  } else {\n    isResuming = true;\n  }\n\n  let participantNumber;\n  let socket;\n\n  async function saveSession(trialSessionId) {\n   \n   const res = await fetch(\"/api/append-result/5de9a3dd-867e-46d2-bed9-b0b461b56880\", {\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\", Accept: \"*/*\" },\n      body: JSON.stringify({\n        sessionId: trialSessionId,\n        metadata: metadata\n      }),\n    });\n  \n    const result = await res.json();\n    participantNumber = result.participantNumber;\n    return participantNumber;\n    \n  }\n\n  \n  // --- Loading overlay ---\n  const _loadingOverlay = document.createElement('div');\n  _loadingOverlay.id = 'jspsych-loading-overlay';\n  _loadingOverlay.style.cssText = [\n    'position:fixed', 'inset:0', 'z-index:9999',\n    'display:flex', 'flex-direction:column',\n    'align-items:center', 'justify-content:center',\n    'background:#fff', 'gap:20px',\n    'font-family:sans-serif'\n  ].join(';');\n  _loadingOverlay.innerHTML = `\n    <div style=\"width:48px;height:48px;border:5px solid #e0e0e0;border-top-color:#555;border-radius:50%;animation:_spin 0.8s linear infinite\"></div>\n    <p id=\"jspsych-loading-msg\" style=\"margin:0;color:#555;font-size:15px\">Initializing experiment‚Ä¶</p>\n    <style>@keyframes _spin{to{transform:rotate(360deg)}}</style>\n  `;\n  document.body.appendChild(_loadingOverlay);\n\n  function _setLoadingMsg(msg) {\n    const el = document.getElementById('jspsych-loading-msg');\n    if (el) el.textContent = msg;\n  }\n\n  function _hideLoading() {\n    const el = document.getElementById('jspsych-loading-overlay');\n    if (el) el.remove();\n  }\n\n  function _showSuccess() {\n    _hideLoading();\n    const overlay = document.createElement('div');\n    overlay.id = 'jspsych-loading-overlay';\n    overlay.style.cssText = [\n      'position:fixed', 'inset:0', 'z-index:9999',\n      'display:flex', 'flex-direction:column',\n      'align-items:center', 'justify-content:center',\n      'background:#fff', 'gap:16px',\n      'font-family:sans-serif'\n    ].join(';');\n    overlay.innerHTML = `\n      <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"64\" height=\"64\" viewBox=\"0 0 64 64\">\n        <circle cx=\"32\" cy=\"32\" r=\"30\" fill=\"#22c55e\"/>\n        <polyline points=\"18,33 28,43 46,22\" fill=\"none\" stroke=\"#fff\" stroke-width=\"5\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\n      </svg>\n      <p style=\"margin:0;color:#111;font-size:18px;font-weight:600\">Experiment complete. Thank you!</p>\n      <p style=\"margin:0;color:#555;font-size:14px\">You can now close this window.</p>\n    `;\n    document.body.appendChild(overlay);\n  }\n\n  function _showLoading(msg) {\n    _hideLoading();\n    const overlay = document.createElement('div');\n    overlay.id = 'jspsych-loading-overlay';\n    overlay.style.cssText = [\n      'position:fixed', 'inset:0', 'z-index:9999',\n      'display:flex', 'flex-direction:column',\n      'align-items:center', 'justify-content:center',\n      'background:#fff', 'gap:20px',\n      'font-family:sans-serif'\n    ].join(';');\n    overlay.innerHTML = `\n      <div style=\"width:48px;height:48px;border:5px solid #e0e0e0;border-top-color:#555;border-radius:50%;animation:_spin 0.8s linear infinite\"></div>\n      <p id=\"jspsych-loading-msg\" style=\"margin:0;color:#555;font-size:15px\">${msg || 'Please wait‚Ä¶'}</p>\n      <style>@keyframes _spin{to{transform:rotate(360deg)}}</style>\n    `;\n    document.body.appendChild(overlay);\n  }\n\n  \n  // Resuelve a qu√© trial saltar al reanudar evaluando las branch conditions guardadas.\n  // Retorna el id (string) del trial destino, o null si no hay punto de retoma.\n  function _resolveResumeBranch(resumeRaw) {\n    if (!resumeRaw) return null;\n    try {\n      const d = JSON.parse(resumeRaw);\n      const branches = d.branches || [];\n      const branchConditions = d.branchConditions || [];\n      const trialData = d.trialData || {};\n\n      if (branches.length === 0) return null; // trial terminal, experimento termin√≥\n      if (branches.length === 1) return String(branches[0]); // √∫nico branch, sin condiciones\n\n      // M√∫ltiples branches: evaluar condiciones (OR entre condiciones, AND entre reglas)\n      const flat = Array.isArray(branchConditions[0])\n        ? branchConditions.flat()\n        : branchConditions;\n\n      for (let i = 0; i < flat.length; i++) {\n        const cond = flat[i];\n        if (!cond || !cond.rules) continue;\n        const match = cond.rules.every(rule => {\n          let col = rule.column || '';\n          if (!col && rule.componentIdx && rule.prop) col = rule.componentIdx + '_' + rule.prop;\n          else if (!col && rule.prop) col = rule.prop;\n          let val = trialData[col];\n          // Manejar respuestas anidadas (SurveyComponent)\n          if (val === undefined) {\n            const parts = col.split('_');\n            if (parts.length >= 2) {\n              const resp = trialData[parts.slice(0, -1).join('_') + '_response'];\n              if (resp && typeof resp === 'object') val = resp[parts[parts.length - 1]];\n            }\n          }\n          // Respuestas en array (multi-select)\n          if (Array.isArray(val)) {\n            const has = val.includes(rule.value) || val.includes(String(rule.value));\n            return rule.op === '==' ? has : rule.op === '!=' ? !has : false;\n          }\n          const n1 = parseFloat(val), n2 = parseFloat(rule.value);\n          const isNum = !isNaN(n1) && !isNaN(n2);\n          switch (rule.op) {\n            case '==': return isNum ? n1 === n2 : val == rule.value;\n            case '!=': return isNum ? n1 !== n2 : val != rule.value;\n            case '>':  return isNum && n1 > n2;\n            case '<':  return isNum && n1 < n2;\n            case '>=': return isNum && n1 >= n2;\n            case '<=': return isNum && n1 <= n2;\n            default:   return false;\n          }\n        });\n        if (match && i < branches.length) return String(branches[i]);\n      }\n      return String(branches[0]); // fallback al primero si ninguna condici√≥n matchea\n    } catch (e) {\n      return null; // datos corruptos\n    }\n  }\n\n\n  (async () => {\n\n    // Leer datos de retoma ANTES de cualquier limpieza\n    const resumeRaw = localStorage.getItem('jsPsych_resumeTrial');\n    const existingJump = localStorage.getItem('jsPsych_jumpToTrial');\n\n    if (!existingJump) {\n      // Sin jump pendiente: derivar destino desde el √∫ltimo trial completado\n      localStorage.removeItem('jsPsych_jumpToTrial');\n      const jumpTarget = _resolveResumeBranch(resumeRaw);\n      localStorage.removeItem('jsPsych_resumeTrial');\n      if (jumpTarget) localStorage.setItem('jsPsych_jumpToTrial', jumpTarget);\n    } else {\n      // Jump ya establecido por repeat/jump ‚Äî preservarlo, solo limpiar resume\n      localStorage.removeItem('jsPsych_resumeTrial');\n    }\n\n    // Esperar a que Socket.IO est√© listo\n    await waitForSocket();\n    socket = io();\n    \n    _setLoadingMsg('Creating session‚Ä¶');\n    participantNumber = await saveSession(trialSessionId);\n\n    // Si falla con el sessionId existente (sesi√≥n hu√©rfana), reintentar con uno nuevo\n    // IMPORTANTE: NO borrar jsPsych_resumeTrial aqu√≠ para no perder el punto de retoma\n    if (typeof participantNumber !== \"number\" || isNaN(participantNumber)) {\n      localStorage.removeItem('jsPsych_currentSessionId');\n      localStorage.removeItem('jsPsych_participantNumber');\n      trialSessionId = crypto.randomUUID\n        ? crypto.randomUUID()\n        : Math.random().toString(36).slice(2, 10);\n      isResuming = false;\n      participantNumber = await saveSession(trialSessionId);\n    }\n\n    if (typeof participantNumber !== \"number\" || isNaN(participantNumber)) {\n      alert(\"The participant number is not assigned. Please, wait.\");\n      throw new Error(\"participantNumber not assigned\");\n    }\n\n    // Guardar sessionId en localStorage para futuras retomas\n    localStorage.setItem('jsPsych_currentSessionId', trialSessionId);\n    localStorage.setItem('jsPsych_participantNumber', participantNumber.toString());\n\n    // Conectar sesi√≥n con el servidor via WebSocket\n    socket.emit('join-experiment', {\n      experimentID: '5de9a3dd-867e-46d2-bed9-b0b461b56880',\n      sessionId: trialSessionId,\n      state: isResuming ? 'resumed' : 'initiated',\n      metadata: metadata\n    });\n\n    // --- Branching logic functions (outside initJsPsych for timeline access) ---\n    window.nextTrialId = null;\n    window.skipRemaining = false;\n    window.branchingActive = false;\n    window.branchCustomParameters = null; // Store custom parameters for the next trial\n\n    const evaluateCondition = (trialData, condition) => {\n      // All rules in a condition must be true (AND logic)\n      return condition.rules.every(rule => {\n        // Construct column name from componentIdx and prop if column is empty\n        // This handles dynamic plugins like ButtonResponseComponent_1_response\n        let columnName = rule.column || \"\";\n        if (!columnName && rule.componentIdx && rule.prop) {\n          columnName = rule.componentIdx + '_' + rule.prop;\n        } else if (!columnName && rule.prop) {\n          columnName = rule.prop;\n        }\n        \n        if (!columnName) {\n          console.warn('No column name specified in rule:', rule);\n          return false;\n        }\n        \n        // Get value directly from the column\n        const propValue = trialData[columnName];\n        \n        if (propValue === undefined) {\n          console.warn('Column not found in trial data:', columnName);\n          return false;\n        }\n        \n        const compareValue = rule.value;\n        \n        // Handle array responses (multi-select or single-select returned as array)\n        if (Array.isArray(propValue)) {\n          const matches = propValue.includes(compareValue) || propValue.includes(String(compareValue));\n          switch (rule.op) {\n            case '==':\n              return matches;\n            case '!=':\n              return !matches;\n            default:\n              return false;\n          }\n        }\n        \n        // Convert values for comparison (for non-array values)\n        const numPropValue = parseFloat(propValue);\n        const numCompareValue = parseFloat(compareValue);\n        const isNumeric = !isNaN(numPropValue) && !isNaN(numCompareValue);\n        \n        switch (rule.op) {\n          case '==':\n            return isNumeric ? numPropValue === numCompareValue : propValue == compareValue;\n          case '!=':\n            return isNumeric ? numPropValue !== numCompareValue : propValue != compareValue;\n          case '>':\n            return isNumeric && numPropValue > numCompareValue;\n          case '<':\n            return isNumeric && numPropValue < numCompareValue;\n          case '>=':\n            return isNumeric && numPropValue >= numCompareValue;\n          case '<=':\n            return isNumeric && numPropValue <= numCompareValue;\n          default:\n            return false;\n        }\n      });\n    };\n    \n    const getNextTrialId = (lastTrialData) => {\n      if (!lastTrialData || !lastTrialData.trials || !lastTrialData.trials[0]) {\n        return null;\n      }\n      \n      const trial = lastTrialData.trials[0];\n      \n      // Check if trial/loop has branches\n      if (!Array.isArray(trial.branches) || trial.branches.length === 0) {\n        return null;\n      }\n      \n      // Check if there are conditions to evaluate\n      const hasBranchConditions = Array.isArray(trial.branchConditions) && trial.branchConditions.length > 0;\n      \n      // Check if any condition has customParameters\n      const hasCustomParameters = hasBranchConditions && \n        trial.branchConditions.flat().some(condition => \n          condition && condition.customParameters && \n          Object.keys(condition.customParameters).length > 0\n        );\n      \n      // If there are no conditions AND no custom parameters, auto-branch to first branch\n      if (!hasBranchConditions && !hasCustomParameters) {\n        console.log('No conditions or custom parameters defined, auto-branching to first branch:', trial.branches[0]);\n        return trial.branches[0];\n      }\n      \n      // If there are no conditions but there ARE custom parameters, we can't auto-branch\n      // We need to evaluate conditions to know which customParameters to use\n      if (!hasBranchConditions && hasCustomParameters) {\n        console.log('Custom parameters exist but no conditions, cannot auto-branch');\n        return null;\n      }\n      \n      // If there ARE conditions, evaluate them (regardless of how many branches there are)\n      // branchConditions is an array of arrays, flatten it first\n      const conditions = trial.branchConditions.flat();\n      \n      // Evaluate each condition (OR logic between conditions)\n      for (const condition of conditions) {\n        if (!condition || !condition.rules) {\n          console.warn('Invalid condition structure:', condition);\n          continue;\n        }\n        \n        if (evaluateCondition(trial, condition)) {\n          // Store custom parameters if they exist\n          if (condition.customParameters) {\n            window.branchCustomParameters = condition.customParameters;\n          }\n          return condition.nextTrialId;\n        }\n      }\n      \n      // No condition matched - do NOT branch (conditions were defined but none matched)\n      return null;\n    };\n\n    _hideLoading();\n\n    // Track pending data saves to ensure all complete before finishing\n    const pendingDataSaves = [];\n\n    const jsPsych = initJsPsych({\n          display_element: document.getElementById('jspsych-container'),\n\n\n    \n\n    on_data_update: function (data) {\n      // Create and track the promise for this data save\n      const savePromise = fetch(\"/api/append-result/5de9a3dd-867e-46d2-bed9-b0b461b56880\", {\n        method: \"PUT\",\n        headers: { \"Content-Type\": \"application/json\", Accept: \"*/*\" },\n        body: JSON.stringify({\n          sessionId: trialSessionId,\n          response: data,\n        }),\n      })\n      .then(res => {\n        if (!res.ok) {\n          console.error('Error saving trial data:', res.statusText);\n        }\n        return res;\n      })\n      .catch(error => {\n        console.error('Error in on_data_update:', error);\n      })\n      .finally(() => {\n        // Remove from pending once complete\n        const index = pendingDataSaves.indexOf(savePromise);\n        if (index > -1) {\n          pendingDataSaves.splice(index, 1);\n        }\n      });\n      \n      pendingDataSaves.push(savePromise);\n\n      // üîÑ SISTEMA DE RETOMA: Guardar branches + datos del trial para evaluar al reanudar\n      if (data.builder_id !== undefined && data.builder_id !== null) {\n        localStorage.setItem('jsPsych_resumeTrial', JSON.stringify({\n          branches: data.branches || [],\n          branchConditions: data.branchConditions || [],\n          trialData: data\n        }));\n      }\n      \n      // Actualizar estado a 'in-progress' en la primera actualizaci√≥n\n      if (data.trial_index === 0 && socket) {\n        socket.emit('update-session-state', {\n          experimentID: '5de9a3dd-867e-46d2-bed9-b0b461b56880',\n          sessionId: trialSessionId,\n          state: 'in-progress'\n        });\n      }\n      \n      // Solo evaluar branching si el trial/loop tiene un trial_id o loop_id v√°lido\n      if ((!data.trial_id || data.trial_id === undefined) && (!data.loop_id || data.loop_id === undefined)) {\n        return;\n      }\n      \n      const lastTrialData = jsPsych.data.getLastTrialData();\n      const trial = lastTrialData.trials ? lastTrialData.trials[0] : null;\n      \n      // Verificar si este trial/loop tiene branches\n      if (!trial || !trial.branches || trial.branches.length === 0) {\n        return; // No tiene branches, no hay nada que hacer\n      }\n      \n      // IMPORTANTE: Si el trial est√° dentro de un loop (isInLoop = true),\n      // NO activar el branching global. Los trials dentro de loops usan su propio\n      // sistema de branching con variables locales (loopNextTrialId, etc.)\n      if (trial.isInLoop === true) {\n        return;\n      }\n      \n      const nextTrialId = getNextTrialId(lastTrialData);\n      \n      if (nextTrialId) {\n        // Check if nextTrialId is \"FINISH_EXPERIMENT\"\n        if (nextTrialId === 'FINISH_EXPERIMENT') {\n          console.log('üèÅ [BRANCHING] Finishing experiment via branching');\n          jsPsych.abortExperiment('Experiment finished by branching condition', {});\n          return;\n        }\n        \n        console.log('üéØ [BRANCHING] Setting global branch target:', nextTrialId);\n        window.nextTrialId = nextTrialId;\n        window.skipRemaining = true;\n        window.branchingActive = true;\n        console.log('üéØ [BRANCHING] Skip remaining activated');\n      }\n    },\n\n  on_finish: async function() {\n    // Si hay un repeat/jump pendiente (via window o localStorage), recargar para ejecutarlo\n    const pendingJump = localStorage.getItem('jsPsych_jumpToTrial') || (window.skipRemaining && window.nextTrialId);\n    if (pendingJump) {\n      if (window.skipRemaining && window.nextTrialId) {\n        localStorage.setItem('jsPsych_jumpToTrial', String(window.nextTrialId));\n      }\n      if (pendingDataSaves.length > 0) await Promise.allSettled(pendingDataSaves);\n      window.location.reload();\n      return;\n    }\n\n    _showLoading('Saving your data‚Ä¶');\n    await new Promise(r => setTimeout(r, 0));\n\n    // Limpiar datos de retoma ya que el experimento termin√≥ correctamente\n    localStorage.removeItem('jsPsych_resumeTrial');\n    localStorage.removeItem('jsPsych_currentSessionId');\n    localStorage.removeItem('jsPsych_participantNumber');\n\n    // Wait for all pending data saves to complete\n    if (pendingDataSaves.length > 0) {\n      _setLoadingMsg('Uploading data‚Ä¶');\n      await Promise.allSettled(pendingDataSaves);\n    }\n    \n    _setLoadingMsg('Finishing up‚Ä¶');\n\n    // Marcar como completado\n    if (socket) {\n      socket.emit('update-session-state', {\n        experimentID: '5de9a3dd-867e-46d2-bed9-b0b461b56880',\n        sessionId: trialSessionId,\n        state: 'completed'\n      });\n    }\n    \n    await fetch(\"/api/complete-session/5de9a3dd-867e-46d2-bed9-b0b461b56880\", {\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\", Accept: \"*/*\" },\n      body: JSON.stringify({\n        sessionId: trialSessionId,\n      }),\n    });\n\n    _showSuccess();\n  }\n});\n\nconst timeline = [];\n\n    // Global preload for all uploaded files from Timeline\n    \n    const globalPreload = {\n      type: jsPsychPreload,\n      files: [\"img/armadillo.png\",\"img/bmw.png\",\"img/boat.png\",\"img/boat2.png\",\"img/cofre.png\",\"img/cube.png\",\"img/dis.png\",\"img/floor.png\",\"img/green.png\",\"img/obstacle.png\"]\n    };\n    timeline.push(globalPreload);\n    \n\n    \n    const test_stimuli_New_Trial = [{components: [{ type: \"ImageComponent\", coordinates: {\"x\":-0.556640625,\"y\":0.5807291666666666}, zIndex: 1, name: \"ImageComponent_1\", stimulus: \"img/armadillo.png\" }, { type: \"HtmlComponent\", coordinates: {\"x\":0.17213114754098346,\"y\":0}, width: 200, height: 50, zIndex: 3, name: \"HtmlComponent_1\", stimulus: \"<div style=\\\"box-sizing: border-box;\\\">Type or design here</div>\" }],\nresponse_components: [{ type: \"ButtonResponseComponent\", coordinates: {\"x\":0.012295081967213184,\"y\":-0.42076502732240445}, width: 200, height: 50, zIndex: 4, name: \"ButtonResponseComponent_1\", choices: [\"hola\"] }]}];\n    const New_Trial_timeline = {\n    type: DynamicPlugin, components: jsPsych.timelineVariable(\"components\"),\nresponse_components: jsPsych.timelineVariable(\"response_components\"),\n      data: {\n        rt: \"rt\",\n        trial_id: 1771449779189,\n        builder_id: 1771449779189,\n        \n        \n        branches: [1771712362456],\n        branchConditions: [undefined] \n        \n      },\n    on_start: function(trial) {\n      // Then apply custom parameters from branching conditions (higher priority)\n      // For trials outside loops, use window.branchCustomParameters\n      if (window.branchCustomParameters && typeof window.branchCustomParameters === 'object') {\n        Object.entries(window.branchCustomParameters).forEach(([key, param]) => {\n          if (param && param.source !== 'none') {\n            // Parse key to check if it's a nested survey question\n            const parts = key.split('::');\n            \n            if (parts.length === 4) {\n              // Format: fieldType::componentName::survey_json::questionName\n              const [fieldType, componentName, propName, questionName] = parts;\n              \n              if (fieldType && componentName && propName === 'survey_json' && questionName) {\n                // Find the component by name in the field array\n                const fieldArray = trial[fieldType];\n                if (Array.isArray(fieldArray)) {\n                  const compIndex = fieldArray.findIndex(c => c.name === componentName);\n                  if (compIndex !== -1 && fieldArray[compIndex].survey_json) {\n                    // Find the question in survey_json.elements\n                    const elements = fieldArray[compIndex].survey_json.elements || [];\n                    const questionIndex = elements.findIndex(q => q.name === questionName);\n                    \n                    if (questionIndex !== -1) {\n                      // Apply the override value (from typed or csv)\n                      let valueToSet;\n                      if (param.source === 'typed') {\n                        valueToSet = String(param.value); // Convert to string for SurveyJS\n                      } else if (param.source === 'csv') {\n                        valueToSet = String(trial[param.value]); // Get from CSV column and convert to string\n                      }\n                      \n                      if (valueToSet !== undefined && valueToSet !== null) {\n                        fieldArray[compIndex].survey_json.elements[questionIndex].defaultValue = valueToSet;\n                      }\n                    }\n                  }\n                }\n              }\n            } else if (parts.length === 3) {\n              // Format: fieldType::componentName::property (for DynamicPlugin components)\n              const [fieldType, componentName, propName] = parts;\n              \n              if (fieldType && componentName && propName) {\n                // Find the component by name in the field array\n                const fieldArray = trial[fieldType];\n                if (Array.isArray(fieldArray)) {\n                  const compIndex = fieldArray.findIndex(c => c.name === componentName);\n                  if (compIndex !== -1) {\n                    // Apply the override value (from typed or csv)\n                    let valueToSet;\n                    if (param.source === 'typed') {\n                      valueToSet = param.value;\n                    } else if (param.source === 'csv') {\n                      valueToSet = trial[param.value];\n                    }\n                    \n                    if (valueToSet !== undefined && valueToSet !== null) {\n                      fieldArray[compIndex][propName] = valueToSet;\n                    }\n                  }\n                }\n              }\n            } else {\n              // Normal parameter (not nested survey question)\n              if (param.source === 'typed' && param.value !== undefined && param.value !== null) {\n                trial[key] = param.value;\n              } else if (param.source === 'csv' && param.value !== undefined && param.value !== null) {\n                trial[key] = trial[param.value];\n              }\n            }\n          }\n        });\n        // Clear the custom parameters after applying them\n        window.branchCustomParameters = null;\n      }\n      \n    },\n    on_finish: function(data) {\n      // Branching autom√°tico al primer branch (global)\n      console.log('üîÑ [GLOBAL BRANCH] Auto-branching to first branch:', 1771712362456);\n      window.nextTrialId = 1771712362456;\n      window.skipRemaining = true;\n      window.branchingActive = true;\n      \n    },};\n    console.log(\"=== PROCEDURE SETUP New_Trial ===\");\n    console.log(\"test_stimuli_New_Trial before procedure:\", test_stimuli_New_Trial);\n    console.log(\"test_stimuli_New_Trial.length:\", test_stimuli_New_Trial ? test_stimuli_New_Trial.length : 'undefined');\n    \n    const New_Trial_procedure = {\n    timeline: \n    [New_Trial_timeline],\n    timeline_variables: test_stimuli_New_Trial,\n    \n    conditional_function: function() {\n      const currentId = 1771449779189;\n      \n      // Verificar si hay un trial objetivo guardado en localStorage (para repeat/jump)\n      const jumpToTrial = localStorage.getItem('jsPsych_jumpToTrial');\n      if (jumpToTrial) {\n        if (String(currentId) === String(jumpToTrial)) {\n          // Encontramos el trial objetivo para repeat/jump\n          console.log('üîÅ [REPEAT/JUMP] Found target trial', currentId);\n          localStorage.removeItem('jsPsych_jumpToTrial');\n          return true;\n        }\n        // No es el objetivo, saltar\n        console.log('‚è≠Ô∏è [REPEAT/JUMP] Skipping trial', currentId);\n        return false;\n      }\n      \n      // Si skipRemaining est√° activo (branching normal), verificar si este es el trial objetivo\n      if (window.skipRemaining) {\n        console.log('üîç [SKIP CHECK] Trial', currentId, '| Target:', window.nextTrialId, '| Match:', String(currentId) === String(window.nextTrialId));\n        if (String(currentId) === String(window.nextTrialId)) {\n          // Encontramos el trial objetivo\n          console.log('‚úÖ [SKIP CHECK] Found target trial! Disabling skip mode');\n          window.skipRemaining = false;\n          window.nextTrialId = null;\n          return true;\n        }\n        // No es el objetivo, saltar\n        console.log('‚è≠Ô∏è [SKIP CHECK] Skipping trial', currentId);\n        return false;\n      }\n      \n      return true;\n    },\n  \n    \n    };\n    timeline.push(New_Trial_procedure);\n  \n\n\n    const test_stimuli_New_Trial_1 = [{components: [{ type: \"HtmlComponent\", coordinates: {\"x\":0,\"y\":0}, width: 200, height: 50, zIndex: 1, name: \"HtmlComponent_1\", stimulus: \"<div style=\\\"box-sizing: border-box;\\\">Type or design here</div>\" }],\nresponse_components: [{ type: \"ButtonResponseComponent\", coordinates: {\"x\":0,\"y\":-0.3333333333333333}, width: 200, height: 50, zIndex: 2, name: \"ButtonResponseComponent_1\", choices: [\"2\"] }]}];\n    const New_Trial_1_timeline = {\n    type: DynamicPlugin, components: jsPsych.timelineVariable(\"components\"),\nresponse_components: jsPsych.timelineVariable(\"response_components\"),\n      data: {\n        rt: \"rt\",\n        trial_id: 1771712362456,\n        builder_id: 1771712362456,\n        \n        \n        branches: [1771712363606],\n        branchConditions: [undefined] \n        \n      },\n    on_start: function(trial) {\n      // Then apply custom parameters from branching conditions (higher priority)\n      // For trials outside loops, use window.branchCustomParameters\n      if (window.branchCustomParameters && typeof window.branchCustomParameters === 'object') {\n        Object.entries(window.branchCustomParameters).forEach(([key, param]) => {\n          if (param && param.source !== 'none') {\n            // Parse key to check if it's a nested survey question\n            const parts = key.split('::');\n            \n            if (parts.length === 4) {\n              // Format: fieldType::componentName::survey_json::questionName\n              const [fieldType, componentName, propName, questionName] = parts;\n              \n              if (fieldType && componentName && propName === 'survey_json' && questionName) {\n                // Find the component by name in the field array\n                const fieldArray = trial[fieldType];\n                if (Array.isArray(fieldArray)) {\n                  const compIndex = fieldArray.findIndex(c => c.name === componentName);\n                  if (compIndex !== -1 && fieldArray[compIndex].survey_json) {\n                    // Find the question in survey_json.elements\n                    const elements = fieldArray[compIndex].survey_json.elements || [];\n                    const questionIndex = elements.findIndex(q => q.name === questionName);\n                    \n                    if (questionIndex !== -1) {\n                      // Apply the override value (from typed or csv)\n                      let valueToSet;\n                      if (param.source === 'typed') {\n                        valueToSet = String(param.value); // Convert to string for SurveyJS\n                      } else if (param.source === 'csv') {\n                        valueToSet = String(trial[param.value]); // Get from CSV column and convert to string\n                      }\n                      \n                      if (valueToSet !== undefined && valueToSet !== null) {\n                        fieldArray[compIndex].survey_json.elements[questionIndex].defaultValue = valueToSet;\n                      }\n                    }\n                  }\n                }\n              }\n            } else if (parts.length === 3) {\n              // Format: fieldType::componentName::property (for DynamicPlugin components)\n              const [fieldType, componentName, propName] = parts;\n              \n              if (fieldType && componentName && propName) {\n                // Find the component by name in the field array\n                const fieldArray = trial[fieldType];\n                if (Array.isArray(fieldArray)) {\n                  const compIndex = fieldArray.findIndex(c => c.name === componentName);\n                  if (compIndex !== -1) {\n                    // Apply the override value (from typed or csv)\n                    let valueToSet;\n                    if (param.source === 'typed') {\n                      valueToSet = param.value;\n                    } else if (param.source === 'csv') {\n                      valueToSet = trial[param.value];\n                    }\n                    \n                    if (valueToSet !== undefined && valueToSet !== null) {\n                      fieldArray[compIndex][propName] = valueToSet;\n                    }\n                  }\n                }\n              }\n            } else {\n              // Normal parameter (not nested survey question)\n              if (param.source === 'typed' && param.value !== undefined && param.value !== null) {\n                trial[key] = param.value;\n              } else if (param.source === 'csv' && param.value !== undefined && param.value !== null) {\n                trial[key] = trial[param.value];\n              }\n            }\n          }\n        });\n        // Clear the custom parameters after applying them\n        window.branchCustomParameters = null;\n      }\n      \n    },\n    on_finish: function(data) {\n      // Branching autom√°tico al primer branch (global)\n      console.log('üîÑ [GLOBAL BRANCH] Auto-branching to first branch:', 1771712363606);\n      window.nextTrialId = 1771712363606;\n      window.skipRemaining = true;\n      window.branchingActive = true;\n      \n    },};\n    console.log(\"=== PROCEDURE SETUP New_Trial_1 ===\");\n    console.log(\"test_stimuli_New_Trial_1 before procedure:\", test_stimuli_New_Trial_1);\n    console.log(\"test_stimuli_New_Trial_1.length:\", test_stimuli_New_Trial_1 ? test_stimuli_New_Trial_1.length : 'undefined');\n    \n    const New_Trial_1_procedure = {\n    timeline: \n    [New_Trial_1_timeline],\n    timeline_variables: test_stimuli_New_Trial_1,\n    \n    conditional_function: function() {\n      const currentId = 1771712362456;\n      \n      // Verificar si hay un trial objetivo guardado en localStorage (para repeat/jump)\n      const jumpToTrial = localStorage.getItem('jsPsych_jumpToTrial');\n      if (jumpToTrial) {\n        if (String(currentId) === String(jumpToTrial)) {\n          // Encontramos el trial objetivo para repeat/jump\n          console.log('üîÅ [REPEAT/JUMP] Found target trial', currentId);\n          localStorage.removeItem('jsPsych_jumpToTrial');\n          return true;\n        }\n        // No es el objetivo, saltar\n        console.log('‚è≠Ô∏è [REPEAT/JUMP] Skipping trial', currentId);\n        return false;\n      }\n      \n      // Si skipRemaining est√° activo (branching normal), verificar si este es el trial objetivo\n      if (window.skipRemaining) {\n        console.log('üîç [SKIP CHECK] Trial', currentId, '| Target:', window.nextTrialId, '| Match:', String(currentId) === String(window.nextTrialId));\n        if (String(currentId) === String(window.nextTrialId)) {\n          // Encontramos el trial objetivo\n          console.log('‚úÖ [SKIP CHECK] Found target trial! Disabling skip mode');\n          window.skipRemaining = false;\n          window.nextTrialId = null;\n          return true;\n        }\n        // No es el objetivo, saltar\n        console.log('‚è≠Ô∏è [SKIP CHECK] Skipping trial', currentId);\n        return false;\n      }\n      \n      return true;\n    },\n  \n    \n    };\n    timeline.push(New_Trial_1_procedure);\n  \n\n\n    const test_stimuli_New_Trial_2 = [{components: [{ type: \"HtmlComponent\", coordinates: {\"x\":0,\"y\":0}, width: 200, height: 50, zIndex: 1, name: \"HtmlComponent_1\", stimulus: \"<div style=\\\"box-sizing: border-box;\\\">Type or design here</div>\" }],\nresponse_components: [{ type: \"ButtonResponseComponent\", coordinates: {\"x\":0,\"y\":-0.20765027322404364}, width: 200, height: 50, zIndex: 2, name: \"ButtonResponseComponent_1\", choices: [\"3\"] }]}];\n    const New_Trial_2_timeline = {\n    type: DynamicPlugin, components: jsPsych.timelineVariable(\"components\"),\nresponse_components: jsPsych.timelineVariable(\"response_components\"),\n      data: {\n        rt: \"rt\",\n        trial_id: 1771712363606,\n        builder_id: 1771712363606,\n        \n        \n      },\n    on_start: function(trial) {\n      // Then apply custom parameters from branching conditions (higher priority)\n      // For trials outside loops, use window.branchCustomParameters\n      if (window.branchCustomParameters && typeof window.branchCustomParameters === 'object') {\n        Object.entries(window.branchCustomParameters).forEach(([key, param]) => {\n          if (param && param.source !== 'none') {\n            // Parse key to check if it's a nested survey question\n            const parts = key.split('::');\n            \n            if (parts.length === 4) {\n              // Format: fieldType::componentName::survey_json::questionName\n              const [fieldType, componentName, propName, questionName] = parts;\n              \n              if (fieldType && componentName && propName === 'survey_json' && questionName) {\n                // Find the component by name in the field array\n                const fieldArray = trial[fieldType];\n                if (Array.isArray(fieldArray)) {\n                  const compIndex = fieldArray.findIndex(c => c.name === componentName);\n                  if (compIndex !== -1 && fieldArray[compIndex].survey_json) {\n                    // Find the question in survey_json.elements\n                    const elements = fieldArray[compIndex].survey_json.elements || [];\n                    const questionIndex = elements.findIndex(q => q.name === questionName);\n                    \n                    if (questionIndex !== -1) {\n                      // Apply the override value (from typed or csv)\n                      let valueToSet;\n                      if (param.source === 'typed') {\n                        valueToSet = String(param.value); // Convert to string for SurveyJS\n                      } else if (param.source === 'csv') {\n                        valueToSet = String(trial[param.value]); // Get from CSV column and convert to string\n                      }\n                      \n                      if (valueToSet !== undefined && valueToSet !== null) {\n                        fieldArray[compIndex].survey_json.elements[questionIndex].defaultValue = valueToSet;\n                      }\n                    }\n                  }\n                }\n              }\n            } else if (parts.length === 3) {\n              // Format: fieldType::componentName::property (for DynamicPlugin components)\n              const [fieldType, componentName, propName] = parts;\n              \n              if (fieldType && componentName && propName) {\n                // Find the component by name in the field array\n                const fieldArray = trial[fieldType];\n                if (Array.isArray(fieldArray)) {\n                  const compIndex = fieldArray.findIndex(c => c.name === componentName);\n                  if (compIndex !== -1) {\n                    // Apply the override value (from typed or csv)\n                    let valueToSet;\n                    if (param.source === 'typed') {\n                      valueToSet = param.value;\n                    } else if (param.source === 'csv') {\n                      valueToSet = trial[param.value];\n                    }\n                    \n                    if (valueToSet !== undefined && valueToSet !== null) {\n                      fieldArray[compIndex][propName] = valueToSet;\n                    }\n                  }\n                }\n              }\n            } else {\n              // Normal parameter (not nested survey question)\n              if (param.source === 'typed' && param.value !== undefined && param.value !== null) {\n                trial[key] = param.value;\n              } else if (param.source === 'csv' && param.value !== undefined && param.value !== null) {\n                trial[key] = trial[param.value];\n              }\n            }\n          }\n        });\n        // Clear the custom parameters after applying them\n        window.branchCustomParameters = null;\n      }\n      \n    },\n    on_finish: function(data) {\n      // Evaluar repeat conditions (para reiniciar el experimento desde un trial espec√≠fico)\n      const repeatConditionsArray = [{\"id\":1771714900583,\"rules\":[{\"column\":\"\",\"op\":\"==\",\"value\":\"3\",\"fieldType\":\"response_components\",\"componentIdx\":\"ButtonResponseComponent_1\",\"prop\":\"response\"}],\"jumpToTrialId\":\"1771712362456\"}];\n      \n      let shouldRepeat = false;\n      for (const condition of repeatConditionsArray) {\n        if (!condition || !condition.rules) {\n          continue;\n        }\n        \n        // Todas las reglas en una condici√≥n deben ser verdaderas (l√≥gica AND)\n        const allRulesMatch = condition.rules.every(rule => {\n          // Construct column name if empty (for dynamic plugins)\n          let columnName = rule.column || \"\";\n          if (!columnName && rule.componentIdx && rule.prop) {\n            columnName = rule.componentIdx + '_' + rule.prop;\n          } else if (!columnName && rule.prop) {\n            columnName = rule.prop;\n          }\n          \n          // Get the property value using the column name\n          const propValue = data[columnName];\n          const compareValue = rule.value;\n          \n          // Handle array responses (multi-select questions)\n          if (Array.isArray(propValue)) {\n            // For array values, check if compareValue is included in the array\n            switch (rule.op) {\n              case '==':\n                return propValue.includes(compareValue);\n              case '!=':\n                return !propValue.includes(compareValue);\n              default:\n                return false; // Comparison operators don't make sense for arrays\n            }\n          }\n          \n          // Convertir valores para comparaci√≥n (for non-array values)\n          const numPropValue = parseFloat(propValue);\n          const numCompareValue = parseFloat(compareValue);\n          const isNumeric = !isNaN(numPropValue) && !isNaN(numCompareValue);\n          \n          switch (rule.op) {\n            case '==':\n              return isNumeric ? numPropValue === numCompareValue : propValue == compareValue;\n            case '!=':\n              return isNumeric ? numPropValue !== numCompareValue : propValue != compareValue;\n            case '>':\n              return isNumeric && numPropValue > numCompareValue;\n            case '<':\n              return isNumeric && numPropValue < numCompareValue;\n            case '>=':\n              return isNumeric && numPropValue >= numCompareValue;\n            case '<=':\n              return isNumeric && numPropValue <= numCompareValue;\n            default:\n              return false;\n          }\n        });\n        \n        if (allRulesMatch && condition.jumpToTrialId) {\n          console.log('Repeat condition matched! Jumping to trial:', condition.jumpToTrialId);\n          // Guardar el trial objetivo en localStorage\n          localStorage.setItem('jsPsych_jumpToTrial', String(condition.jumpToTrialId));\n          shouldRepeat = true;\n          break;\n        }\n      }\n      \n      if (shouldRepeat) {\n        // Limpiar el contenedor de jsPsych (jspsych-container es el display_element)\n        const container = document.getElementById('jspsych-container');\n        if (container) {\n          // Limpiar todo el contenido del container\n          container.innerHTML = '';\n        }\n        // Reiniciar el timeline\n        setTimeout(() => {\n          jsPsych.run(timeline);\n        }, 100);\n        return;\n      }\n      \n    },};\n    console.log(\"=== PROCEDURE SETUP New_Trial_2 ===\");\n    console.log(\"test_stimuli_New_Trial_2 before procedure:\", test_stimuli_New_Trial_2);\n    console.log(\"test_stimuli_New_Trial_2.length:\", test_stimuli_New_Trial_2 ? test_stimuli_New_Trial_2.length : 'undefined');\n    \n    const New_Trial_2_procedure = {\n    timeline: \n    [New_Trial_2_timeline],\n    timeline_variables: test_stimuli_New_Trial_2,\n    \n    conditional_function: function() {\n      const currentId = 1771712363606;\n      \n      // Verificar si hay un trial objetivo guardado en localStorage (para repeat/jump)\n      const jumpToTrial = localStorage.getItem('jsPsych_jumpToTrial');\n      if (jumpToTrial) {\n        if (String(currentId) === String(jumpToTrial)) {\n          // Encontramos el trial objetivo para repeat/jump\n          console.log('üîÅ [REPEAT/JUMP] Found target trial', currentId);\n          localStorage.removeItem('jsPsych_jumpToTrial');\n          return true;\n        }\n        // No es el objetivo, saltar\n        console.log('‚è≠Ô∏è [REPEAT/JUMP] Skipping trial', currentId);\n        return false;\n      }\n      \n      // Si skipRemaining est√° activo (branching normal), verificar si este es el trial objetivo\n      if (window.skipRemaining) {\n        console.log('üîç [SKIP CHECK] Trial', currentId, '| Target:', window.nextTrialId, '| Match:', String(currentId) === String(window.nextTrialId));\n        if (String(currentId) === String(window.nextTrialId)) {\n          // Encontramos el trial objetivo\n          console.log('‚úÖ [SKIP CHECK] Found target trial! Disabling skip mode');\n          window.skipRemaining = false;\n          window.nextTrialId = null;\n          return true;\n        }\n        // No es el objetivo, saltar\n        console.log('‚è≠Ô∏è [SKIP CHECK] Skipping trial', currentId);\n        return false;\n      }\n      \n      return true;\n    },\n  \n    \n    };\n    timeline.push(New_Trial_2_procedure);\n  \n\n    jsPsych.run(timeline);\n    \n\n\n})();\n"
      },
      "isDevMode": false,
      "createdAt": "2026-02-18T21:22:59.656Z",
      "updatedAt": "2026-02-21T23:24:24.860Z"
    }
  ],
  "pluginConfigs": [
    {
      "plugins": [],
      "config": {}
    }
  ],
  "sessionResults": []
}