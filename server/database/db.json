{
  "experiments": [
    {
      "experimentID": "4bd964f3-1936-452f-a744-fcdffc938976",
      "name": "re",
      "createdAt": "2026-01-16T00:01:57.283Z",
      "updatedAt": "2026-01-16T00:01:57.283Z"
    }
  ],
  "trials": [
    {
      "experimentID": "4bd964f3-1936-452f-a744-fcdffc938976",
      "trials": [
        {
          "type": "Trial",
          "name": "nPreguntasmdns",
          "parameters": {
            "includesExtensions": false,
            "extensionType": ""
          },
          "trialCode": "\n    const test_stimuli_nPreguntasmdns = [{components: [{ type: \"HtmlComponent\", coordinates: {\"x\":0.278688524590164,\"y\":0.6065573770491802}, width: 200, height: 50, stimulus: \"<div style=\\\"box-sizing: border-box;\\\">Type or design here</div>\" }],\nresponse_components: [],\nstimuli_duration: undefined,\ntrial_duration: undefined,\nresponse_ends_trial: undefined}];\n    const nPreguntasmdns_timeline = {\n    type: DynamicPlugin, components: jsPsych.timelineVariable(\"components\"),\nresponse_components: jsPsych.timelineVariable(\"response_components\"),\nstimuli_duration: jsPsych.timelineVariable(\"stimuli_duration\"),\ntrial_duration: jsPsych.timelineVariable(\"trial_duration\"),\nresponse_ends_trial: jsPsych.timelineVariable(\"response_ends_trial\"),\n      data: {\n        rt: \"rt\",\n        trial_id: 1768521719165,\n        \n        \n        branches: [1768521892763, 1768524559825],\n        branchConditions: [[{\"id\":1768535708995,\"rules\":[{\"column\":\"boton_type\",\"op\":\"==\",\"value\":\"mjnlnmn\"}],\"nextTrialId\":\"1768521892763\",\"customParameters\":{\"components\":{\"source\":\"none\",\"value\":null}}}]] \n        \n      },\n    on_start: function(trial) {\n      // Then apply custom parameters from branching conditions (higher priority)\n      // For trials outside loops, use window.branchCustomParameters\n      if (window.branchCustomParameters && typeof window.branchCustomParameters === 'object') {\n        Object.entries(window.branchCustomParameters).forEach(([key, param]) => {\n          if (param && param.source !== 'none') {\n            // Parse key to check if it's a nested survey question\n            const parts = key.split('::');\n            \n            if (parts.length === 4) {\n              // Format: fieldType::componentName::survey_json::questionName\n              const [fieldType, componentName, propName, questionName] = parts;\n              \n              if (fieldType && componentName && propName === 'survey_json' && questionName) {\n                // Find the component by name in the field array\n                const fieldArray = trial[fieldType];\n                if (Array.isArray(fieldArray)) {\n                  const compIndex = fieldArray.findIndex(c => c.name === componentName);\n                  if (compIndex !== -1 && fieldArray[compIndex].survey_json) {\n                    // Find the question in survey_json.elements\n                    const elements = fieldArray[compIndex].survey_json.elements || [];\n                    const questionIndex = elements.findIndex(q => q.name === questionName);\n                    \n                    if (questionIndex !== -1) {\n                      // Apply the override value (from typed or csv)\n                      let valueToSet;\n                      if (param.source === 'typed') {\n                        valueToSet = String(param.value); // Convert to string for SurveyJS\n                      } else if (param.source === 'csv') {\n                        valueToSet = String(trial[param.value]); // Get from CSV column and convert to string\n                      }\n                      \n                      if (valueToSet !== undefined && valueToSet !== null) {\n                        fieldArray[compIndex].survey_json.elements[questionIndex].defaultValue = valueToSet;\n                      }\n                    }\n                  }\n                }\n              }\n            } else {\n              // Normal parameter (not nested survey question)\n              if (param.source === 'typed' && param.value !== undefined && param.value !== null) {\n                trial[key] = param.value;\n              } else if (param.source === 'csv' && param.value !== undefined && param.value !== null) {\n                trial[key] = trial[param.value];\n              }\n            }\n          }\n        });\n        // Clear the custom parameters after applying them\n        window.branchCustomParameters = null;\n      }\n      \n    },\n    on_finish: function(data) {\n      // Evaluar condiciones del trial para branching global\n      console.log('üîç [GLOBAL BRANCH] Evaluating branch conditions...');\n      const branches = [1768521892763, 1768524559825];\n      const branchConditions = [{\"id\":1768535708995,\"rules\":[{\"column\":\"boton_type\",\"op\":\"==\",\"value\":\"mjnlnmn\"}],\"nextTrialId\":\"1768521892763\",\"customParameters\":{\"components\":{\"source\":\"none\",\"value\":null}}}].flat();\n      console.log('üîç [GLOBAL BRANCH] Available branches:', branches);\n      console.log('üîç [GLOBAL BRANCH] Conditions to evaluate:', branchConditions.length);\n      \n      let nextTrialId = null;\n      let matchedCustomParameters = null;\n      \n      // Evaluar cada condici√≥n (l√≥gica OR entre condiciones)\n      for (const condition of branchConditions) {\n        if (!condition || !condition.rules) {\n          continue;\n        }\n        \n        // Todas las reglas en una condici√≥n deben ser verdaderas (l√≥gica AND)\n        const allRulesMatch = condition.rules.every(rule => {\n          let propValue;\n          \n          // Parse column name to extract component info for dynamic plugins\n          // Format: \"componentName_propertyName\" or \"componentName_questionName\" for surveys\n          const columnName = rule.column || rule.prop || \"\";\n          const parts = columnName.split(\"_\");\n          \n          // Check if this looks like a dynamic plugin column (has underscore)\n          if (parts.length >= 2) {\n            // Last part is the property or question name\n            const propertyOrQuestion = parts[parts.length - 1];\n            // Everything before the last underscore is the component name\n            const componentName = parts.slice(0, -1).join(\"_\");\n            \n            // Try to find the data in the format: componentName_response\n            const responseKey = componentName + '_response';\n            const responseData = data[responseKey];\n            \n            // If response data exists and is an object (SurveyComponent case)\n            if (responseData && typeof responseData === 'object' && !Array.isArray(responseData)) {\n              // This is likely a survey response - check if property is a question name\n              if (responseData[propertyOrQuestion] !== undefined) {\n                propValue = responseData[propertyOrQuestion];\n              } else {\n                return false;\n              }\n            } else {\n              // Not a survey response object, try direct property access\n              const directKey = componentName + '_' + propertyOrQuestion;\n              if (data[directKey] !== undefined) {\n                propValue = data[directKey];\n              } else {\n                return false;\n              }\n            }\n          } else {\n            // Normal plugin structure - direct property access\n            propValue = data[columnName];\n          }\n          \n          const compareValue = rule.value;\n          \n          // Handle array responses (multi-select or single-select returned as array)\n          if (Array.isArray(propValue)) {\n            const matches = propValue.includes(compareValue) || propValue.includes(String(compareValue));\n            switch (rule.op) {\n              case '==':\n                return matches;\n              case '!=':\n                return !matches;\n              default:\n                return false;\n            }\n          }\n          \n          // Convertir valores para comparaci√≥n\n          const numPropValue = parseFloat(propValue);\n          const numCompareValue = parseFloat(compareValue);\n          const isNumeric = !isNaN(numPropValue) && !isNaN(numCompareValue);\n          \n          switch (rule.op) {\n            case '==':\n              return isNumeric ? numPropValue === numCompareValue : propValue == compareValue;\n            case '!=':\n              return isNumeric ? numPropValue !== numCompareValue : propValue != compareValue;\n            case '>':\n              return isNumeric && numPropValue > numCompareValue;\n            case '<':\n              return isNumeric && numPropValue < numCompareValue;\n            case '>=':\n              return isNumeric && numPropValue >= numCompareValue;\n            case '<=':\n              return isNumeric && numPropValue <= numCompareValue;\n            default:\n              return false;\n          }\n        });\n        \n        if (allRulesMatch) {\n          console.log('‚úÖ [GLOBAL BRANCH] Condition matched! Next trial:', condition.nextTrialId);\n          nextTrialId = condition.nextTrialId;\n          // Store custom parameters if they exist\n          if (condition.customParameters) {\n            matchedCustomParameters = condition.customParameters;\n            console.log('‚úÖ [GLOBAL BRANCH] Custom parameters:', matchedCustomParameters);\n          }\n          break;\n        }\n      }\n      \n      // Si se encontr√≥ match, activar branching\n      if (nextTrialId) {\n        console.log('üéØ [GLOBAL BRANCH] Activating branching to trial:', nextTrialId);\n        window.nextTrialId = nextTrialId;\n        window.skipRemaining = true;\n        window.branchingActive = true;\n        // Store custom parameters for the next trial\n        if (matchedCustomParameters) {\n          window.branchCustomParameters = matchedCustomParameters;\n        }\n      } else {\n        // No match - ir al primer branch por defecto\n        console.log('‚ö†Ô∏è [GLOBAL BRANCH] No condition matched, branching to first branch:', branches[0]);\n        window.nextTrialId = branches[0];\n        window.skipRemaining = true;\n        window.branchingActive = true;\n      }\n      \n    },};\n    const nPreguntasmdns_procedure = {\n    timeline: \n    [nPreguntasmdns_timeline],\n    timeline_variables: test_stimuli_nPreguntasmdns,\n    \n    conditional_function: function() {\n      const currentId = 1768521719165;\n      \n      // Verificar si hay un trial objetivo guardado en localStorage (para repeat/jump)\n      const jumpToTrial = localStorage.getItem('jsPsych_jumpToTrial');\n      if (jumpToTrial) {\n        if (String(currentId) === String(jumpToTrial)) {\n          // Encontramos el trial objetivo para repeat/jump\n          console.log('üîÅ [REPEAT/JUMP] Found target trial', currentId);\n          localStorage.removeItem('jsPsych_jumpToTrial');\n          return true;\n        }\n        // No es el objetivo, saltar\n        console.log('‚è≠Ô∏è [REPEAT/JUMP] Skipping trial', currentId);\n        return false;\n      }\n      \n      // Si skipRemaining est√° activo (branching normal), verificar si este es el trial objetivo\n      if (window.skipRemaining) {\n        console.log('üîç [SKIP CHECK] Trial', currentId, '| Target:', window.nextTrialId, '| Match:', String(currentId) === String(window.nextTrialId));\n        if (String(currentId) === String(window.nextTrialId)) {\n          // Encontramos el trial objetivo\n          console.log('‚úÖ [SKIP CHECK] Found target trial! Disabling skip mode');\n          window.skipRemaining = false;\n          window.nextTrialId = null;\n          return true;\n        }\n        // No es el objetivo, saltar\n        console.log('‚è≠Ô∏è [SKIP CHECK] Skipping trial', currentId);\n        return false;\n      }\n      \n      return true;\n    },\n  \n    \n    };\n    timeline.push(nPreguntasmdns_procedure);\n  ",
          "id": 1768521719165,
          "createdAt": "2026-01-16T00:01:59.165Z",
          "updatedAt": "2026-01-18T03:20:07.786Z",
          "branches": [
            1768521892763,
            "loop_1768683384399"
          ],
          "plugin": "plugin-dynamic",
          "columnMapping": {
            "response_components": {
              "source": "typed",
              "value": [
                {
                  "type": "SketchpadComponent",
                  "coordinates": {
                    "x": 0,
                    "y": 0
                  },
                  "width": 200,
                  "height": 200,
                  "name": {
                    "source": "typed",
                    "value": "SketchpadComponent_1"
                  }
                }
              ]
            },
            "components": {
              "source": "typed",
              "value": [
                {
                  "type": "HtmlComponent",
                  "coordinates": {
                    "x": 0,
                    "y": 0
                  },
                  "width": 200,
                  "height": 50,
                  "name": {
                    "source": "typed",
                    "value": "HtmlComponent_1"
                  },
                  "stimulus": {
                    "source": "typed",
                    "value": "<div id=\"in5s\" style=\"box-sizing: border-box;\">Type or design here</div>"
                  }
                }
              ]
            }
          },
          "csvJson": [],
          "csvColumns": [],
          "orders": false,
          "orderColumns": [],
          "stimuliOrders": [],
          "categories": false,
          "categoryColumn": "",
          "categoryData": [],
          "parentLoopId": null,
          "branchConditions": [],
          "repeatConditions": [],
          "paramsOverride": []
        },
        {
          "type": "Trial",
          "name": "New Trial 1",
          "parameters": {
            "include_instructions": {
              "plugin-webgazer-init-camera": false,
              "plugin-webgazer-calibrate": true,
              "plugin-webgazer-validate": false,
              "plugin-webgazer-recalibrate": false
            },
            "minimum_percent": 50
          },
          "trialCode": "\n    const test_stimuli_plugin_webgazer_init_camera = [{instructions: \"`\\n            <p>Position your head so that the webcam has a good view of your eyes.</p>\\n            <p>Center your face in the box and look directly towards the camera.</p>\\n            <p>It is important that you try and keep your head reasonably still throughout the experiment, so please take a moment to adjust your setup to be comfortable.</p>\\n            <p>When your face is centered in the box and the box is green, you can click to continue.</p>`\",\nbutton_text: \"Continue\"}];\n\n    \n    const plugin_webgazer_init_camera_timeline = {\n    type: jsPsychWebgazerInitCamera, \n    instructions: jsPsych.timelineVariable(\"instructions\"),\nbutton_text: jsPsych.timelineVariable(\"button_text\"),\n    data: {\n      load_time: \"load_time\",\n    },\n    on_start: function(trial) {\n      // Then apply custom parameters from branching conditions (higher priority)\n      // For trials outside loops, use window.branchCustomParameters\n      if (window.branchCustomParameters && typeof window.branchCustomParameters === 'object') {\n        Object.entries(window.branchCustomParameters).forEach(([key, param]) => {\n          if (param && param.source !== 'none') {\n            // Parse key to check if it's a nested survey question\n            const parts = key.split('::');\n            \n            if (parts.length === 4) {\n              // Format: fieldType::componentName::survey_json::questionName\n              const [fieldType, componentName, propName, questionName] = parts;\n              \n              if (fieldType && componentName && propName === 'survey_json' && questionName) {\n                // Find the component by name in the field array\n                const fieldArray = trial[fieldType];\n                if (Array.isArray(fieldArray)) {\n                  const compIndex = fieldArray.findIndex(c => c.name === componentName);\n                  if (compIndex !== -1 && fieldArray[compIndex].survey_json) {\n                    // Find the question in survey_json.elements\n                    const elements = fieldArray[compIndex].survey_json.elements || [];\n                    const questionIndex = elements.findIndex(q => q.name === questionName);\n                    \n                    if (questionIndex !== -1) {\n                      // Apply the override value (from typed or csv)\n                      let valueToSet;\n                      if (param.source === 'typed') {\n                        valueToSet = String(param.value); // Convert to string for SurveyJS\n                      } else if (param.source === 'csv') {\n                        valueToSet = String(trial[param.value]); // Get from CSV column and convert to string\n                      }\n                      \n                      if (valueToSet !== undefined && valueToSet !== null) {\n                        fieldArray[compIndex].survey_json.elements[questionIndex].defaultValue = valueToSet;\n                      }\n                    }\n                  }\n                }\n              }\n            } else {\n              // Normal parameter (not nested survey question)\n              if (param.source === 'typed' && param.value !== undefined && param.value !== null) {\n                trial[key] = param.value;\n              } else if (param.source === 'csv' && param.value !== undefined && param.value !== null) {\n                trial[key] = trial[param.value];\n              }\n            }\n          }\n        });\n        // Clear the custom parameters after applying them\n        window.branchCustomParameters = null;\n      }\n      \n    },\n    on_finish: function(data) {\n      // Trial terminal - si llegamos aqu√≠ despu√©s de branching, terminar el experimento\n      if (window.branchingActive) {\n        jsPsych.abortExperiment('', {});\n      }\n    },\n    };;\n    \n    const plugin_webgazer_init_camera_procedure = {\n    timeline: \n    [\n    \n    \n    plugin_webgazer_init_camera_timeline \n    ],\n    timeline_variables: test_stimuli_plugin_webgazer_init_camera,\n    \n    conditional_function: function() {\n      const currentId = 1768521892763;\n      \n      // Verificar si hay un trial objetivo guardado en localStorage (para repeat/jump)\n      const jumpToTrial = localStorage.getItem('jsPsych_jumpToTrial');\n      if (jumpToTrial) {\n        if (String(currentId) === String(jumpToTrial)) {\n          // Encontramos el trial objetivo para repeat/jump\n          console.log('üîÅ [REPEAT/JUMP] Found target trial', currentId);\n          localStorage.removeItem('jsPsych_jumpToTrial');\n          return true;\n        }\n        // No es el objetivo, saltar\n        console.log('‚è≠Ô∏è [REPEAT/JUMP] Skipping trial', currentId);\n        return false;\n      }\n      \n      // Si skipRemaining est√° activo (branching normal), verificar si este es el trial objetivo\n      if (window.skipRemaining) {\n        console.log('üîç [SKIP CHECK] Trial', currentId, '| Target:', window.nextTrialId, '| Match:', String(currentId) === String(window.nextTrialId));\n        if (String(currentId) === String(window.nextTrialId)) {\n          // Encontramos el trial objetivo\n          console.log('‚úÖ [SKIP CHECK] Found target trial! Disabling skip mode');\n          window.skipRemaining = false;\n          window.nextTrialId = null;\n          return true;\n        }\n        // No es el objetivo, saltar\n        console.log('‚è≠Ô∏è [SKIP CHECK] Skipping trial', currentId);\n        return false;\n      }\n      \n      return true;\n    },\n  \n  };\n    timeline.push(plugin_webgazer_init_camera_procedure);\n  ;const plugin_webgazer_calibrate_instructions = {\n      type: jsPsychHtmlButtonResponse,\n      stimulus: jsPsych.timelineVariable(\"plugin_webgazer_calibrate_instructions\"),\n      choices: jsPsych.timelineVariable(\"plugin_webgazer_calibrate_choices\"),\n    };\n    const test_stimuli_plugin_webgazer_calibrate = [{calibration_points: [[10,10],[10,50],[10,90],[50,10],[50,50],[50,90],[90,10],[90,50],[90,90]],\ncalibration_mode: \"click\",\npoint_size: 20,\nrepetitions_per_point: 1,\nrandomize_calibration_order: false,\ntime_to_saccade: 1000,\ntime_per_point: 1000,\nplugin_webgazer_calibrate_instructions: \"\\n          <p>Now you'll calibrate the eye tracking, so that the software can use the image of your eyes to predict where you are looking.</p>\\n          <p>You'll see a series of dots appear on the screen. Look at each dot and click on it.</p>\\n        \",\nplugin_webgazer_calibrate_choices: [\"Got it\"]}];\n\n    \n    const plugin_webgazer_calibrate_timeline = {\n    type: jsPsychWebgazerCalibrate, \n    calibration_points: jsPsych.timelineVariable(\"calibration_points\"),\ncalibration_mode: jsPsych.timelineVariable(\"calibration_mode\"),\npoint_size: jsPsych.timelineVariable(\"point_size\"),\nrepetitions_per_point: jsPsych.timelineVariable(\"repetitions_per_point\"),\nrandomize_calibration_order: jsPsych.timelineVariable(\"randomize_calibration_order\"),\ntime_to_saccade: jsPsych.timelineVariable(\"time_to_saccade\"),\ntime_per_point: jsPsych.timelineVariable(\"time_per_point\"),\n    data: {\n      \n    },\n    on_start: function(trial) {\n      // Then apply custom parameters from branching conditions (higher priority)\n      // For trials outside loops, use window.branchCustomParameters\n      if (window.branchCustomParameters && typeof window.branchCustomParameters === 'object') {\n        Object.entries(window.branchCustomParameters).forEach(([key, param]) => {\n          if (param && param.source !== 'none') {\n            // Parse key to check if it's a nested survey question\n            const parts = key.split('::');\n            \n            if (parts.length === 4) {\n              // Format: fieldType::componentName::survey_json::questionName\n              const [fieldType, componentName, propName, questionName] = parts;\n              \n              if (fieldType && componentName && propName === 'survey_json' && questionName) {\n                // Find the component by name in the field array\n                const fieldArray = trial[fieldType];\n                if (Array.isArray(fieldArray)) {\n                  const compIndex = fieldArray.findIndex(c => c.name === componentName);\n                  if (compIndex !== -1 && fieldArray[compIndex].survey_json) {\n                    // Find the question in survey_json.elements\n                    const elements = fieldArray[compIndex].survey_json.elements || [];\n                    const questionIndex = elements.findIndex(q => q.name === questionName);\n                    \n                    if (questionIndex !== -1) {\n                      // Apply the override value (from typed or csv)\n                      let valueToSet;\n                      if (param.source === 'typed') {\n                        valueToSet = String(param.value); // Convert to string for SurveyJS\n                      } else if (param.source === 'csv') {\n                        valueToSet = String(trial[param.value]); // Get from CSV column and convert to string\n                      }\n                      \n                      if (valueToSet !== undefined && valueToSet !== null) {\n                        fieldArray[compIndex].survey_json.elements[questionIndex].defaultValue = valueToSet;\n                      }\n                    }\n                  }\n                }\n              }\n            } else {\n              // Normal parameter (not nested survey question)\n              if (param.source === 'typed' && param.value !== undefined && param.value !== null) {\n                trial[key] = param.value;\n              } else if (param.source === 'csv' && param.value !== undefined && param.value !== null) {\n                trial[key] = trial[param.value];\n              }\n            }\n          }\n        });\n        // Clear the custom parameters after applying them\n        window.branchCustomParameters = null;\n      }\n      \n    },\n    on_finish: function(data) {\n      // Trial terminal - si llegamos aqu√≠ despu√©s de branching, terminar el experimento\n      if (window.branchingActive) {\n        jsPsych.abortExperiment('', {});\n      }\n    },\n    };;\n    \n    const plugin_webgazer_calibrate_procedure = {\n    timeline: \n    [\n    plugin_webgazer_calibrate_instructions,\n    \n    plugin_webgazer_calibrate_timeline \n    ],\n    timeline_variables: test_stimuli_plugin_webgazer_calibrate,\n    \n    conditional_function: function() {\n      const currentId = 1768521892763;\n      \n      // Verificar si hay un trial objetivo guardado en localStorage (para repeat/jump)\n      const jumpToTrial = localStorage.getItem('jsPsych_jumpToTrial');\n      if (jumpToTrial) {\n        if (String(currentId) === String(jumpToTrial)) {\n          // Encontramos el trial objetivo para repeat/jump\n          console.log('üîÅ [REPEAT/JUMP] Found target trial', currentId);\n          localStorage.removeItem('jsPsych_jumpToTrial');\n          return true;\n        }\n        // No es el objetivo, saltar\n        console.log('‚è≠Ô∏è [REPEAT/JUMP] Skipping trial', currentId);\n        return false;\n      }\n      \n      // Si skipRemaining est√° activo (branching normal), verificar si este es el trial objetivo\n      if (window.skipRemaining) {\n        console.log('üîç [SKIP CHECK] Trial', currentId, '| Target:', window.nextTrialId, '| Match:', String(currentId) === String(window.nextTrialId));\n        if (String(currentId) === String(window.nextTrialId)) {\n          // Encontramos el trial objetivo\n          console.log('‚úÖ [SKIP CHECK] Found target trial! Disabling skip mode');\n          window.skipRemaining = false;\n          window.nextTrialId = null;\n          return true;\n        }\n        // No es el objetivo, saltar\n        console.log('‚è≠Ô∏è [SKIP CHECK] Skipping trial', currentId);\n        return false;\n      }\n      \n      return true;\n    },\n  \n  };\n    timeline.push(plugin_webgazer_calibrate_procedure);\n  ;\n    const test_stimuli_plugin_webgazer_validate = [{validation_points: [[10,10],[10,50],[10,90],[50,10],[50,50],[50,90],[90,10],[90,50],[90,90]],\nvalidation_point_coordinates: \"percent\",\nroi_radius: 200,\nrandomize_validation_order: false,\ntime_to_saccade: 1000,\nvalidation_duration: 2000,\npoint_size: 20,\nshow_validation_data: false}];\n\n    \n    const plugin_webgazer_validate_timeline = {\n    type: jsPsychWebgazerValidate, validation_points: jsPsych.timelineVariable(\"validation_points\"),\nvalidation_point_coordinates: jsPsych.timelineVariable(\"validation_point_coordinates\"),\nroi_radius: jsPsych.timelineVariable(\"roi_radius\"),\nrandomize_validation_order: jsPsych.timelineVariable(\"randomize_validation_order\"),\ntime_to_saccade: jsPsych.timelineVariable(\"time_to_saccade\"),\nvalidation_duration: jsPsych.timelineVariable(\"validation_duration\"),\npoint_size: jsPsych.timelineVariable(\"point_size\"),\nshow_validation_data: jsPsych.timelineVariable(\"show_validation_data\"),\n    data: {\n      task: 'validate'\n    }\n    on_start: function(trial) {\n      // Then apply custom parameters from branching conditions (higher priority)\n      // For trials outside loops, use window.branchCustomParameters\n      if (window.branchCustomParameters && typeof window.branchCustomParameters === 'object') {\n        Object.entries(window.branchCustomParameters).forEach(([key, param]) => {\n          if (param && param.source !== 'none') {\n            // Parse key to check if it's a nested survey question\n            const parts = key.split('::');\n            \n            if (parts.length === 4) {\n              // Format: fieldType::componentName::survey_json::questionName\n              const [fieldType, componentName, propName, questionName] = parts;\n              \n              if (fieldType && componentName && propName === 'survey_json' && questionName) {\n                // Find the component by name in the field array\n                const fieldArray = trial[fieldType];\n                if (Array.isArray(fieldArray)) {\n                  const compIndex = fieldArray.findIndex(c => c.name === componentName);\n                  if (compIndex !== -1 && fieldArray[compIndex].survey_json) {\n                    // Find the question in survey_json.elements\n                    const elements = fieldArray[compIndex].survey_json.elements || [];\n                    const questionIndex = elements.findIndex(q => q.name === questionName);\n                    \n                    if (questionIndex !== -1) {\n                      // Apply the override value (from typed or csv)\n                      let valueToSet;\n                      if (param.source === 'typed') {\n                        valueToSet = String(param.value); // Convert to string for SurveyJS\n                      } else if (param.source === 'csv') {\n                        valueToSet = String(trial[param.value]); // Get from CSV column and convert to string\n                      }\n                      \n                      if (valueToSet !== undefined && valueToSet !== null) {\n                        fieldArray[compIndex].survey_json.elements[questionIndex].defaultValue = valueToSet;\n                      }\n                    }\n                  }\n                }\n              }\n            } else {\n              // Normal parameter (not nested survey question)\n              if (param.source === 'typed' && param.value !== undefined && param.value !== null) {\n                trial[key] = param.value;\n              } else if (param.source === 'csv' && param.value !== undefined && param.value !== null) {\n                trial[key] = trial[param.value];\n              }\n            }\n          }\n        });\n        // Clear the custom parameters after applying them\n        window.branchCustomParameters = null;\n      }\n      \n    },\n    on_finish: function(data) {\n      // Trial terminal - si llegamos aqu√≠ despu√©s de branching, terminar el experimento\n      if (window.branchingActive) {\n        jsPsych.abortExperiment('', {});\n      }\n    },\n    };;\n    \n    const plugin_webgazer_validate_procedure = {\n    timeline: \n    [\n    \n    \n    plugin_webgazer_validate_timeline \n    ],\n    timeline_variables: test_stimuli_plugin_webgazer_validate,\n    \n    conditional_function: function() {\n      const currentId = 1768521892763;\n      \n      // Verificar si hay un trial objetivo guardado en localStorage (para repeat/jump)\n      const jumpToTrial = localStorage.getItem('jsPsych_jumpToTrial');\n      if (jumpToTrial) {\n        if (String(currentId) === String(jumpToTrial)) {\n          // Encontramos el trial objetivo para repeat/jump\n          console.log('üîÅ [REPEAT/JUMP] Found target trial', currentId);\n          localStorage.removeItem('jsPsych_jumpToTrial');\n          return true;\n        }\n        // No es el objetivo, saltar\n        console.log('‚è≠Ô∏è [REPEAT/JUMP] Skipping trial', currentId);\n        return false;\n      }\n      \n      // Si skipRemaining est√° activo (branching normal), verificar si este es el trial objetivo\n      if (window.skipRemaining) {\n        console.log('üîç [SKIP CHECK] Trial', currentId, '| Target:', window.nextTrialId, '| Match:', String(currentId) === String(window.nextTrialId));\n        if (String(currentId) === String(window.nextTrialId)) {\n          // Encontramos el trial objetivo\n          console.log('‚úÖ [SKIP CHECK] Found target trial! Disabling skip mode');\n          window.skipRemaining = false;\n          window.nextTrialId = null;\n          return true;\n        }\n        // No es el objetivo, saltar\n        console.log('‚è≠Ô∏è [SKIP CHECK] Skipping trial', currentId);\n        return false;\n      }\n      \n      return true;\n    },\n  \n  };\n    timeline.push(plugin_webgazer_validate_procedure);\n  ;\n    const test_stimuli_plugin_webgazer_recalibrate = [{}];\n\n    ;\n    \n    const plugin_webgazer_recalibrate_procedure = {\n    timeline: \n    [\n    \n    \n    \n    ],\n    timeline_variables: test_stimuli_plugin_webgazer_recalibrate,\n    \n    conditional_function: function() {\n      const currentId = 1768521892763;\n      \n      // Verificar si hay un trial objetivo guardado en localStorage (para repeat/jump)\n      const jumpToTrial = localStorage.getItem('jsPsych_jumpToTrial');\n      if (jumpToTrial) {\n        if (String(currentId) === String(jumpToTrial)) {\n          // Encontramos el trial objetivo para repeat/jump\n          console.log('üîÅ [REPEAT/JUMP] Found target trial', currentId);\n          localStorage.removeItem('jsPsych_jumpToTrial');\n          return true;\n        }\n        // No es el objetivo, saltar\n        console.log('‚è≠Ô∏è [REPEAT/JUMP] Skipping trial', currentId);\n        return false;\n      }\n      \n      // Si skipRemaining est√° activo (branching normal), verificar si este es el trial objetivo\n      if (window.skipRemaining) {\n        console.log('üîç [SKIP CHECK] Trial', currentId, '| Target:', window.nextTrialId, '| Match:', String(currentId) === String(window.nextTrialId));\n        if (String(currentId) === String(window.nextTrialId)) {\n          // Encontramos el trial objetivo\n          console.log('‚úÖ [SKIP CHECK] Found target trial! Disabling skip mode');\n          window.skipRemaining = false;\n          window.nextTrialId = null;\n          return true;\n        }\n        // No es el objetivo, saltar\n        console.log('‚è≠Ô∏è [SKIP CHECK] Skipping trial', currentId);\n        return false;\n      }\n      \n      return true;\n    },\n  \n  };\n    timeline.push(plugin_webgazer_recalibrate_procedure);\n  ;\n    const recalibrate_timeline = {\n        timeline: [\n        plugin_webgazer_calibrate_procedure, plugin_webgazer_validate_procedure],\n        conditional_function: function(){\n          var validation_data = jsPsych.data.get().filter({task: 'validate'}).values()[0];\n          return validation_data.percent_in_roi.some(function(x){\n            var minimum_percent_acceptable = 50;\n            return x < minimum_percent_acceptable;\n          });\n        },\n        data: {\n          phase: 'recalibration'\n        }\n      } \n const recalibrateWebGazer_procedure = {\n    timeline: \n    [recalibrate_timeline],\n    timeline_variables: test_stimuli_plugin_webgazer_recalibrate,\n    \n    conditional_function: function() {\n      const currentId = 1768521892763;\n      \n      // Verificar si hay un trial objetivo guardado en localStorage (para repeat/jump)\n      const jumpToTrial = localStorage.getItem('jsPsych_jumpToTrial');\n      if (jumpToTrial) {\n        if (String(currentId) === String(jumpToTrial)) {\n          // Encontramos el trial objetivo para repeat/jump\n          console.log('üîÅ [REPEAT/JUMP] Found target trial', currentId);\n          localStorage.removeItem('jsPsych_jumpToTrial');\n          return true;\n        }\n        // No es el objetivo, saltar\n        console.log('‚è≠Ô∏è [REPEAT/JUMP] Skipping trial', currentId);\n        return false;\n      }\n      \n      // Si skipRemaining est√° activo (branching normal), verificar si este es el trial objetivo\n      if (window.skipRemaining) {\n        console.log('üîç [SKIP CHECK] Trial', currentId, '| Target:', window.nextTrialId, '| Match:', String(currentId) === String(window.nextTrialId));\n        if (String(currentId) === String(window.nextTrialId)) {\n          // Encontramos el trial objetivo\n          console.log('‚úÖ [SKIP CHECK] Found target trial! Disabling skip mode');\n          window.skipRemaining = false;\n          window.nextTrialId = null;\n          return true;\n        }\n        // No es el objetivo, saltar\n        console.log('‚è≠Ô∏è [SKIP CHECK] Skipping trial', currentId);\n        return false;\n      }\n      \n      return true;\n    },\n  \n  };\n    timeline.push(recalibrateWebGazer_procedure);\n  ;const calibration_done = {\n        type: jsPsychHtmlButtonResponse,\n        stimulus: `\n          <p>Great, we're done with calibration!</p>\n        `,\n        choices: ['OK']\n      }\n    timeline.push(calibration_done);\n",
          "id": 1768521892763,
          "createdAt": "2026-01-16T00:04:52.763Z",
          "updatedAt": "2026-01-18T03:07:11.601Z",
          "branches": [],
          "plugin": "plugin-dynamic",
          "columnMapping": {
            "components": {
              "source": "typed",
              "value": [
                {
                  "type": "HtmlComponent",
                  "coordinates": {
                    "x": -0.032786885245901676,
                    "y": -0.3661202185792351
                  },
                  "width": 200,
                  "height": 50,
                  "name": {
                    "source": "typed",
                    "value": "HtmlComponent_1"
                  }
                }
              ]
            },
            "response_components": {
              "source": "typed",
              "value": [
                {
                  "type": "ButtonResponseComponent",
                  "coordinates": {
                    "x": -0.032786885245901676,
                    "y": 0.26775956284152996
                  },
                  "width": 200,
                  "height": 50,
                  "name": {
                    "source": "typed",
                    "value": "ButtonResponseComponent_1"
                  },
                  "choices": {
                    "source": "typed",
                    "value": [
                      "loa"
                    ]
                  }
                },
                {
                  "type": "SurveyComponent",
                  "coordinates": {
                    "x": 0,
                    "y": 0
                  },
                  "width": 200,
                  "height": 50,
                  "name": {
                    "source": "typed",
                    "value": "SurveyComponent_1"
                  },
                  "survey_json": {
                    "source": "typed",
                    "value": {
                      "title": "My Survey",
                      "elements": [
                        {
                          "type": "text",
                          "name": "question1",
                          "title": "Question 1",
                          "isRequired": false
                        }
                      ]
                    }
                  }
                }
              ]
            }
          },
          "csvJson": [],
          "csvColumns": [],
          "orders": false,
          "orderColumns": [],
          "stimuliOrders": [],
          "categories": false,
          "categoryColumn": "",
          "categoryData": [],
          "parentLoopId": null,
          "branchConditions": [],
          "repeatConditions": [],
          "paramsOverride": [
            {
              "id": 1768705544523,
              "rules": [
                {
                  "trialId": "1768521719165",
                  "column": "",
                  "op": "==",
                  "value": "",
                  "prop": ""
                }
              ],
              "paramsToOverride": {}
            }
          ]
        },
        {
          "type": "Trial",
          "name": "New Trial 2",
          "parameters": {},
          "trialCode": "",
          "parentLoopId": "loop_1768544730842",
          "id": 1768544990020,
          "createdAt": "2026-01-16T06:29:50.020Z",
          "updatedAt": "2026-01-16T06:29:50.020Z",
          "branches": []
        },
        {
          "type": "Trial",
          "name": "New Trial",
          "parameters": {},
          "trialCode": "",
          "id": 1768683378653,
          "createdAt": "2026-01-17T20:56:18.653Z",
          "updatedAt": "2026-01-17T20:56:24.413Z",
          "branches": [
            1768683379966
          ],
          "parentLoopId": "loop_1768683384399"
        },
        {
          "type": "Trial",
          "name": "New Trial 2",
          "parameters": {},
          "trialCode": "",
          "id": 1768683379966,
          "createdAt": "2026-01-17T20:56:19.966Z",
          "updatedAt": "2026-01-17T20:56:24.420Z",
          "parentLoopId": "loop_1768683384399"
        }
      ],
      "loops": [
        {
          "name": "Loop 1",
          "repetitions": 5,
          "randomize": true,
          "orders": true,
          "stimuliOrders": [],
          "orderColumns": [
            "plugin_version",
            "time_elapsed",
            "session_browser",
            "session_browser_version"
          ],
          "categoryColumn": "trial_id",
          "categories": true,
          "categoryData": [],
          "trials": [
            1768683378653,
            1768683379966
          ],
          "code": "",
          "id": "loop_1768683384399",
          "createdAt": "2026-01-17T20:56:24.399Z",
          "updatedAt": "2026-01-18T03:37:40.562Z",
          "isConditionalLoop": true,
          "loopConditions": [],
          "csvJson": [],
          "csvColumns": []
        }
      ],
      "timeline": [
        {
          "id": 1768521719165,
          "type": "trial",
          "name": "nPreguntasmdns",
          "branches": [
            1768521892763,
            "loop_1768683384399"
          ]
        },
        {
          "id": 1768521892763,
          "type": "trial",
          "name": "New Trial 1",
          "branches": []
        },
        {
          "id": "loop_1768683384399",
          "type": "loop",
          "name": "Loop 1",
          "branches": [],
          "trials": [
            1768683378653,
            1768683379966
          ]
        }
      ],
      "createdAt": "2026-01-16T00:01:59.166Z",
      "updatedAt": "2026-01-18T03:37:40.562Z"
    }
  ],
  "configs": [
    {
      "experimentID": "4bd964f3-1936-452f-a744-fcdffc938976",
      "data": {
        "generatedCode": "\n  // --- Recolectar metadata del sistema ---\n  const getMetadata = () => {\n    const ua = navigator.userAgent;\n    let browserName = 'Unknown';\n    let browserVersion = 'Unknown';\n    \n    if (ua.indexOf('Firefox') > -1) {\n      browserName = 'Firefox';\n      browserVersion = ua.match(/Firefox\\/(\\d+\\.\\d+)/)?.[1] || 'Unknown';\n    } else if (ua.indexOf('Chrome') > -1) {\n      browserName = 'Chrome';\n      browserVersion = ua.match(/Chrome\\/(\\d+\\.\\d+)/)?.[1] || 'Unknown';\n    } else if (ua.indexOf('Safari') > -1) {\n      browserName = 'Safari';\n      browserVersion = ua.match(/Version\\/(\\d+\\.\\d+)/)?.[1] || 'Unknown';\n    } else if (ua.indexOf('Edg') > -1) {\n      browserName = 'Edge';\n      browserVersion = ua.match(/Edg\\/(\\d+\\.\\d+)/)?.[1] || 'Unknown';\n    }\n    \n    let osName = 'Unknown';\n    if (ua.indexOf('Win') > -1) osName = 'Windows';\n    else if (ua.indexOf('Mac') > -1) osName = 'macOS';\n    else if (ua.indexOf('Linux') > -1) osName = 'Linux';\n    else if (ua.indexOf('Android') > -1) osName = 'Android';\n    else if (ua.indexOf('iOS') > -1) osName = 'iOS';\n    \n    return {\n      browser: browserName,\n      browserVersion: browserVersion,\n      os: osName,\n      screenWidth: window.screen.width,\n      screenHeight: window.screen.height,\n      screenResolution: `${window.screen.width}x${window.screen.height}`,\n      viewportWidth: window.innerWidth,\n      viewportHeight: window.innerHeight,\n      language: navigator.language,\n      userAgent: ua,\n      startedAt: new Date().toISOString()\n    };\n  };\n  \n  const metadata = getMetadata();\n\n  // --- Firebase config ---\n  const firebaseConfig = {\n    apiKey: \"AIzaSyBEbJ-uGKzsaf2u24KPamBPVZrUmvhFk-Q\",\n    authDomain: \"test-e4cf9.firebaseapp.com\",\n    databaseURL: \"http://localhost:9000?ns=test-e4cf9\",\n    projectId: \"test-e4cf9\",\n    storageBucket: \"test-e4cf9.firebasestorage.app\",\n    messagingSenderId: \"414213417080\",\n    appId: \"1:414213417080:web:98607c621a54d07656e58d\"\n  };\n\n  // --- Cargar Firebase SDK ---\n  if (typeof window.firebase === 'undefined') {\n    const script = document.createElement('script');\n    script.src = 'https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js';\n    script.onload = () => {\n      const dbScript = document.createElement('script');\n      dbScript.src = 'https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js';\n      dbScript.onload = () => { window._firebaseReady = true; };\n      document.head.appendChild(dbScript);\n    };\n    document.head.appendChild(script);\n  } else {\n    window._firebaseReady = true;\n  }\n\n  function waitForFirebase() {\n    return new Promise(resolve => {\n      if (window._firebaseReady) return resolve();\n      const interval = setInterval(() => {\n        if (window._firebaseReady) {\n          clearInterval(interval);\n          resolve();\n        }\n      }, 50);\n    });\n  }\n\n \n  const userStr = null;\n\n  const Uid = userStr.uid\n\n  const trialSessionId =\n    \"online_\" + (crypto.randomUUID\n      ? crypto.randomUUID()\n      : Math.random().toString(36).slice(2, 10));\n\n  let participantNumber;\n\n  async function saveSession(trialSessionId) {\n    try {\n      const res = await fetch(\"http://localhost:5001/test-e4cf9/us-central1/apiData\", {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\", Accept: \"*/*\" },\n        body: JSON.stringify({\n          experimentID: \"4bd964f3-1936-452f-a744-fcdffc938976\",\n          experimentName: \"re\", \n          sessionId: trialSessionId,\n          storage: \"drive\",\n          uid: Uid\n        }),\n      });\n      \n      console.log('Response status:', res.status);\n      \n      if (!res.ok) {\n        const errorText = await res.text();\n        console.error('Error creating session:', errorText);\n        throw new Error(`Failed to create session: ${res.status} - ${errorText}`);\n      }\n      \n      const result = await res.json();\n      console.log('Session created successfully:', result);\n      \n      if (!result.success) {\n        if (result.message?.includes(\"INVALID_GOOGLE_DRIVE_TOKEN\") || result.message?.includes(\"Invalid Google Drive token\")) {\n          alert(\"Warning: Google Drive token not found or invalid. Please reconnect your Drive account in Settings.\");\n        } else if (result.message?.includes(\"INVALID_DROPBOX_TOKEN\") || result.message?.includes(\"Invalid Dropbox token\")) {\n          alert(\"Warning: Dropbox token not found or invalid. Please reconnect your Dropbox account in Settings.\");\n        }\n        throw new Error(result.message || 'Failed to create session');\n      }\n      \n      participantNumber = result.participantNumber;\n      return participantNumber;\n    } catch (error) {\n      console.error('Error in saveSession:', error);\n      alert('Error creating session: ' + error.message);\n      throw error;\n    }\n  }\n\n  (async () => {\n    // Limpiar el localStorage de valores de sesiones anteriores\n    localStorage.removeItem('jsPsych_jumpToTrial');\n    \n    // Esperar e inicializar Firebase\n    await waitForFirebase();\n    if (!window.firebase.apps.length) {\n      window.firebase.initializeApp(firebaseConfig);\n    }\n    const db = window.firebase.database();\n\n    participantNumber = await saveSession(trialSessionId);\n\n    if (typeof participantNumber !== \"number\" || isNaN(participantNumber)) {\n      alert(\"The participant number is not assigned. Please, wait.\");\n      throw new Error(\"participantNumber not assigned\");\n    }\n\n    // --- Configurar onDisconnect para finalizar sesi√≥n autom√°ticamente ---\n    const sessionRef = db.ref('sessions/4bd964f3-1936-452f-a744-fcdffc938976/' + trialSessionId);\n    await sessionRef.set({\n      connected: true,\n      experimentID: '4bd964f3-1936-452f-a744-fcdffc938976',\n      sessionId: trialSessionId,\n      startedAt: window.firebase.database.ServerValue.TIMESTAMP,\n      storage: 'drive',\n      state: 'initiated',\n      lastUpdate: window.firebase.database.ServerValue.TIMESTAMP,\n      metadata: metadata\n    });\n    \n    // Guardar metadata en db.json local tambi√©n (para persistencia)\n    fetch('/api/save-online-session-metadata/4bd964f3-1936-452f-a744-fcdffc938976', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        sessionId: trialSessionId,\n        metadata: metadata,\n        state: 'initiated'\n      })\n    }).catch(err => console.warn('Could not save metadata to local db:', err));\n    \n    // Cuando se desconecte sin completar, marcar como abandoned\n    // Incluir needsFinalization para que se procesen los datos en caso de desconexi√≥n\n    sessionRef.onDisconnect().update({\n      connected: false,\n      needsFinalization: true,\n      state: 'abandoned',\n      disconnectedAt: window.firebase.database.ServerValue.TIMESTAMP,\n      storage: 'drive'\n    });\n\n    // --- Branching logic functions (outside initJsPsych for timeline access) ---\n    window.nextTrialId = null;\n    window.skipRemaining = false;\n    window.branchingActive = false;\n    window.branchCustomParameters = null; // Store custom parameters for the next trial\n\n    const evaluateCondition = (trialData, condition) => {\n      // All rules in a condition must be true (AND logic)\n      return condition.rules.every(rule => {\n        // New flat structure: rule.column contains the direct column name\n        // e.g., \"ButtonResponseComponent_1_response\" or \"response\" for normal plugins\n        const columnName = rule.column || rule.prop; // Fallback to rule.prop for backward compatibility\n        \n        if (!columnName) {\n          console.warn('No column name specified in rule:', rule);\n          return false;\n        }\n        \n        // Get value directly from the column\n        const propValue = trialData[columnName];\n        \n        if (propValue === undefined) {\n          console.warn('Column not found in trial data:', columnName);\n          return false;\n        }\n        \n        const compareValue = rule.value;\n        \n        // Handle array responses (multi-select or single-select returned as array)\n        if (Array.isArray(propValue)) {\n          const matches = propValue.includes(compareValue) || propValue.includes(String(compareValue));\n          switch (rule.op) {\n            case '==':\n              return matches;\n            case '!=':\n              return !matches;\n            default:\n              return false;\n          }\n        }\n        \n        // Convert values for comparison (for non-array values)\n        const numPropValue = parseFloat(propValue);\n        const numCompareValue = parseFloat(compareValue);\n        const isNumeric = !isNaN(numPropValue) && !isNaN(numCompareValue);\n        \n        switch (rule.op) {\n          case '==':\n            return isNumeric ? numPropValue === numCompareValue : propValue == compareValue;\n          case '!=':\n            return isNumeric ? numPropValue !== numCompareValue : propValue != compareValue;\n          case '>':\n            return isNumeric && numPropValue > numCompareValue;\n          case '<':\n            return isNumeric && numPropValue < numCompareValue;\n          case '>=':\n            return isNumeric && numPropValue >= numCompareValue;\n          case '<=':\n            return isNumeric && numPropValue <= numCompareValue;\n          default:\n            return false;\n        }\n      });\n    };\n    \n    const getNextTrialId = (lastTrialData) => {\n      if (!lastTrialData || !lastTrialData.trials || !lastTrialData.trials[0]) {\n        return null;\n      }\n      \n      const trial = lastTrialData.trials[0];\n      \n      // Check if trial/loop has branches\n      if (!Array.isArray(trial.branches) || trial.branches.length === 0) {\n        return null;\n      }\n      \n      // Check if there are conditions to evaluate\n      const hasBranchConditions = Array.isArray(trial.branchConditions) && trial.branchConditions.length > 0;\n      \n      // Check if any condition has customParameters\n      const hasCustomParameters = hasBranchConditions && \n        trial.branchConditions.flat().some(condition => \n          condition && condition.customParameters && \n          Object.keys(condition.customParameters).length > 0\n        );\n      \n      // If there are no conditions AND no custom parameters, auto-branch to first branch\n      if (!hasBranchConditions && !hasCustomParameters) {\n        console.log('No conditions or custom parameters defined, auto-branching to first branch:', trial.branches[0]);\n        return trial.branches[0];\n      }\n      \n      // If there are no conditions but there ARE custom parameters, we can't auto-branch\n      // We need to evaluate conditions to know which customParameters to use\n      if (!hasBranchConditions && hasCustomParameters) {\n        console.log('Custom parameters exist but no conditions, cannot auto-branch');\n        return null;\n      }\n      \n      // If there ARE conditions, evaluate them (regardless of how many branches there are)\n      // branchConditions is an array of arrays, flatten it first\n      const conditions = trial.branchConditions.flat();\n      \n      // Evaluate each condition (OR logic between conditions)\n      for (const condition of conditions) {\n        if (!condition || !condition.rules) {\n          console.warn('Invalid condition structure:', condition);\n          continue;\n        }\n        \n        if (evaluateCondition(trial, condition)) {\n          // Store custom parameters if they exist\n          if (condition.customParameters) {\n            window.branchCustomParameters = condition.customParameters;\n          }\n          return condition.nextTrialId;\n        }\n      }\n      \n      // No condition matched - do NOT branch (conditions were defined but none matched)\n      return null;\n    };\n\n    // Track pending data saves to ensure all complete before finishing\n    const pendingDataSaves = [];\n\n    const jsPsych = initJsPsych({\n      display_element: document.getElementById('jspsych-container'),\n\n      on_trial_start: function(trial) {\n        const lastTrialData = jsPsych.data.get()\n        if (lastTrialData && trial.data) {\n        trial.data.prev_response = lastTrialData.response;\n        }\n      },\n\n      \n\n      on_data_update: function (data) {\n\n        // Actualizar estado a 'in-progress' en la primera actualizaci√≥n\n        if (data.trial_index === 0) {\n          sessionRef.update({\n            state: 'in-progress',\n            lastUpdate: window.firebase.database.ServerValue.TIMESTAMP\n          }).catch(err => console.error('Error updating state:', err));\n          \n          // Actualizar tambi√©n en db.json local\n          fetch('/api/save-online-session-metadata/4bd964f3-1936-452f-a744-fcdffc938976', {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify({\n              sessionId: trialSessionId,\n              state: 'in-progress'\n            })\n          }).catch(err => console.warn('Could not update state in local db:', err));\n        }\n\n        // Create and track the promise for this data save\n        const savePromise = fetch(\"http://localhost:5001/test-e4cf9/us-central1/apiData\", {\n          method: \"POST\",\n          headers: { \"Content-Type\": \"application/json\", Accept: \"*/*\" },\n          body: JSON.stringify({\n            experimentID: \"4bd964f3-1936-452f-a744-fcdffc938976\",\n            sessionId: trialSessionId,\n            data: data,\n            storage: \"drive\",\n          }),\n        })\n        .then(res => {\n          if (!res.ok) {\n            return res.text().then(text => {\n              console.error('Error appending data:', text);\n            });\n          }\n          return res.json();\n        })\n        .then(result => {\n          if (result && result.success) {\n            console.log('Data appended to temporary storage');\n          }\n        })\n        .catch(error => {\n          console.error('Error in on_data_update:', error);\n        })\n        .finally(() => {\n          // Remove from pending once complete\n          const index = pendingDataSaves.indexOf(savePromise);\n          if (index > -1) {\n            pendingDataSaves.splice(index, 1);\n          }\n        });\n        \n        pendingDataSaves.push(savePromise);\n\n        // Solo evaluar branching si el trial/loop tiene un trial_id o loop_id v√°lido\n      if ((!data.trial_id || data.trial_id === undefined) && (!data.loop_id || data.loop_id === undefined)) {\n        return;\n      }\n      \n      const lastTrialData = jsPsych.data.getLastTrialData();\n      const trial = lastTrialData.trials ? lastTrialData.trials[0] : null;\n      \n      // Verificar si este trial/loop tiene branches\n      if (!trial || !trial.branches || trial.branches.length === 0) {\n        return; // No tiene branches, no hay nada que hacer\n      }\n      \n      // IMPORTANTE: Si el trial est√° dentro de un loop (isInLoop = true),\n      // NO activar el branching global. Los trials dentro de loops usan su propio\n      // sistema de branching con variables locales (loopNextTrialId, etc.)\n      if (trial.isInLoop === true) {\n        return;\n      }\n      \n      const nextTrialId = getNextTrialId(lastTrialData);\n      \n      if (nextTrialId) {\n        // Check if nextTrialId is \"FINISH_EXPERIMENT\"\n        if (nextTrialId === 'FINISH_EXPERIMENT') {\n          console.log('üèÅ [BRANCHING] Finishing experiment via branching');\n          jsPsych.abortExperiment('Experiment finished by branching condition', {});\n          return;\n        }\n        \n        console.log('üéØ [BRANCHING] Setting global branch target:', nextTrialId);\n        window.nextTrialId = nextTrialId;\n        window.skipRemaining = true;\n        window.branchingActive = true;\n        console.log('üéØ [BRANCHING] Skip remaining activated');\n      }\n      },\n\n      on_finish: async function() {\n        \n        // Wait for all pending data saves to complete\n        if (pendingDataSaves.length > 0) {\n          console.log('Waiting for', pendingDataSaves.length, 'pending data saves to complete...');\n          await Promise.allSettled(pendingDataSaves);\n          console.log('All data saves completed');\n        }\n        \n        // Cancelar el onDisconnect para evitar que marque como abandoned\n        sessionRef.onDisconnect().cancel();\n\n        // Finalizar la sesi√≥n normalmente y marcar en Firebase que termin√≥ correctamente\n        console.log('Experiment finished normally, sending data to storage...');\n        \n        try {\n          \n          // Marcar en Firebase que termin√≥ correctamente Y necesita finalizaci√≥n\n          await sessionRef.update({\n            connected: false,\n            finished: true,\n            needsFinalization: true,\n            state: 'completed',\n            finishedAt: window.firebase.database.ServerValue.TIMESTAMP,\n            lastUpdate: window.firebase.database.ServerValue.TIMESTAMP\n          });\n          \n          // Guardar estado completado en db.json local (persistencia)\n          await fetch('/api/save-online-session-metadata/4bd964f3-1936-452f-a744-fcdffc938976', {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify({\n              sessionId: trialSessionId,\n              state: 'completed'\n            })\n          }).catch(err => console.warn('Could not update completed state in local db:', err));\n          \n          // El backend procesar√° la finalizaci√≥n al detectar needsFinalization=true\n          console.log('Session marked for finalization in Firebase');\n        } catch (error) {\n          console.error('Error marking session as finished:', error);\n        }\n      },\n  // Uncomment to see the json results after finishing a session experiment\n  // jsPsych.data.displayData('csv');\n});\n\nconst timeline = [];\n\n// Global preload for all uploaded files from Timeline\n\n\n\n    const test_stimuli_nPreguntasmdns = [{components: [],\nresponse_components: [{ type: \"SurveyComponent\", coordinates: {\"x\":0.7786885245901636,\"y\":0.2295081967213113}, width: 200, height: 50, survey_json: {\"title\":\"Seco\",\"elements\":[{\"type\":\"radiogroup\",\"name\":\"loca\",\"title\":\"sexo en el oxo ?\",\"isRequired\":false,\"choices\":[{\"value\":\"si\",\"text\":\"si\",\"imageLink\":\"\"},{\"value\":\"nel\",\"text\":\"nel\",\"imageLink\":\"\"}]},{\"type\":\"text\",\"name\":\"huevos\",\"title\":\"tu\",\"isRequired\":false}],\"description\":\"Cola\"}, name: \"survey\" }, { type: \"ButtonResponseComponent\", coordinates: {\"x\":0.7893622770671946,\"y\":0.8312015852999455}, width: 200, height: 50, choices: [\"loca\", \"no\"], name: \"boton\" }],\nstimuli_duration: undefined,\ntrial_duration: undefined,\nresponse_ends_trial: undefined}];\n    const nPreguntasmdns_timeline = {\n    type: DynamicPlugin, components: jsPsych.timelineVariable(\"components\"),\nresponse_components: jsPsych.timelineVariable(\"response_components\"),\nstimuli_duration: jsPsych.timelineVariable(\"stimuli_duration\"),\ntrial_duration: jsPsych.timelineVariable(\"trial_duration\"),\nresponse_ends_trial: jsPsych.timelineVariable(\"response_ends_trial\"),\n      data: {\n        rt: \"rt\",\n        trial_id: 1768521719165,\n        \n        \n        branches: [1768521892763, 1768524559825],\n        branchConditions: [[{\"id\":1768535708995,\"rules\":[{\"column\":\"survey_huevos\",\"op\":\"==\",\"value\":\"tu\"}],\"nextTrialId\":\"1768524559825\",\"customParameters\":{}}]] \n        \n      },\n    on_start: function(trial) {\n      // Then apply custom parameters from branching conditions (higher priority)\n      // For trials outside loops, use window.branchCustomParameters\n      if (window.branchCustomParameters && typeof window.branchCustomParameters === 'object') {\n        Object.entries(window.branchCustomParameters).forEach(([key, param]) => {\n          if (param && param.source !== 'none') {\n            // Parse key to check if it's a nested survey question\n            const parts = key.split('::');\n            \n            if (parts.length === 4) {\n              // Format: fieldType::componentName::survey_json::questionName\n              const [fieldType, componentName, propName, questionName] = parts;\n              \n              if (fieldType && componentName && propName === 'survey_json' && questionName) {\n                // Find the component by name in the field array\n                const fieldArray = trial[fieldType];\n                if (Array.isArray(fieldArray)) {\n                  const compIndex = fieldArray.findIndex(c => c.name === componentName);\n                  if (compIndex !== -1 && fieldArray[compIndex].survey_json) {\n                    // Find the question in survey_json.elements\n                    const elements = fieldArray[compIndex].survey_json.elements || [];\n                    const questionIndex = elements.findIndex(q => q.name === questionName);\n                    \n                    if (questionIndex !== -1) {\n                      // Apply the override value (from typed or csv)\n                      let valueToSet;\n                      if (param.source === 'typed') {\n                        valueToSet = String(param.value); // Convert to string for SurveyJS\n                      } else if (param.source === 'csv') {\n                        valueToSet = String(trial[param.value]); // Get from CSV column and convert to string\n                      }\n                      \n                      if (valueToSet !== undefined && valueToSet !== null) {\n                        fieldArray[compIndex].survey_json.elements[questionIndex].defaultValue = valueToSet;\n                      }\n                    }\n                  }\n                }\n              }\n            } else {\n              // Normal parameter (not nested survey question)\n              if (param.source === 'typed' && param.value !== undefined && param.value !== null) {\n                trial[key] = param.value;\n              } else if (param.source === 'csv' && param.value !== undefined && param.value !== null) {\n                trial[key] = trial[param.value];\n              }\n            }\n          }\n        });\n        // Clear the custom parameters after applying them\n        window.branchCustomParameters = null;\n      }\n      \n    },\n    on_finish: function(data) {\n      // Evaluar condiciones del trial para branching global\n      console.log('üîç [GLOBAL BRANCH] Evaluating branch conditions...');\n      const branches = [1768521892763, 1768524559825];\n      const branchConditions = [{\"id\":1768535708995,\"rules\":[{\"column\":\"survey_huevos\",\"op\":\"==\",\"value\":\"tu\"}],\"nextTrialId\":\"1768524559825\",\"customParameters\":{}}].flat();\n      console.log('üîç [GLOBAL BRANCH] Available branches:', branches);\n      console.log('üîç [GLOBAL BRANCH] Conditions to evaluate:', branchConditions.length);\n      \n      let nextTrialId = null;\n      let matchedCustomParameters = null;\n      \n      // Evaluar cada condici√≥n (l√≥gica OR entre condiciones)\n      for (const condition of branchConditions) {\n        if (!condition || !condition.rules) {\n          continue;\n        }\n        \n        // Todas las reglas en una condici√≥n deben ser verdaderas (l√≥gica AND)\n        const allRulesMatch = condition.rules.every(rule => {\n          let propValue;\n          \n          // Parse column name to extract component info for dynamic plugins\n          // Format: \"componentName_propertyName\" or \"componentName_questionName\" for surveys\n          const columnName = rule.column || rule.prop || \"\";\n          const parts = columnName.split(\"_\");\n          \n          // Check if this looks like a dynamic plugin column (has underscore)\n          if (parts.length >= 2) {\n            // Last part is the property or question name\n            const propertyOrQuestion = parts[parts.length - 1];\n            // Everything before the last underscore is the component name\n            const componentName = parts.slice(0, -1).join(\"_\");\n            \n            // Try to find the data in the format: componentName_response\n            const responseKey = componentName + '_response';\n            const responseData = data[responseKey];\n            \n            // If response data exists and is an object (SurveyComponent case)\n            if (responseData && typeof responseData === 'object' && !Array.isArray(responseData)) {\n              // This is likely a survey response - check if property is a question name\n              if (responseData[propertyOrQuestion] !== undefined) {\n                propValue = responseData[propertyOrQuestion];\n              } else {\n                return false;\n              }\n            } else {\n              // Not a survey response object, try direct property access\n              const directKey = componentName + '_' + propertyOrQuestion;\n              if (data[directKey] !== undefined) {\n                propValue = data[directKey];\n              } else {\n                return false;\n              }\n            }\n          } else {\n            // Normal plugin structure - direct property access\n            propValue = data[columnName];\n          }\n          \n          const compareValue = rule.value;\n          \n          // Handle array responses (multi-select or single-select returned as array)\n          if (Array.isArray(propValue)) {\n            const matches = propValue.includes(compareValue) || propValue.includes(String(compareValue));\n            switch (rule.op) {\n              case '==':\n                return matches;\n              case '!=':\n                return !matches;\n              default:\n                return false;\n            }\n          }\n          \n          // Convertir valores para comparaci√≥n\n          const numPropValue = parseFloat(propValue);\n          const numCompareValue = parseFloat(compareValue);\n          const isNumeric = !isNaN(numPropValue) && !isNaN(numCompareValue);\n          \n          switch (rule.op) {\n            case '==':\n              return isNumeric ? numPropValue === numCompareValue : propValue == compareValue;\n            case '!=':\n              return isNumeric ? numPropValue !== numCompareValue : propValue != compareValue;\n            case '>':\n              return isNumeric && numPropValue > numCompareValue;\n            case '<':\n              return isNumeric && numPropValue < numCompareValue;\n            case '>=':\n              return isNumeric && numPropValue >= numCompareValue;\n            case '<=':\n              return isNumeric && numPropValue <= numCompareValue;\n            default:\n              return false;\n          }\n        });\n        \n        if (allRulesMatch) {\n          console.log('‚úÖ [GLOBAL BRANCH] Condition matched! Next trial:', condition.nextTrialId);\n          nextTrialId = condition.nextTrialId;\n          // Store custom parameters if they exist\n          if (condition.customParameters) {\n            matchedCustomParameters = condition.customParameters;\n            console.log('‚úÖ [GLOBAL BRANCH] Custom parameters:', matchedCustomParameters);\n          }\n          break;\n        }\n      }\n      \n      // Si se encontr√≥ match, activar branching\n      if (nextTrialId) {\n        console.log('üéØ [GLOBAL BRANCH] Activating branching to trial:', nextTrialId);\n        window.nextTrialId = nextTrialId;\n        window.skipRemaining = true;\n        window.branchingActive = true;\n        // Store custom parameters for the next trial\n        if (matchedCustomParameters) {\n          window.branchCustomParameters = matchedCustomParameters;\n        }\n      } else {\n        // No match - ir al primer branch por defecto\n        console.log('‚ö†Ô∏è [GLOBAL BRANCH] No condition matched, branching to first branch:', branches[0]);\n        window.nextTrialId = branches[0];\n        window.skipRemaining = true;\n        window.branchingActive = true;\n      }\n      \n    },};\n    const nPreguntasmdns_procedure = {\n    timeline: \n    [nPreguntasmdns_timeline],\n    timeline_variables: test_stimuli_nPreguntasmdns,\n    \n    conditional_function: function() {\n      const currentId = 1768521719165;\n      \n      // Verificar si hay un trial objetivo guardado en localStorage (para repeat/jump)\n      const jumpToTrial = localStorage.getItem('jsPsych_jumpToTrial');\n      if (jumpToTrial) {\n        if (String(currentId) === String(jumpToTrial)) {\n          // Encontramos el trial objetivo para repeat/jump\n          console.log('üîÅ [REPEAT/JUMP] Found target trial', currentId);\n          localStorage.removeItem('jsPsych_jumpToTrial');\n          return true;\n        }\n        // No es el objetivo, saltar\n        console.log('‚è≠Ô∏è [REPEAT/JUMP] Skipping trial', currentId);\n        return false;\n      }\n      \n      // Si skipRemaining est√° activo (branching normal), verificar si este es el trial objetivo\n      if (window.skipRemaining) {\n        console.log('üîç [SKIP CHECK] Trial', currentId, '| Target:', window.nextTrialId, '| Match:', String(currentId) === String(window.nextTrialId));\n        if (String(currentId) === String(window.nextTrialId)) {\n          // Encontramos el trial objetivo\n          console.log('‚úÖ [SKIP CHECK] Found target trial! Disabling skip mode');\n          window.skipRemaining = false;\n          window.nextTrialId = null;\n          return true;\n        }\n        // No es el objetivo, saltar\n        console.log('‚è≠Ô∏è [SKIP CHECK] Skipping trial', currentId);\n        return false;\n      }\n      \n      return true;\n    },\n  \n    \n    };\n    timeline.push(nPreguntasmdns_procedure);\n  \n\n\n    const test_stimuli_New_Trial_1 = [{components: [{ type: \"HtmlComponent\", coordinates: {\"x\":0.1788280208095232,\"y\":-0.13759175307252672}, width: 260.5073648041071, height: 65.12684120102682, stimulus: \"<div style=\\\"box-sizing: border-box;\\\">Type or design here</div>\" }],\nresponse_components: [{ type: \"KeyboardResponseComponent\", coordinates: {\"x\":0.6201585299945953,\"y\":0.7745751516243319}, width: 200, height: 50 }],\nstimuli_duration: undefined,\ntrial_duration: undefined,\nresponse_ends_trial: undefined}];\n    const New_Trial_1_timeline = {\n    type: DynamicPlugin, components: jsPsych.timelineVariable(\"components\"),\nresponse_components: jsPsych.timelineVariable(\"response_components\"),\nstimuli_duration: jsPsych.timelineVariable(\"stimuli_duration\"),\ntrial_duration: jsPsych.timelineVariable(\"trial_duration\"),\nresponse_ends_trial: jsPsych.timelineVariable(\"response_ends_trial\"),\n      data: {\n        rt: \"rt\",\n        trial_id: 1768521892763,\n        \n        \n      },\n    on_start: function(trial) {\n      // Then apply custom parameters from branching conditions (higher priority)\n      // For trials outside loops, use window.branchCustomParameters\n      if (window.branchCustomParameters && typeof window.branchCustomParameters === 'object') {\n        Object.entries(window.branchCustomParameters).forEach(([key, param]) => {\n          if (param && param.source !== 'none') {\n            // Parse key to check if it's a nested survey question\n            const parts = key.split('::');\n            \n            if (parts.length === 4) {\n              // Format: fieldType::componentName::survey_json::questionName\n              const [fieldType, componentName, propName, questionName] = parts;\n              \n              if (fieldType && componentName && propName === 'survey_json' && questionName) {\n                // Find the component by name in the field array\n                const fieldArray = trial[fieldType];\n                if (Array.isArray(fieldArray)) {\n                  const compIndex = fieldArray.findIndex(c => c.name === componentName);\n                  if (compIndex !== -1 && fieldArray[compIndex].survey_json) {\n                    // Find the question in survey_json.elements\n                    const elements = fieldArray[compIndex].survey_json.elements || [];\n                    const questionIndex = elements.findIndex(q => q.name === questionName);\n                    \n                    if (questionIndex !== -1) {\n                      // Apply the override value (from typed or csv)\n                      let valueToSet;\n                      if (param.source === 'typed') {\n                        valueToSet = String(param.value); // Convert to string for SurveyJS\n                      } else if (param.source === 'csv') {\n                        valueToSet = String(trial[param.value]); // Get from CSV column and convert to string\n                      }\n                      \n                      if (valueToSet !== undefined && valueToSet !== null) {\n                        fieldArray[compIndex].survey_json.elements[questionIndex].defaultValue = valueToSet;\n                      }\n                    }\n                  }\n                }\n              }\n            } else {\n              // Normal parameter (not nested survey question)\n              if (param.source === 'typed' && param.value !== undefined && param.value !== null) {\n                trial[key] = param.value;\n              } else if (param.source === 'csv' && param.value !== undefined && param.value !== null) {\n                trial[key] = trial[param.value];\n              }\n            }\n          }\n        });\n        // Clear the custom parameters after applying them\n        window.branchCustomParameters = null;\n      }\n      \n    },\n    on_finish: function(data) {\n      // Trial terminal - si llegamos aqu√≠ despu√©s de branching, terminar el experimento\n      if (window.branchingActive) {\n        jsPsych.abortExperiment('', {});\n      }\n    },};\n    const New_Trial_1_procedure = {\n    timeline: \n    [New_Trial_1_timeline],\n    timeline_variables: test_stimuli_New_Trial_1,\n    \n    conditional_function: function() {\n      const currentId = 1768521892763;\n      \n      // Verificar si hay un trial objetivo guardado en localStorage (para repeat/jump)\n      const jumpToTrial = localStorage.getItem('jsPsych_jumpToTrial');\n      if (jumpToTrial) {\n        if (String(currentId) === String(jumpToTrial)) {\n          // Encontramos el trial objetivo para repeat/jump\n          console.log('üîÅ [REPEAT/JUMP] Found target trial', currentId);\n          localStorage.removeItem('jsPsych_jumpToTrial');\n          return true;\n        }\n        // No es el objetivo, saltar\n        console.log('‚è≠Ô∏è [REPEAT/JUMP] Skipping trial', currentId);\n        return false;\n      }\n      \n      // Si skipRemaining est√° activo (branching normal), verificar si este es el trial objetivo\n      if (window.skipRemaining) {\n        console.log('üîç [SKIP CHECK] Trial', currentId, '| Target:', window.nextTrialId, '| Match:', String(currentId) === String(window.nextTrialId));\n        if (String(currentId) === String(window.nextTrialId)) {\n          // Encontramos el trial objetivo\n          console.log('‚úÖ [SKIP CHECK] Found target trial! Disabling skip mode');\n          window.skipRemaining = false;\n          window.nextTrialId = null;\n          return true;\n        }\n        // No es el objetivo, saltar\n        console.log('‚è≠Ô∏è [SKIP CHECK] Skipping trial', currentId);\n        return false;\n      }\n      \n      return true;\n    },\n  \n    \n    };\n    timeline.push(New_Trial_1_procedure);\n  \n\n\n    const test_stimuli_locao = [{components: [{ type: \"HtmlComponent\", coordinates: {\"x\":0,\"y\":0}, width: 200, height: 50, stimulus: \"<div id=\\\"i3ls\\\" style=\\\"box-sizing: border-box;\\\">Locao</div>\" }],\nresponse_components: [{ type: \"KeyboardResponseComponent\", coordinates: {\"x\":0.1153846153846152,\"y\":0.4395604395604395}, width: 200, height: 50 }],\nstimuli_duration: undefined,\ntrial_duration: undefined,\nresponse_ends_trial: undefined}];\n    const locao_timeline = {\n    type: DynamicPlugin, components: jsPsych.timelineVariable(\"components\"),\nresponse_components: jsPsych.timelineVariable(\"response_components\"),\nstimuli_duration: jsPsych.timelineVariable(\"stimuli_duration\"),\ntrial_duration: jsPsych.timelineVariable(\"trial_duration\"),\nresponse_ends_trial: jsPsych.timelineVariable(\"response_ends_trial\"),\n      data: {\n        rt: \"rt\",\n        trial_id: 1768524559825,\n        \n        \n      },\n    on_start: function(trial) {\n      // Then apply custom parameters from branching conditions (higher priority)\n      // For trials outside loops, use window.branchCustomParameters\n      if (window.branchCustomParameters && typeof window.branchCustomParameters === 'object') {\n        Object.entries(window.branchCustomParameters).forEach(([key, param]) => {\n          if (param && param.source !== 'none') {\n            // Parse key to check if it's a nested survey question\n            const parts = key.split('::');\n            \n            if (parts.length === 4) {\n              // Format: fieldType::componentName::survey_json::questionName\n              const [fieldType, componentName, propName, questionName] = parts;\n              \n              if (fieldType && componentName && propName === 'survey_json' && questionName) {\n                // Find the component by name in the field array\n                const fieldArray = trial[fieldType];\n                if (Array.isArray(fieldArray)) {\n                  const compIndex = fieldArray.findIndex(c => c.name === componentName);\n                  if (compIndex !== -1 && fieldArray[compIndex].survey_json) {\n                    // Find the question in survey_json.elements\n                    const elements = fieldArray[compIndex].survey_json.elements || [];\n                    const questionIndex = elements.findIndex(q => q.name === questionName);\n                    \n                    if (questionIndex !== -1) {\n                      // Apply the override value (from typed or csv)\n                      let valueToSet;\n                      if (param.source === 'typed') {\n                        valueToSet = String(param.value); // Convert to string for SurveyJS\n                      } else if (param.source === 'csv') {\n                        valueToSet = String(trial[param.value]); // Get from CSV column and convert to string\n                      }\n                      \n                      if (valueToSet !== undefined && valueToSet !== null) {\n                        fieldArray[compIndex].survey_json.elements[questionIndex].defaultValue = valueToSet;\n                      }\n                    }\n                  }\n                }\n              }\n            } else {\n              // Normal parameter (not nested survey question)\n              if (param.source === 'typed' && param.value !== undefined && param.value !== null) {\n                trial[key] = param.value;\n              } else if (param.source === 'csv' && param.value !== undefined && param.value !== null) {\n                trial[key] = trial[param.value];\n              }\n            }\n          }\n        });\n        // Clear the custom parameters after applying them\n        window.branchCustomParameters = null;\n      }\n      \n    },\n    on_finish: function(data) {\n      // Trial terminal - si llegamos aqu√≠ despu√©s de branching, terminar el experimento\n      if (window.branchingActive) {\n        jsPsych.abortExperiment('', {});\n      }\n    },};\n    const locao_procedure = {\n    timeline: \n    [locao_timeline],\n    timeline_variables: test_stimuli_locao,\n    \n    conditional_function: function() {\n      const currentId = 1768524559825;\n      \n      // Verificar si hay un trial objetivo guardado en localStorage (para repeat/jump)\n      const jumpToTrial = localStorage.getItem('jsPsych_jumpToTrial');\n      if (jumpToTrial) {\n        if (String(currentId) === String(jumpToTrial)) {\n          // Encontramos el trial objetivo para repeat/jump\n          console.log('üîÅ [REPEAT/JUMP] Found target trial', currentId);\n          localStorage.removeItem('jsPsych_jumpToTrial');\n          return true;\n        }\n        // No es el objetivo, saltar\n        console.log('‚è≠Ô∏è [REPEAT/JUMP] Skipping trial', currentId);\n        return false;\n      }\n      \n      // Si skipRemaining est√° activo (branching normal), verificar si este es el trial objetivo\n      if (window.skipRemaining) {\n        console.log('üîç [SKIP CHECK] Trial', currentId, '| Target:', window.nextTrialId, '| Match:', String(currentId) === String(window.nextTrialId));\n        if (String(currentId) === String(window.nextTrialId)) {\n          // Encontramos el trial objetivo\n          console.log('‚úÖ [SKIP CHECK] Found target trial! Disabling skip mode');\n          window.skipRemaining = false;\n          window.nextTrialId = null;\n          return true;\n        }\n        // No es el objetivo, saltar\n        console.log('‚è≠Ô∏è [SKIP CHECK] Skipping trial', currentId);\n        return false;\n      }\n      \n      return true;\n    },\n  \n    \n    };\n    timeline.push(locao_procedure);\n  \n\njsPsych.run(timeline);\n\n})();\n"
      },
      "isDevMode": false,
      "createdAt": "2026-01-16T00:01:59.416Z",
      "updatedAt": "2026-01-18T03:37:31.481Z"
    }
  ],
  "pluginConfigs": [],
  "sessionResults": [
    {
      "experimentID": "4bd964f3-1936-452f-a744-fcdffc938976",
      "sessionId": "Pregunta_result_aa8822c7-0b86-4acb-8210-6195dc762f15",
      "createdAt": "2026-01-16T01:37:45.475Z",
      "data": [],
      "state": "initiated",
      "lastUpdate": "2026-01-16T01:37:45.475Z",
      "metadata": {}
    },
    {
      "experimentID": "4bd964f3-1936-452f-a744-fcdffc938976",
      "sessionId": "Pregunta_result_63149b64-a2d1-4e48-b784-58ed437dc9dd",
      "createdAt": "2026-01-16T01:37:52.030Z",
      "data": [
        {
          "rt": 824,
          "trial_id": 1768521719165,
          "branches": [
            1768521892763,
            1768524559825
          ],
          "branchConditions": [
            [
              {
                "id": 1768527284961,
                "rules": [
                  {
                    "column": "er_response",
                    "op": "==",
                    "value": "co"
                  }
                ],
                "nextTrialId": "1768524559825",
                "customParameters": {}
              }
            ]
          ],
          "er_type": "ButtonResponseComponent",
          "er_response": "locao",
          "er_rt": 823,
          "trial_type": "DynamicPlugin",
          "trial_index": 0,
          "plugin_version": "1.0.0",
          "time_elapsed": 826
        }
      ],
      "state": "in-progress",
      "lastUpdate": "2026-01-16T01:37:52.862Z",
      "metadata": {}
    },
    {
      "experimentID": "4bd964f3-1936-452f-a744-fcdffc938976",
      "sessionId": "nPreguntasmdns_result_00ab8539-ecd9-450a-be2b-7e361150116f",
      "createdAt": "2026-01-16T05:41:08.117Z",
      "data": [],
      "state": "initiated",
      "lastUpdate": "2026-01-16T05:41:08.117Z",
      "metadata": {}
    },
    {
      "experimentID": "4bd964f3-1936-452f-a744-fcdffc938976",
      "sessionId": "nPreguntasmdns_result_c393e2a9-6844-4e0e-bad6-fc20d9786785",
      "createdAt": "2026-01-16T05:49:36.672Z",
      "data": [
        {
          "rt": 5798,
          "trial_id": 1768521719165,
          "branches": [
            1768521892763,
            1768524559825
          ],
          "branchConditions": [
            [
              {
                "id": 1768535708995,
                "rules": [
                  {
                    "column": "survey_huevos",
                    "op": "==",
                    "value": "tu"
                  }
                ],
                "nextTrialId": "1768524559825",
                "customParameters": {}
              }
            ]
          ],
          "survey_type": "SurveyComponent",
          "survey_response": {
            "loca": "nel",
            "huevos": null
          },
          "survey_rt": 5773,
          "boton_type": "ButtonResponseComponent",
          "boton_response": null,
          "boton_rt": null,
          "trial_type": "DynamicPlugin",
          "trial_index": 0,
          "plugin_version": "1.0.0",
          "time_elapsed": 5801
        }
      ],
      "state": "in-progress",
      "lastUpdate": "2026-01-16T05:49:42.502Z",
      "metadata": {}
    },
    {
      "experimentID": "4bd964f3-1936-452f-a744-fcdffc938976",
      "sessionId": "nPreguntasmdns_result_0330922b-d239-4a15-8c90-bfccb637bcc5",
      "createdAt": "2026-01-16T05:49:51.893Z",
      "data": [],
      "state": "initiated",
      "lastUpdate": "2026-01-16T05:49:51.893Z",
      "metadata": {}
    },
    {
      "experimentID": "4bd964f3-1936-452f-a744-fcdffc938976",
      "sessionId": "nPreguntasmdns_result_3b4d3bf9-097d-44cf-aace-8792942f22c5",
      "createdAt": "2026-01-16T05:49:52.760Z",
      "data": [],
      "state": "initiated",
      "lastUpdate": "2026-01-16T05:49:52.760Z",
      "metadata": {}
    },
    {
      "experimentID": "4bd964f3-1936-452f-a744-fcdffc938976",
      "sessionId": "nPreguntasmdns_result_73ce8ca9-9c2e-42b3-a605-3c647719761d",
      "createdAt": "2026-01-16T05:50:01.730Z",
      "data": [],
      "state": "initiated",
      "lastUpdate": "2026-01-16T05:50:01.730Z",
      "metadata": {}
    },
    {
      "experimentID": "4bd964f3-1936-452f-a744-fcdffc938976",
      "sessionId": "nPreguntasmdns_result_3b9ba2c8-a921-4a14-acfc-999d7096fe6b",
      "createdAt": "2026-01-16T05:50:02.726Z",
      "data": [],
      "state": "initiated",
      "lastUpdate": "2026-01-16T05:50:02.726Z",
      "metadata": {}
    },
    {
      "experimentID": "4bd964f3-1936-452f-a744-fcdffc938976",
      "sessionId": "nPreguntasmdns_result_14f8c747-4bbb-4495-8bda-840f19f12a13",
      "createdAt": "2026-01-16T05:50:04.110Z",
      "data": [],
      "state": "initiated",
      "lastUpdate": "2026-01-16T05:50:04.110Z",
      "metadata": {}
    },
    {
      "experimentID": "4bd964f3-1936-452f-a744-fcdffc938976",
      "sessionId": "nPreguntasmdns_result_5479d87c-2575-4350-8c7d-739fe01f2488",
      "createdAt": "2026-01-16T05:50:05.472Z",
      "data": [],
      "state": "initiated",
      "lastUpdate": "2026-01-16T05:50:05.472Z",
      "metadata": {}
    },
    {
      "experimentID": "4bd964f3-1936-452f-a744-fcdffc938976",
      "sessionId": "nPreguntasmdns_result_a6eabf20-a335-4580-a606-6aa388073fd1",
      "createdAt": "2026-01-16T05:50:06.565Z",
      "data": [],
      "state": "initiated",
      "lastUpdate": "2026-01-16T05:50:06.565Z",
      "metadata": {}
    },
    {
      "experimentID": "4bd964f3-1936-452f-a744-fcdffc938976",
      "sessionId": "nPreguntasmdns_result_7833269f-9070-4c99-85e6-112d9ee160ad",
      "createdAt": "2026-01-16T05:51:26.351Z",
      "data": [],
      "state": "initiated",
      "lastUpdate": "2026-01-16T05:51:26.351Z",
      "metadata": {}
    },
    {
      "experimentID": "4bd964f3-1936-452f-a744-fcdffc938976",
      "sessionId": "nPreguntasmdns_result_37522453-2d27-43a0-8025-2a5acff77641",
      "createdAt": "2026-01-16T05:52:55.675Z",
      "data": [],
      "state": "initiated",
      "lastUpdate": "2026-01-16T05:52:55.675Z",
      "metadata": {}
    },
    {
      "experimentID": "4bd964f3-1936-452f-a744-fcdffc938976",
      "sessionId": "nPreguntasmdns_result_65a8c7eb-91eb-449f-98ea-e44fe2f615e0",
      "createdAt": "2026-01-16T05:52:57.174Z",
      "data": [],
      "state": "initiated",
      "lastUpdate": "2026-01-16T05:52:57.174Z",
      "metadata": {}
    },
    {
      "experimentID": "4bd964f3-1936-452f-a744-fcdffc938976",
      "sessionId": "nPreguntasmdns_result_5a02bfe0-ca51-40a7-ae62-6c0accacf2ff",
      "createdAt": "2026-01-16T05:53:00.086Z",
      "data": [],
      "state": "initiated",
      "lastUpdate": "2026-01-16T05:53:00.086Z",
      "metadata": {}
    },
    {
      "experimentID": "4bd964f3-1936-452f-a744-fcdffc938976",
      "sessionId": "nPreguntasmdns_result_d85dad08-dc30-43fc-8d45-88deddebfaaa",
      "createdAt": "2026-01-16T05:53:01.238Z",
      "data": [],
      "state": "initiated",
      "lastUpdate": "2026-01-16T05:53:01.238Z",
      "metadata": {}
    },
    {
      "experimentID": "4bd964f3-1936-452f-a744-fcdffc938976",
      "sessionId": "nPreguntasmdns_result_822f4724-5347-4dea-8f43-3e1bc0f9f0c1",
      "createdAt": "2026-01-16T05:53:05.400Z",
      "data": [],
      "state": "initiated",
      "lastUpdate": "2026-01-16T05:53:05.401Z",
      "metadata": {}
    },
    {
      "experimentID": "4bd964f3-1936-452f-a744-fcdffc938976",
      "sessionId": "nPreguntasmdns_result_da6ec3ce-b899-4536-bd73-ee4f7ddce8d6",
      "createdAt": "2026-01-16T05:53:09.709Z",
      "data": [],
      "state": "initiated",
      "lastUpdate": "2026-01-16T05:53:09.709Z",
      "metadata": {}
    },
    {
      "experimentID": "4bd964f3-1936-452f-a744-fcdffc938976",
      "sessionId": "nPreguntasmdns_result_a1bcea0f-9e74-4c58-beb9-3576060de831",
      "createdAt": "2026-01-16T05:53:12.141Z",
      "data": [],
      "state": "initiated",
      "lastUpdate": "2026-01-16T05:53:12.141Z",
      "metadata": {}
    },
    {
      "experimentID": "4bd964f3-1936-452f-a744-fcdffc938976",
      "sessionId": "nPreguntasmdns_result_3a16ee66-8243-4dfb-9211-071ee06cb73b",
      "createdAt": "2026-01-16T05:53:15.964Z",
      "data": [],
      "state": "initiated",
      "lastUpdate": "2026-01-16T05:53:15.964Z",
      "metadata": {}
    },
    {
      "experimentID": "4bd964f3-1936-452f-a744-fcdffc938976",
      "sessionId": "nPreguntasmdns_result_8d2ab82f-b767-49bc-89c4-5395d35e0c45",
      "createdAt": "2026-01-16T05:53:17.898Z",
      "data": [],
      "state": "initiated",
      "lastUpdate": "2026-01-16T05:53:17.898Z",
      "metadata": {}
    },
    {
      "experimentID": "4bd964f3-1936-452f-a744-fcdffc938976",
      "sessionId": "nPreguntasmdns_result_fa1a557e-d507-4216-b805-82e438b78492",
      "createdAt": "2026-01-16T05:53:18.359Z",
      "data": [],
      "state": "initiated",
      "lastUpdate": "2026-01-16T05:53:18.359Z",
      "metadata": {}
    },
    {
      "experimentID": "4bd964f3-1936-452f-a744-fcdffc938976",
      "sessionId": "nPreguntasmdns_result_4dc2512d-e821-44c3-8539-5502188f0b00",
      "createdAt": "2026-01-16T05:53:20.720Z",
      "data": [],
      "state": "initiated",
      "lastUpdate": "2026-01-16T05:53:20.720Z",
      "metadata": {}
    },
    {
      "experimentID": "4bd964f3-1936-452f-a744-fcdffc938976",
      "sessionId": "nPreguntasmdns_result_2948627a-4459-4dcc-a232-513094dbdf9b",
      "createdAt": "2026-01-16T05:53:23.251Z",
      "data": [],
      "state": "initiated",
      "lastUpdate": "2026-01-16T05:53:23.251Z",
      "metadata": {}
    },
    {
      "experimentID": "4bd964f3-1936-452f-a744-fcdffc938976",
      "sessionId": "nPreguntasmdns_result_cb2bf44a-5bc4-4977-a269-139d78715156",
      "createdAt": "2026-01-16T05:53:24.077Z",
      "data": [],
      "state": "initiated",
      "lastUpdate": "2026-01-16T05:53:24.077Z",
      "metadata": {}
    },
    {
      "experimentID": "4bd964f3-1936-452f-a744-fcdffc938976",
      "sessionId": "nPreguntasmdns_result_baadee80-001b-418c-a70c-99381856da96",
      "createdAt": "2026-01-16T05:53:24.724Z",
      "data": [],
      "state": "initiated",
      "lastUpdate": "2026-01-16T05:53:24.724Z",
      "metadata": {}
    },
    {
      "experimentID": "4bd964f3-1936-452f-a744-fcdffc938976",
      "sessionId": "nPreguntasmdns_result_3939eade-f638-461f-a8bc-888c7e3344b3",
      "createdAt": "2026-01-16T06:16:24.894Z",
      "data": [],
      "state": "initiated",
      "lastUpdate": "2026-01-16T06:16:24.894Z",
      "metadata": {}
    },
    {
      "experimentID": "4bd964f3-1936-452f-a744-fcdffc938976",
      "sessionId": "nPreguntasmdns_result_4b7f473e-8c4c-48a3-8d7a-78a40d0f61a7",
      "createdAt": "2026-01-16T06:16:29.290Z",
      "data": [],
      "state": "initiated",
      "lastUpdate": "2026-01-16T06:16:29.290Z",
      "metadata": {}
    },
    {
      "experimentID": "4bd964f3-1936-452f-a744-fcdffc938976",
      "sessionId": "nPreguntasmdns_result_b1545b1c-774f-473f-9abd-0223f2a3c61d",
      "createdAt": "2026-01-16T06:16:35.549Z",
      "data": [],
      "state": "initiated",
      "lastUpdate": "2026-01-16T06:16:35.549Z",
      "metadata": {}
    },
    {
      "experimentID": "4bd964f3-1936-452f-a744-fcdffc938976",
      "sessionId": "locaod_result_f727ec97-a12c-41c6-9b6a-06fb70b67728",
      "createdAt": "2026-01-16T06:16:39.125Z",
      "data": [],
      "state": "initiated",
      "lastUpdate": "2026-01-16T06:16:39.125Z",
      "metadata": {}
    },
    {
      "experimentID": "4bd964f3-1936-452f-a744-fcdffc938976",
      "sessionId": "locaod_result_db458bde-9658-481d-9fe9-2cc578a1d70c",
      "createdAt": "2026-01-16T06:16:42.199Z",
      "data": [],
      "state": "initiated",
      "lastUpdate": "2026-01-16T06:16:42.199Z",
      "metadata": {}
    },
    {
      "experimentID": "4bd964f3-1936-452f-a744-fcdffc938976",
      "sessionId": "locaod_result_c2207b8a-8049-4de2-afaf-3060a7406ba9",
      "createdAt": "2026-01-16T06:18:11.559Z",
      "data": [],
      "state": "initiated",
      "lastUpdate": "2026-01-16T06:18:11.559Z",
      "metadata": {}
    },
    {
      "experimentID": "4bd964f3-1936-452f-a744-fcdffc938976",
      "sessionId": "nPreguntasmdns_result_81e3cbea-fc0f-4364-90e5-6c95f52039f1",
      "createdAt": "2026-01-16T06:18:17.065Z",
      "data": [],
      "state": "initiated",
      "lastUpdate": "2026-01-16T06:18:17.065Z",
      "metadata": {}
    },
    {
      "experimentID": "4bd964f3-1936-452f-a744-fcdffc938976",
      "sessionId": "nPreguntasmdns_result_280aee54-9489-4ea0-bde4-8fb3c235a907",
      "createdAt": "2026-01-16T06:18:22.380Z",
      "data": [],
      "state": "initiated",
      "lastUpdate": "2026-01-16T06:18:22.380Z",
      "metadata": {}
    },
    {
      "experimentID": "4bd964f3-1936-452f-a744-fcdffc938976",
      "sessionId": "nPreguntasmdns_result_48520b81-2bf4-4c8a-bbfa-84a4f5935d83",
      "createdAt": "2026-01-16T06:18:27.432Z",
      "data": [],
      "state": "initiated",
      "lastUpdate": "2026-01-16T06:18:27.432Z",
      "metadata": {}
    },
    {
      "experimentID": "4bd964f3-1936-452f-a744-fcdffc938976",
      "sessionId": "nPreguntasmdns_result_511617b4-5eab-4425-b8a7-9d857095b200",
      "createdAt": "2026-01-16T06:18:30.263Z",
      "data": [],
      "state": "initiated",
      "lastUpdate": "2026-01-16T06:18:30.263Z",
      "metadata": {}
    },
    {
      "experimentID": "4bd964f3-1936-452f-a744-fcdffc938976",
      "sessionId": "nPreguntasmdns_result_9ece69c1-6878-4aba-9935-d2bd990ccd0f",
      "createdAt": "2026-01-16T06:18:33.339Z",
      "data": [],
      "state": "initiated",
      "lastUpdate": "2026-01-16T06:18:33.339Z",
      "metadata": {}
    },
    {
      "experimentID": "4bd964f3-1936-452f-a744-fcdffc938976",
      "sessionId": "nPreguntasmdns_result_3ede58db-cad1-41db-8af0-7acb79d23984",
      "createdAt": "2026-01-16T06:18:36.169Z",
      "data": [],
      "state": "initiated",
      "lastUpdate": "2026-01-16T06:18:36.169Z",
      "metadata": {}
    }
  ]
}