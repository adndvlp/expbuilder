<!DOCTYPE html><html lang="en"><head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/png+xml" href="/icon/fp black.png">
    <title>Experiment</title>

    <link href="../jspsych-bundle/index.css" rel="stylesheet" type="text/css">
    <script src="https://cdn.jsdelivr.net/gh/jspsych/jspsych@jspsych@7.0.0/examples/js/webgazer/webgazer.js"></script>

    <script src="../jspsych-bundle/index.js"></script>

    <style>
      body {
        margin: 0;
        padding: 0;
        background-color: #f0f0f0;
      }
      #jspsych-container {
        width: 100%;
        height: 100vh;
      }
      #jspsych-target {
        width: 100%;
      }
    </style>
  </head>
  <body>
    <div id="jspsych-container">
      <div id="jspsych-target"></div>
    </div>

    
  

<script id="generated-script">


        const trialSessionId =
            "Loopsiono_result_" + (crypto.randomUUID
              ? crypto.randomUUID()
              : Math.random().toString(36).slice(2, 10));

        let participantNumber;

          async function saveSession(trialSessionId) {
          const res = await fetch("/api/append-result/35c481f1-13f2-43a6-9aee-54e1e0bc2e42", {
            method: "POST",
            headers: { "Content-Type": "application/json", Accept: "*/*" },
            body: JSON.stringify({
              sessionId: trialSessionId,
            }),
          });

          const result = await res.json();
          participantNumber = result.participantNumber;
          return participantNumber;
    }
(async () => {
localStorage.removeItem('jsPsych_jumpToTrial');
  participantNumber = await saveSession(trialSessionId);

  if (typeof participantNumber !== "number" || isNaN(participantNumber)) {
    alert("The participant number is not assigned. Please, wait.");
    throw new Error("participantNumber not assigned");
  }
    const jsPsych = initJsPsych({
    display_element: document.getElementById('jspsych-container'),
          on_data_update: function (data) {
            const res = fetch("/api/append-result/35c481f1-13f2-43a6-9aee-54e1e0bc2e42", {
              method: "PUT",
              headers: { "Content-Type": "application/json", Accept: "*/*" },
              body: JSON.stringify({
                sessionId: trialSessionId,
                response: data,
              }),
            });
        
          },

          on_finish: function() {
              jsPsych.data.displayData();
          },
    });

      const timeline = [];
      
      
    const test_stimuli_Loopsiono = [{components: [{ type: "HtmlComponent", coordinates: {"x":0,"y":0}, width: 200, height: 50, name: "HtmlComponent_1", stimulus: "<div id=\"ip0u\" style=\"box-sizing: border-box;\">loop?</div>" }],
response_components: [{ type: "ButtonResponseComponent", coordinates: {"x":-0.016393442622950838,"y":0.4207650273224042}, width: 200, height: 50, name: "ButtonResponseComponent_1", choices: ["si", "no", "nose"] }]}];
    const Loopsiono_timeline = {
    type: DynamicPlugin, components: jsPsych.timelineVariable("components"),
response_components: jsPsych.timelineVariable("response_components"),
      data: {
        rt: "rt",
        trial_id: 1769054412868,
        
        
        branches: [1769054414149, "loop_1769054420851"],
        branchConditions: [[{"id":1769125088942,"rules":[{"column":"","op":"==","value":"nose","fieldType":"response_components","componentIdx":"ButtonResponseComponent_1","prop":"response"}],"nextTrialId":"1769054414149","customParameters":{}},{"id":1769125796392,"rules":[{"column":"","op":"==","value":"si","fieldType":"response_components","componentIdx":"ButtonResponseComponent_1","prop":"response"}],"nextTrialId":"loop_1769054420851","customParameters":{}},{"id":1769128638211,"rules":[{"column":"","op":"==","value":"no","fieldType":"response_components","componentIdx":"ButtonResponseComponent_1","prop":"response"}],"nextTrialId":"1769054414149","customParameters":{"response_components::ButtonResponseComponent_2::choices":{"source":"typed","value":["colalocalcoa"]}}}]] 
        
      },
    on_start: function(trial) {
      // First, evaluate and apply params override conditions (if any)
      const paramsOverrideConditions = [{"id":1769122722267,"rules":[{"trialId":"","column":"","op":"==","value":"","prop":""}],"paramsToOverride":{}}];
      
      // Evaluate params override conditions
      for (const condition of paramsOverrideConditions) {
        if (!condition || !condition.rules) {
          continue;
        }
        
        // Get data from all previous trials
        const allData = jsPsych.data.get().values();
        
        // Check if all rules match (AND logic within condition)
        const allRulesMatch = condition.rules.every(rule => {
          if (!rule.trialId) {
            return false;
          }
          
          // Find data from the referenced trial
          const trialData = allData.filter(d => {
            // Compare both as strings to handle type mismatches
            return String(d.trial_id) === String(rule.trialId) || d.trial_id === rule.trialId;
          });
          if (trialData.length === 0) {
            return false;
          }
          
          // Use the most recent data if multiple exist
          const data = trialData[trialData.length - 1];
          
          // Construct column name if empty (for dynamic plugins)
          let columnName = rule.column || "";
          if (!columnName && rule.componentIdx && rule.prop) {
            columnName = rule.componentIdx + '_' + rule.prop;
          }
          
          // Get the property value using the column name
          const propValue = data[columnName || rule.prop];
          const compareValue = rule.value;
          
          // Handle array responses (multi-select questions)
          if (Array.isArray(propValue)) {
            // For array values, check if compareValue is included in the array
            switch (rule.op) {
              case '==':
                return propValue.includes(compareValue);
              case '!=':
                return !propValue.includes(compareValue);
              default:
                return false; // Comparison operators don't make sense for arrays
            }
          }
          
          // Convert values for comparison (for non-array values)
          const numPropValue = parseFloat(propValue);
          const numCompareValue = parseFloat(compareValue);
          const isNumeric = !isNaN(numPropValue) && !isNaN(numCompareValue);
          
          switch (rule.op) {
            case '==':
              return isNumeric ? numPropValue === numCompareValue : propValue == compareValue;
            case '!=':
              return isNumeric ? numPropValue !== numCompareValue : propValue != compareValue;
            case '>':
              return isNumeric && numPropValue > numCompareValue;
            case '<':
              return isNumeric && numPropValue < numCompareValue;
            case '>=':
              return isNumeric && numPropValue >= numCompareValue;
            case '<=':
              return isNumeric && numPropValue <= numCompareValue;
            default:
              return false;
          }
        });
        
        // If all rules match, apply parameter overrides
        if (allRulesMatch && condition.paramsToOverride) {
          Object.entries(condition.paramsToOverride).forEach(([key, param]) => {
            if (param && param.source !== 'none') {
              // Parse key to check structure
              const parts = key.split('::');
              
              if (parts.length === 4) {
                // Format: fieldType::componentName::survey_json::questionName
                const [fieldType, componentName, propName, questionName] = parts;
                
                if (fieldType && componentName && propName === 'survey_json' && questionName) {
                  // Find the component by name in the field array
                  const fieldArray = trial[fieldType];
                  
                  if (Array.isArray(fieldArray)) {
                    const compIndex = fieldArray.findIndex(c => c.name === componentName);
                    
                    if (compIndex !== -1 && fieldArray[compIndex].survey_json) {
                      // Find the question in survey_json.elements
                      const elements = fieldArray[compIndex].survey_json.elements || [];
                      const questionIndex = elements.findIndex(q => q.name === questionName);
                      
                      if (questionIndex !== -1) {
                        // Apply the override value (from typed or csv)
                        let valueToSet;
                        if (param.source === 'typed') {
                          valueToSet = String(param.value); // Convert to string for SurveyJS
                        } else if (param.source === 'csv') {
                          valueToSet = String(trial[param.value]); // Get from CSV column and convert to string
                        }
                        
                        if (valueToSet !== undefined && valueToSet !== null) {
                          fieldArray[compIndex].survey_json.elements[questionIndex].defaultValue = valueToSet;
                        }
                      }
                    }
                  }
                }
              } else if (parts.length === 3) {
                // Format: fieldType::componentName::property (for dynamic plugin components like ButtonResponseComponent)
                const [fieldType, componentName, propName] = parts;
                
                if (fieldType && componentName && propName) {
                  // Find the component by name in the field array
                  const fieldArray = trial[fieldType];
                  
                  if (Array.isArray(fieldArray)) {
                    const compIndex = fieldArray.findIndex(c => c.name === componentName);
                    
                    if (compIndex !== -1) {
                      // Apply the override value
                      let valueToSet;
                      if (param.source === 'typed') {
                        valueToSet = param.value;
                      } else if (param.source === 'csv') {
                        valueToSet = trial[param.value]; // Get from CSV column
                      }
                      
                      if (valueToSet !== undefined && valueToSet !== null) {
                        fieldArray[compIndex][propName] = valueToSet;
                      }
                    }
                  }
                }
              } else {
                // Normal parameter (not nested)
                if (param.source === 'typed' && param.value !== undefined && param.value !== null) {
                  trial[key] = param.value;
                } else if (param.source === 'csv' && param.value !== undefined && param.value !== null) {
                  // For CSV source, param.value contains the column name, get the actual value from trial
                  trial[key] = trial[param.value];
                }
              }
            }
          });
          // Break after first matching condition (OR logic between conditions)
          break;
        }
      }
      
      // Then apply custom parameters from branching conditions (higher priority)
      // For trials outside loops, use window.branchCustomParameters
      if (window.branchCustomParameters && typeof window.branchCustomParameters === 'object') {
        Object.entries(window.branchCustomParameters).forEach(([key, param]) => {
          if (param && param.source !== 'none') {
            // Parse key to check if it's a nested survey question
            const parts = key.split('::');
            
            if (parts.length === 4) {
              // Format: fieldType::componentName::survey_json::questionName
              const [fieldType, componentName, propName, questionName] = parts;
              
              if (fieldType && componentName && propName === 'survey_json' && questionName) {
                // Find the component by name in the field array
                const fieldArray = trial[fieldType];
                if (Array.isArray(fieldArray)) {
                  const compIndex = fieldArray.findIndex(c => c.name === componentName);
                  if (compIndex !== -1 && fieldArray[compIndex].survey_json) {
                    // Find the question in survey_json.elements
                    const elements = fieldArray[compIndex].survey_json.elements || [];
                    const questionIndex = elements.findIndex(q => q.name === questionName);
                    
                    if (questionIndex !== -1) {
                      // Apply the override value (from typed or csv)
                      let valueToSet;
                      if (param.source === 'typed') {
                        valueToSet = String(param.value); // Convert to string for SurveyJS
                      } else if (param.source === 'csv') {
                        valueToSet = String(trial[param.value]); // Get from CSV column and convert to string
                      }
                      
                      if (valueToSet !== undefined && valueToSet !== null) {
                        fieldArray[compIndex].survey_json.elements[questionIndex].defaultValue = valueToSet;
                      }
                    }
                  }
                }
              }
            } else if (parts.length === 3) {
              // Format: fieldType::componentName::property (for DynamicPlugin components)
              const [fieldType, componentName, propName] = parts;
              
              if (fieldType && componentName && propName) {
                // Find the component by name in the field array
                const fieldArray = trial[fieldType];
                if (Array.isArray(fieldArray)) {
                  const compIndex = fieldArray.findIndex(c => c.name === componentName);
                  if (compIndex !== -1) {
                    // Apply the override value (from typed or csv)
                    let valueToSet;
                    if (param.source === 'typed') {
                      valueToSet = param.value;
                    } else if (param.source === 'csv') {
                      valueToSet = trial[param.value];
                    }
                    
                    if (valueToSet !== undefined && valueToSet !== null) {
                      fieldArray[compIndex][propName] = valueToSet;
                    }
                  }
                }
              }
            } else {
              // Normal parameter (not nested survey question)
              if (param.source === 'typed' && param.value !== undefined && param.value !== null) {
                trial[key] = param.value;
              } else if (param.source === 'csv' && param.value !== undefined && param.value !== null) {
                trial[key] = trial[param.value];
              }
            }
          }
        });
        // Clear the custom parameters after applying them
        window.branchCustomParameters = null;
      }
      
    },
    on_finish: function(data) {
      // Evaluar condiciones del trial para branching global
      console.log('ðŸ” [GLOBAL BRANCH] Evaluating branch conditions...');
      const branches = [1769054414149, "loop_1769054420851"];
      const branchConditions = [{"id":1769125088942,"rules":[{"column":"","op":"==","value":"nose","fieldType":"response_components","componentIdx":"ButtonResponseComponent_1","prop":"response"}],"nextTrialId":"1769054414149","customParameters":{}},{"id":1769125796392,"rules":[{"column":"","op":"==","value":"si","fieldType":"response_components","componentIdx":"ButtonResponseComponent_1","prop":"response"}],"nextTrialId":"loop_1769054420851","customParameters":{}},{"id":1769128638211,"rules":[{"column":"","op":"==","value":"no","fieldType":"response_components","componentIdx":"ButtonResponseComponent_1","prop":"response"}],"nextTrialId":"1769054414149","customParameters":{"response_components::ButtonResponseComponent_2::choices":{"source":"typed","value":["colalocalcoa"]}}}].flat();
      console.log('ðŸ” [GLOBAL BRANCH] Available branches:', branches);
      console.log('ðŸ” [GLOBAL BRANCH] Conditions to evaluate:', branchConditions.length);
      
      let nextTrialId = null;
      let matchedCustomParameters = null;
      
      // Evaluar cada condiciÃ³n (lÃ³gica OR entre condiciones)
      for (const condition of branchConditions) {
        if (!condition || !condition.rules) {
          continue;
        }
        
        // Todas las reglas en una condiciÃ³n deben ser verdaderas (lÃ³gica AND)
        const allRulesMatch = condition.rules.every(rule => {
          let propValue;
          
          // Parse column name to extract component info for dynamic plugins
          // Format: "componentName_propertyName" or "componentName_questionName" for surveys
          // If column is empty, construct it from componentIdx and prop
          let columnName = rule.column || "";
          if (!columnName && rule.componentIdx && rule.prop) {
            columnName = rule.componentIdx + '_' + rule.prop;
          }
          const parts = columnName.split("_");
          
          // Check if this looks like a dynamic plugin column (has underscore)
          if (parts.length >= 2) {
            // Last part is the property or question name
            const propertyOrQuestion = parts[parts.length - 1];
            // Everything before the last underscore is the component name
            const componentName = parts.slice(0, -1).join("_");
            
            // Try to find the data in the format: componentName_response
            const responseKey = componentName + '_response';
            const responseData = data[responseKey];
            
            // If response data exists and is an object (SurveyComponent case)
            if (responseData && typeof responseData === 'object' && !Array.isArray(responseData)) {
              // This is likely a survey response - check if property is a question name
              if (responseData[propertyOrQuestion] !== undefined) {
                propValue = responseData[propertyOrQuestion];
              } else {
                return false;
              }
            } else {
              // Not a survey response object, try direct property access
              const directKey = componentName + '_' + propertyOrQuestion;
              if (data[directKey] !== undefined) {
                propValue = data[directKey];
              } else {
                return false;
              }
            }
          } else {
            // Normal plugin structure - direct property access
            propValue = data[columnName];
          }
          
          const compareValue = rule.value;
          
          // Handle array responses (multi-select or single-select returned as array)
          if (Array.isArray(propValue)) {
            const matches = propValue.includes(compareValue) || propValue.includes(String(compareValue));
            switch (rule.op) {
              case '==':
                return matches;
              case '!=':
                return !matches;
              default:
                return false;
            }
          }
          
          // Convertir valores para comparaciÃ³n
          const numPropValue = parseFloat(propValue);
          const numCompareValue = parseFloat(compareValue);
          const isNumeric = !isNaN(numPropValue) && !isNaN(numCompareValue);
          
          switch (rule.op) {
            case '==':
              return isNumeric ? numPropValue === numCompareValue : propValue == compareValue;
            case '!=':
              return isNumeric ? numPropValue !== numCompareValue : propValue != compareValue;
            case '>':
              return isNumeric && numPropValue > numCompareValue;
            case '<':
              return isNumeric && numPropValue < numCompareValue;
            case '>=':
              return isNumeric && numPropValue >= numCompareValue;
            case '<=':
              return isNumeric && numPropValue <= numCompareValue;
            default:
              return false;
          }
        });
        
        if (allRulesMatch) {
          console.log('âœ… [GLOBAL BRANCH] Condition matched! Next trial:', condition.nextTrialId);
          nextTrialId = condition.nextTrialId;
          // Store custom parameters if they exist
          if (condition.customParameters) {
            matchedCustomParameters = condition.customParameters;
            console.log('âœ… [GLOBAL BRANCH] Custom parameters:', matchedCustomParameters);
          }
          break;
        }
      }
      
      // Si se encontrÃ³ match, activar branching
      if (nextTrialId) {
        console.log('ðŸŽ¯ [GLOBAL BRANCH] Activating branching to trial:', nextTrialId);
        window.nextTrialId = nextTrialId;
        window.skipRemaining = true;
        window.branchingActive = true;
        // Store custom parameters for the next trial
        if (matchedCustomParameters) {
          window.branchCustomParameters = matchedCustomParameters;
        }
      } else {
        // No match - ir al primer branch por defecto
        console.log('âš ï¸ [GLOBAL BRANCH] No condition matched, branching to first branch:', branches[0]);
        window.nextTrialId = branches[0];
        window.skipRemaining = true;
        window.branchingActive = true;
      }
      
    },};
    const Loopsiono_procedure = {
    timeline: 
    [Loopsiono_timeline],
    timeline_variables: test_stimuli_Loopsiono,
    
    conditional_function: function() {
      const currentId = 1769054412868;
      
      // Verificar si hay un trial objetivo guardado en localStorage (para repeat/jump)
      const jumpToTrial = localStorage.getItem('jsPsych_jumpToTrial');
      if (jumpToTrial) {
        if (String(currentId) === String(jumpToTrial)) {
          // Encontramos el trial objetivo para repeat/jump
          console.log('ðŸ” [REPEAT/JUMP] Found target trial', currentId);
          localStorage.removeItem('jsPsych_jumpToTrial');
          return true;
        }
        // No es el objetivo, saltar
        console.log('â­ï¸ [REPEAT/JUMP] Skipping trial', currentId);
        return false;
      }
      
      // Si skipRemaining estÃ¡ activo (branching normal), verificar si este es el trial objetivo
      if (window.skipRemaining) {
        console.log('ðŸ” [SKIP CHECK] Trial', currentId, '| Target:', window.nextTrialId, '| Match:', String(currentId) === String(window.nextTrialId));
        if (String(currentId) === String(window.nextTrialId)) {
          // Encontramos el trial objetivo
          console.log('âœ… [SKIP CHECK] Found target trial! Disabling skip mode');
          window.skipRemaining = false;
          window.nextTrialId = null;
          return true;
        }
        // No es el objetivo, saltar
        console.log('â­ï¸ [SKIP CHECK] Skipping trial', currentId);
        return false;
      }
      
      return true;
    },
  
    
    };
    timeline.push(Loopsiono_procedure);
  

      jsPsych.run(timeline);
      
      })()
      
</script></body></html>